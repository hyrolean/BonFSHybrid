diff -uPr BonD_FSHybrid-20201009_org/how_to_building.txt BonD_FSHybrid-20201009_mod10.1/how_to_building.txt
--- BonD_FSHybrid-20201009_org/how_to_building.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/how_to_building.txt	2020-10-19 14:08:44.000000000 +0900
@@ -0,0 +1,132 @@
+How to build FSHybrid series' solution packages.
+
+\[Vt@C̎ނƂ̊֌W
+
+  ^[Qbg̎ނƊɉč\z\[VIĂB
+  iׂẴ\[V𖳗ɍ\zKv͂ȂłBj
+
+  e\[Vt@ĆAsrc tH_zɈʒuĂ܂B
+
+  src\FSHybrid.sln
+   E\zF VisualStudio 2015 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_FSHybrid.dll/BonDriver_FSHybrid_x64.dll
+   ETvF oN]̂ݑΉ[v:WindowsVistaSP2ȍ~OS]
+   E戵F readme_mod_FSHybrid.txt
+
+  src\FSHybrid_isoch.sln
+   E\zF VisualStudio 2015 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_FSHybrid_isoch.dll/BonDriver_FSHybrid_isoch_x64.dll
+   ETvF oN]ƃAC\NiX]̗ɑΉ[v:Windows8.1ȍ~OS]
+   E戵F readme_mod_FSHybrid.txt
+
+  src\uSUNpTV.sln
+   E\zF VisualStudio 2015 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_uSUNpTV.dll/BonDriver_uSUNpTV_x64.dll
+   ETvF oN]̂ݑΉ[v:WindowsVistaSP2ȍ~OS]
+   E戵F readme_mod_uSUNpTV.txt
+
+  src\uSUNpTV_isoch.sln
+   E\zF VisualStudio 2015 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_uSUNpTV_isoch.dll/BonDriver_uSUNpTV_isoch_x64.dll
+   ETvF oN]ƃAC\NiX]̗ɑΉ[v:Windows8.1ȍ~OS]
+   E戵F readme_mod_uSUNpTV.txt
+
+  src\FSUSB2N.sln
+   E\zF VisualStudio 2015 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_FSUSB2N.dll/BonDriver_FSUSB2N_x64.dll
+   ETvF oN]̂ݑΉ[v:WindowsVistaSP2ȍ~OS]
+   E戵F readme_mod_FSUSB2N.txt
+
+  src\FSUSB2N_isoch.sln
+   E\zF VisualStudio 2015 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_FSUSB2N_isoch.dll/BonDriver_FSUSB2N_isoch_x64.dll
+   ETvF oN]ƃAC\NiX]̗ɑΉ[v:Windows8.1ȍ~OS]
+   E戵F readme_mod_FSUSB2N.txt
+
+  src\FSUSB2i.sln
+   E\zF VisualStudio 2015 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_FSUSB2i.dll/BonDriver_FSUSB2i_x64.dll
+   ETvF oN]̂ݑΉ[v:WindowsVistaSP2ȍ~OS]
+   E戵F readme_mod_FSUSB2i.txt
+
+  (ȍ~́AKV[ŁBÎQpłB)
+
+  src\FSHybrid_VS2008.sln
+   E\zF VisualStudio 2008 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_FSHybrid.dll/BonDriver_FSHybrid_x64.dll
+   ETvF oN]̂ݑΉ[v:WindowsXpSP2ȍ~OS]
+   E戵F readme_mod_FSHybrid.txt
+
+  src\uSUNpTV_VS2008.sln
+   E\zF VisualStudio 2008 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_uSUNpTV.dll/BonDriver_uSUNpTV_x64.dll
+   ETvF oN]̂ݑΉ[v:WindowsXpSP2ȍ~OS]
+   E戵F readme_mod_uSUNpTV.txt
+
+  src\FSUSB2N_VS2008.sln
+   E\zF VisualStudio 2008 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_FSUSB2N.dll/BonDriver_FSUSB2N_x64.dll
+   ETvF oN]̂ݑΉ[v:WindowsXpSP2ȍ~OS]
+   E戵F readme_mod_FSUSB2N.txt
+
+  src\FSUSB2i_VS2008.sln
+   E\zF VisualStudio 2008 ȍ~ŃT|[gVC++\z
+   E^[QbgF BonDriver_FSUSB2i.dll/BonDriver_FSUSB2i_x64.dll
+   ETvF oN]̂ݑΉ[v:WindowsXpSP2ȍ~OS]
+   E戵F readme_mod_FSUSB2i.txt
+
+
+^[Qbg̍\z
+
+  e\[V^[QbgƂȂDLL\z/菇܂B
+
+  \zOɁAMicrosoft VisualStudio ̃CXg[ς܂ĂĂB
+  VisualStudio ́AȉURLɓ܂BCXg[ۂɂ́AMSVC C++
+  ̋@\IĂCXg[邱ƂYȂłB
+
+    URL: https://visualstudio.microsoft.com/ja/downloads/
+        iR~jeB[]ō\zo܂j
+
+     VisualStudio2019̏ꍇłACXg[鍀ڂIۂɁA
+      [N[h̗ "C++ɂfXNgbvJ" ڂɃ`FbN
+      CXg[ĂB"MSVCv142 VS2019 C++ x64/x86 rhc["
+      ECXg[̏ڍׂɑIĂ΂łB
+
+  @ \z\[V.sln_uNbN VisualStudio 𗧂グ
+    iȂɂꂽAׂāu͂v܂́uOKvœAl̂܂܉ʂj
+
+  A 㕔c[o[ Debug ƕ\ĂANbN Release I
+    iDebuǵAJҗp̃\[V\Ȃ̂ŁAKReleaseI邱)
+
+  B ^[Qbg̎ނɉAẢEׂ xZZ ƕ\Ă镔؂ւ
+
+      x86 / Win32  32rbgœ삷DLL𐶐 ( ʏ͂I )
+      x64  64rbgœ삷DLL𐶐 ( 64rbgAvŎgpꍇ )
+
+  C 㕔|rh|j[|\[Vrh|Iărh
+
+     [^[Qbg]́ÃhLgƓKwtH_ɍ쐬܂B
+      (AXXXXXXX_VS2008.sln̐vs2008tH_zɐ܂B)
+
+  ŕKvȂ̂́ADLLłBɐꂽEXPLIBȂǂ̃t@CQ
+   ́AɕKvł͂ȂׁAĂ܂ĂxႠ܂B
+
+  ꂽeDLL̐ݒsɂ́AsampletH_BonDriver_FSHybrid.ini
+   DLLƓtH_ɃRs[ēeҏW邱Ƃɂeݒ肪\łB
+
+  Windows8.1SDKKvȂǁArhɃG[\ꍇ́A\[V
+   ̍ă^[QbgsKv܂BẼ\[VGNXv[̈ꗗ
+   u\[V'XXXXXXX'vIAENbÑXs[hj[
+   "\[V̍ă^[Qbg"I"\[V̍ă^[Qbg"
+   _CAO\܂Bwɏ]ăvWFNgAbvO[hĂ
+   \zĂ݂ĂB(AbvO[h̍ڂ͊l̂܂܂ł̔łB)
+
+  \zDLL𑼂PCœۂɂ́A^CpbP[WKvɂȂ܂B
+   Ƃ΁AVisualStudio2019ō\zꍇ́AVC++2019̃^CpbP[W
+   \zDLL𓮍삳^[QbgPCɕʓrCXg[Kv܂B
+   VC++^CpbP[WɂẮAȉURL擾\Ȃ悤łB
+
+     URL: https://support.microsoft.com/ja-jp/help/2977003/the-latest-supported-visual-c-downloads
+
+
+ȏmV
diff -uPr BonD_FSHybrid-20201009_org/patching.txt BonD_FSHybrid-20201009_mod10.1/patching.txt
--- BonD_FSHybrid-20201009_org/patching.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/patching.txt	2020-10-09 01:01:23.000000000 +0900
@@ -0,0 +1,151 @@
+$B%Q%C%A$N=<$FJ}(B
+
+  $B0lEYL\$N%Q%C%A$G$OC1$K$3$N%U%!%$%k$H(Breadme$B$J$I$N%F%-%9%H72$,@8@.$5$l$k$@$1$@$H;W$o$l$k!#(B
+  $B0J2<$N9)Dx$rDI$&$3$H$K$h$C$F3F<+40A4$J%Q%C%A$r@8@.$9$k$3$H$,=PMh$k$+$b$7$l$J$$!#(B
+  $B>0!"$3$N%Q%C%A$r=<$F$k$3$H$K$h$C$FH/@8$7$?B;32$O%Q%C%A:n@.<T$O0l@ZJ]>Z$7$J$$$3$H$H$9$k!#(B
+
+
+$B"#2<=`Hw(B
+
+  $B-!0J2<$N%U%!%$%k$r%M%C%H$+$i=&$C$F$/$k(B
+
+    1) 33ac6f08023bf02372959acc05ff8174  fsusb2n-src-20120929.7z $B"((B1
+    2) d46988c458cb3e94208c138f69c77690  BonD_FSUSB2i-20160219.src.7z $B"((B2
+    3) ca92730e06a52de1a9ad66d6a08410d0  BonD_uSUNpTV-20160219.src.7z $B"((B3
+
+   $B"((B1: http://ktvwiki.22web.org/index.php?Download $B"+(B $B%3%3$GF~<j2D(B($B:G8eHx(B)
+   $B"((B2: http://ktvwiki.22web.org/index.php?BonDriver_FSUSB2i $B"+(B $B%3%3$GF~<j2D(B
+   $B"((B3: http://ktvwiki.22web.org/index.php?BonDriver_uSUNpTV $B"+(B $B%3%3$GF~<j2D(B
+
+  $B-"(Bfsusb2n-src-20120929.7z$B$rE83+$7$F0J2<$N=$@5$r2C$($k(B
+
+    1) $B%U%!%$%kL>$NJQ99(B FSUSB2N-src\BonTuner\BonTuner.vcproj $B"*(B FSUSB2N-src\BonTuner\BonTuner_FSUSB2N.vcproj
+    2) $B%U%!%$%kL>$NJQ99(B FSUSB2N-src\BonTuner\BonTuner.cpp $B"*(B FSUSB2N-src\BonTuner\BonTuner_FSUSB2N.cpp
+    3) $B%U%!%$%kL>$NJQ99(B FSUSB2N-src\BonTuner\BonTuner.h $B"*(B FSUSB2N-src\BonTuner\BonTuner_FSUSB2N.h
+    4) $B%U%)%k%@L>$NJQ99(B FSUSB2N-src\BonTuner $B"*(B FSUSB2N-src\BonTuner_FSUSB2N
+    5) $B%U%)%k%@L>$NJQ99(B FSUSB2N-src $B"*(B src
+
+  $B-#(BBonD_FSUSB2i-20160219.src.7z$B$rE83+$7$F0J2<$N=$@5$r2C$($k(B
+
+    1) $B%U%!%$%kL>$NJQ99(B src\BonTuner\BonTuner.cpp $B"*(B src\BonTuner\BonTuner_FSUSB2i.cpp
+    2) $B%U%!%$%kL>$NJQ99(B src\BonTuner\BonTuner.h $B"*(B src\BonTuner\BonTuner_FSUSB2i.h
+    3) $B%U%)%k%@L>$NJQ99(B src\BonTuner $B"*(B src\BonTuner_FSUSB2i
+
+  $B-$(BBonD_uSUNpTV-20160219.src.7z$B$rE83+$7$F0J2<$N=$@5$r2C$($k(B
+
+    1) $B%U%!%$%kL>$NJQ99(B src\BonTuner\BonTuner.cpp $B"*(B src\BonTuner\BonTuner_uSUNpTV.cpp
+    2) $B%U%!%$%kL>$NJQ99(B src\BonTuner\BonTuner.h $B"*(B src\BonTuner\BonTuner_uSUNpTV.h
+    3) $B%U%)%k%@L>$NJQ99(B src\BonTuner $B"*(B src\BonTuner_uSUNpTV
+
+  $B-%(Bsrc$B%U%)%k%@$rE}9g(B
+
+    $B>e5-$N#3$D$N%U%!%$%k$rE83+$7$F=$@5$r2C$($?7k2L=PMh$"$,$C$?#3$D$N8DJL$N(Bsrc$B%U%)%k%@$rF10l$N(Bsrc$B%U%)%k%@$H$7$F>e=q$-$7$FE}9g$9$k(B
+    $B"(=EJ#$9$k%U%!%$%k$O(B"$B?7$7$$%U%!%$%k(B"$B$NJ}$G>e=q$-$9$k$3$H!JF|IU$,F1$8$+8E$$%U%!%$%k$O%9%-%C%W$9$k!K(B
+
+  $B-&(Bsrc\inc\legacy$B%U%)%k%@$N:n@.$H%U%!%$%k$N0\F0(B
+  
+    $B=PMh>e$,$C$?E}9g%U%)%k%@(Bsrc$BG[2<$N(Binc$B%U%)%k%@$NCf$K(Blegacy$B$H$$$&?75,%U%)%k%@$r:n@.$7!"$=$N:n@.$7$?(Blegacy$B%U%)%k%@$K0J2<$N#29`L\$N%U%!%$%k$r0\F0$9$k(B
+    
+    1) $B%U%!%$%k$N0\F0(B src\inc\winusb.h $B"*(B src\inc\legacy\winusb.h
+    2) $B%U%!%$%k$N0\F0(B src\inc\winusbio.h $B"*(B src\inc\legacy\winusbio.h
+    
+  $B-'(BFSHybrid$B%U%)%k%@$r:n@.$7$F%k!<%H$K$9$k(B
+
+    $BE}9g$,40N;$7$?(Bsrc$B%U%)%k%@$HF13,AX>e$K(BFSHybrid$B%U%)%k%@$r:n$j!"(Bsrc$B%U%)%k%@$4$H(BFSHybrid$B%U%)%k%@$NCf$X0\F0$9$k(B
+
+  $B-(%G%#%l%/%H%j%D%j!<9=B$$r3NG'$9$k(B
+
+    $B%U%)%k%@$N3,AX$,0J2<$N$h$&$J%D%j!<9=B$$G9=@.$5$l$F$$$k$3$H$r3NG'$9$k(B
+
+     <FSHybrid>
+      `--<src>
+          |--<BonDriver_FSUSB2N>
+          |   |-- 14071a2340874b69b16a370107255b93  BonDriver.rc
+          |   |-- 5009476bd025d7ad3caa901da47fc628  BonDriver_FSUSB2N.vcproj
+          |   |-- 7b5e3739173d7de017e222b18947de85  BonTuner_FSUSB2N.cpp
+          |   |-- 9a813835243e70b1c7f19187baf560af  BonTuner_FSUSB2N.h
+          |   |-- cdbfc961c3dc8f0ac6c579ea586832b5  dllmain.cpp
+          |   |-- 65e6e3d79ad3ced6c525378dae395cd0  stdafx.cpp
+          |   `-- 38007ee695d8f22e79d0e76bc296a22e  stdafx.h
+          |--<BonDriver_FSUSB2i>
+          |   |-- 38854f78b814c2909db5298e48c85446  BonDriver.rc
+          |   |-- 9de57bf59af30d8aa6e3e0978a4ef8f5  BonDriver_FSUSB2i.vcxproj
+          |   |-- d577da9bbdcefc5cf476c29fcd062e00  BonDriver_FSUSB2i.vcxproj.filters $B"((B
+          |   |-- b7a22e70347383444c0c7fe9a77474eb  BonDriver_FSUSB2i.vcxproj.user $B"((B
+          |   |-- 251ae6943e2b406aea61be92c56a5c75  BonTuner_FSUSB2i.cpp
+          |   |-- e9f835dd28dd6ff7da7a477c00e19742  BonTuner_FSUSB2i.h
+          |   |-- 88a10878ae76f396798672be97c0fec1  dllmain.cpp
+          |   |-- 0f98e16fbd1fa15aebca4db062f1ef85  stdafx.c
+          |   |-- 6ab53a63f9a44cb6f5ecfd055a907134  stdafx.h
+          |   `-- 0f98e16fbd1fa15aebca4db062f1ef85  stdafx2.cpp
+          |--<BonDriver_uSUNpTV>
+          |   |-- 395e4076e8320ec201699bcbe5900003  BonDriver.rc
+          |   |-- 125cd70a7c437eb5d5e6ed4fe4710a3a  BonDriver_uSUNpTV.vcxproj
+          |   |-- 2bd50d33ef16b3bdd0bf66e9ea6d015c  BonDriver_uSUNpTV.vcxproj.filters $B"((B
+          |   |-- b7a22e70347383444c0c7fe9a77474eb  BonDriver_uSUNpTV.vcxproj.user $B"((B
+          |   |-- 203349afbc699a983bd88ad441ee459f  BonTuner_uSUNpTV.cpp
+          |   |-- 92cf0f2d7938860d46c990743429eeb2  BonTuner_uSUNpTV.h
+          |   |-- 88a10878ae76f396798672be97c0fec1  dllmain.cpp
+          |   |-- 0f98e16fbd1fa15aebca4db062f1ef85  stdafx.c
+          |   |-- 6ab53a63f9a44cb6f5ecfd055a907134  stdafx.h
+          |   `-- 0f98e16fbd1fa15aebca4db062f1ef85  stdafx2.cpp
+          |--<inc>
+          |   |-- ff2511620cb48e582be9ff138fb7ac7e  IBonDriver.h
+          |   |-- 01f7183a9e294c57dbd2527651a3dc5a  IBonDriver2.h
+          |   |-- 19385f4f504162ab3e5e9e78a714b688  usb.h
+          |   |-- 95e6b2dfedec517d62fb172f12790c38  usb100.h
+          |   |-- 3e4cf48f6585a52456b16403769eb631  usb200.h
+          |   `--<legacy>
+          |       |-- 85207bb61f771871b36aa9121ae25bbe  winusb.h
+          |       `-- 69cc6ce4c1d8ea195d746359c06ad78e  winusbio.h
+          |--<lib>
+          |   `-- 200155c22aa44ecd566b4290f56ef4df  winusb.lib
+          |--<lib64>
+          |   `-- 727449d734bfb2daad67568ff27efc0f  winusb.lib
+          |-- c2f62cf93ec519b33786ba49a4d7d6ef  FSUSB2i.sln
+          |-- 348c14eaa696d92a20c7ced00cdcf93b  em2874.cpp
+          |-- d21854b3f6a1a93d8e085dd4a337a38d  em2874.h
+          |-- afcb47262bef1a9c793a75b52771d084  em287x.c
+          |-- a086f2dd5a16ca1215a8586dc00a035a  em287x.h
+          |-- 6b0d232c8a6a76f9347cc40a68f1a4af  em287x_priv.h
+          |-- 6a7b277dcae7e35a43bc38b312938ac7  em287x_usb.c
+          |-- 08971f62053b3d04a5cc99eb536a1fed  em287x_usb.h
+          |-- f59f8b3850d5a23b99301c4fc9092d0f  it9175.c
+          |-- 8667f851f592562d4003087e5dba625b  it9175.h
+          |-- 754f3cbbdf52dcce297467d0e6a2520c  it9175_fw.h
+          |-- d38813a015adafb6b1bdd9a464a05b8d  it9175_priv.h
+          |-- 1326dc92706ba28b88a70bb5687a95ef  it9175_usb.c
+          |-- d8c5649a2bfcdf736f201a956b31e54d  it9175_usb.h
+          |-- 453f897bbe3f8f431641fc41d02d3e08  ktv.cpp
+          |-- 033750ec2dc3e8012ea3653635093db6  ktv.h
+          |-- 46cd3bf9afda7dc48e69f55475009f0d  message.c
+          |-- f5a991f0018935a543d2b915701555db  message.h
+          |-- aff132772e86436ba116c331d9634b9c  mxl136.c
+          |-- 584ca5fbc404fafa015dba0bbb442416  mxl136.h
+          |-- 153be3cf1c681c60b9659758224828f7  osdepend.c
+          |-- 3d14334c2f325708543bfa76ab7ed490  osdepend.h
+          |-- 62f70654d9b275f3c34ef8d6127bab8e  targetver.h
+          |-- b3019d7afcd706f21904b27ca50d2124  tc90522.c
+          |-- 150d362d4cf59e7d20f2a35d9d26ebfc  tc90522.h
+          |-- 51b884a54318b19ed9cbe84135881ac1  tda20142.c
+          |-- dd05eae951f8a24c1e867a41d16b091f  tda20142.h
+          |-- 3011e3daa628ab299caee6822fc11dc9  tsbuff.h
+          |-- a2c129561323cf41bd840b9672924a2f  tsthread.c
+          |-- 19296dc339524b226bc80a8629149471  tsthread.h
+          |-- 289e2c6f0d4955cc2d84962d3cd83072  twindbg.h
+          |-- 96dabbc3238c41ca178bd4ca9a9743b5  types_u.h
+          |-- b54f9e90fd9c2c885652fd602e57d60c  uSUNpTV.sln
+          |-- fb56b93a573dc4478b3fe88935662a4c  usbdevfile.cpp
+          |-- d4b4523c9754d3a612775dcbba7ab05f  usbdevfile.h
+          |-- 93c80d9dddf9bb6c6394b42a5aac5ea9  usbops.c
+          `-- 4962a4e00482019927089a06f4e20561  usbops.h
+
+    $B"((B: $B:o=|2D(B
+
+
+$B"#%Q%C%A$r=<$F$k(B
+
+  $B%7%'%k$r5/F0$7%+%l%s%H%G%#%l%/%H%j$r(BFSHybrid$B%U%)%k%@$K0\$7!"0J2<$N%3%^%s%I$r<B9T$7$F%Q%C%A$r40N;$5$;$k(B
+
+  patch -p1 --binary < BonD_FSHybrid_20201009_mod_xxxxxxxx.patch.diff
+
diff -uPr BonD_FSHybrid-20201009_org/readme_mod_FSHybrid.txt BonD_FSHybrid-20201009_mod10.1/readme_mod_FSHybrid.txt
--- BonD_FSHybrid-20201009_org/readme_mod_FSHybrid.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/readme_mod_FSHybrid.txt	2022-08-11 13:28:35.000000000 +0900
@@ -0,0 +1,141 @@
+BonDriver_FSHybrid.dll MOD @ 2022/8/11
+
+KEIAN/Digibestn3̋@\𓯎ɗLnCubh^BonDriver.dll
+
+  t@Cς邱Ƃɂ蓮ύX\
+  t@CK؂ɕύXȂƂƓ삵Ȃ̂Œ
+
+  BonDriver_FSHybrid.dll
+   BonDriver_FSUSB2N.dll / BonDriver_FSUSB2Nxxxxxx.dll 
+
+    FSUSB2V^(V2)A܂́AFSPCIE p BonDriver Ƃē
+
+      戵 : readme_mod_FSUSB2N.txt
+
+
+  BonDriver_FSHybrid.dll
+   BonDriver_FSUSB2i.dll / BonDriver_FSUSB2ixxxxxx.dll 
+
+    FSUSB2/V3A܂́AFSMINI p BonDriver Ƃē
+
+      戵 : readme_mod_FSUSB2i.txt
+
+
+  BonDriver_FSHybrid.dll
+   BonDriver_uSUNpTV.dll / BonDriver_uSUNpTVxxxxxx.dll 
+
+    US-3POUT (ςOo) p BonDriver Ƃē
+
+      戵 : readme_mod_uSUNpTV.txt
+
+
+  : xxxxxx ́ACӂ̉p
+
+
+XV
+
+2022/5/3 ̕ύX_
+
+  EAC\NiX]LɁA`l؂ւƂɋHɃXg[
+    Xg[(~)邱Ƃ̂錻ۂC
+
+2021/12/7 ̕ύX_
+
+  EeXBonDriverIBonTransponderC^[tFCXɑΉ
+
+  Einit@Cɍx^C}[gĊݐx߂邩ǂ肷
+    HIGH_PRECISE_INTERRUPT ڂǉ
+
+  EZ}tH̃^CAEgԓBɎMf[^ėꍇɃobt@
+    O~Ă܂Ƃ̂sCiAhbv܂݂j
+    (.init@CTSCACHING_BULKPACKETSIZE傫߂Ɣ͗lB
+     oN]̃obt@pPbg̃TCY傫TSXg[̃kpPb
+     gn[hIɏH`[i[̏\͂I[o[邽߂ɕp
+     ɋN鎖ۂ̂悤ŁȀꍇ́A.init@CTSCACHING_DROPNULLPACKETS
+     ̒lnɂ邱Ƃɂ\Ȗ͗lB)
+
+2021/3/18 ̕ύX_
+
+  Einit@CɃ`[i[ID蓖ĎIDzȉ̂Qڂǉ
+
+     DEVICE_ID_ROTATION / DEVICE_ID_ROTATION_VOLATILE
+
+2021/2/7 ̕ύX_
+
+  EeXBonDriverFastScan(`lXL)ɑΉ
+
+2020/11/22 ̕ύX_
+
+  Einit@CɈȉ̊̎Og`lzuݒɊւȉ̂Qڂǉ
+
+     DEF_SPACE_BS_STREAM_STRIDE / DEF_SPACE_CS110_STREAM_STRIDE
+
+2020/11/3 ̕ύX_
+
+  Einit@C TSTHREAD_NUMIO ڂɎwłől64256Ɋg[11/22]
+  Einit@CTSzXbhp}`^XNݒ荀 TSTHREAD_DUPLEX ǉ
+  Einit@CUSBfoCX̃AChȓd͋@\𖳌ɂ邩ǂ肷
+    邽߂̍ USBPOWERPOLICY_AVOID_SUSPEND ǉ
+
+2020/11/1 ̕ύX_
+
+  Einit@CɈȉ̍ڌQVɒǉ
+
+    TSTHREAD_POLL_TIMEOUT / TSTHREAD_SUBMIT_TIMEOUT / TSTHREAD_SUBMIT_IOLIMIT /
+	TSTHREAD_NUMIO / TSALLOC_TIMEOUT / TSALLOC_WAITING / TSALLOC_MODERATE /
+	TUNER_RETRY_DURATION
+
+2020/10/24 ̕ύX_
+
+  Einit@CTSXbh̗D揇ʂύX邱Ƃ̂łȉ̂Qڂǉ
+
+     TSTHREAD_PRIORITY / TSALLOC_PRIORITY
+
+2020/10/17 ̕ύX_
+
+  Einit@CɏvZ@\ȂƂ̂oOC[10/24rev2]
+  Einit@C̐ڂɌvZƂ̂ł@\ǉ
+
+2020/10/9 ̕ύX_
+
+  EAC\NiX]ׂ̕𑽏P
+  Einit@CNULLpPbgVbgAEg邩ǂ𔻒f邽߂̃tO
+    TSCACHING_DROPNULLPACKETS ڂǉ
+
+2020/6/20 ̕ύX_
+
+  Einit@CɃoN]̃pPbgTCYI[o[Ch邱Ƃ̂ł
+    TSCACHING_BULKPACKETSIZE ڂǉ
+
+  EAC\NiX]ɑΉȉ̃\[VVɒǉ
+
+     FSHybrid_isoch.sln / uSUNpTV_isoch.sln / FSUSB2N_isoch.sln
+
+2020/4/27 ̕ύX_
+
+  Einit@CɈȉ̎OñVOi擾rɊւtOǉ
+
+     FSUSB2N_LOCK_ON_SIGNAL / FSUSB2I_LOCK_ON_SIGNAL / USUNPTV_LOCK_ON_SIGNAL
+
+2020/1/12 ̕ύX_
+
+  EdBǂĂȂƂ肱ڂ̃v`hbvۂ̍{IȖC
+   iWinUsb̃pCvǏon̏rōsdg݂̃R[hǉđΉj
+
+2020/1/3 ̕ύX_
+
+  Einit@Cݒǂݍ߂@\ǉ
+    (TvƂBonDriver_FSHybrid.iniYt)
+
+  EfoCX̏Ɏsꍇ͊ōőR܂ōĎsdlɕύX
+
+2019/12/23 ̕ύX_
+
+  ER[ht@N^OăoCiTCY10KB팸
+
+
+gp
+
+  ۏ؁iNO WARRANTYj
+
+
diff -uPr BonD_FSHybrid-20201009_org/readme_mod_FSUSB2N.txt BonD_FSHybrid-20201009_mod10.1/readme_mod_FSUSB2N.txt
--- BonD_FSHybrid-20201009_org/readme_mod_FSUSB2N.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/readme_mod_FSUSB2N.txt	2022-05-03 14:54:28.000000000 +0900
@@ -0,0 +1,108 @@
+BonDriver_FSUSB2N.dll MOD @ 2022/5/3
+
+IWiłVɒǉ@\
+
+  EIDŌʎwł@\ǉ
+
+    BonDriver_FSUSB2N_dev + ID(ԍ) + .dll ̃t@C̋Lq@Ŏw\B
+    BonDriver_FSUSB2N_dev0.dll  ڑ1Ԗڂ̋@
+    BonDriver_FSUSB2N_dev1.dll  ڑ2Ԗڂ̋@
+    BonDriver_FSUSB2N_dev2.dll  ڑ3Ԗڂ̋@
+    LȊŐLq̏ꍇ́A󂢂Ă@킩珇ɒTIWiɏB
+    BonDriver_FSUSB2N_abc.dll ȂǂƋLqƂ܂܂Œʂ莩IDĂB
+
+
+  EƎ`lt@C@\ǉ
+
+    hCoƓOŊgq .ch.txt ɂ̂Ƀ`lLq
+    ƂɂƎ̃`lɃAW邱Ƃ\B
+    TvƂ BonDriver_FSUSB2N.ch.txt YtB
+
+
+XV
+
+2021/3/18 ̕ύX_
+
+  EIBonTransponderC^[tFCXɑΉ
+
+2020/10/9 ̕ύX_
+
+  EFastScanɑΉ ( .ini FSUSB2N_FASTSCAN[y/n]ŋ@\ؑ։ )
+
+2020/6/20 ̕ύX_
+
+  EWindows8.1ȍ~œ삷AC\NiX](ύXK0905̌)ɑΉv
+    WFNgt@C BonDriver_FSUSB2N_isoch.vcxproj Vɒǉ
+    (̃[hœ삳ꍇ́AύXK0905EEPROMɏĂB
+     \[Vt@C FSUSB2N_isoch.sln \zĂB)
+
+2020/5/22 ̕ύX_
+
+  EJ`[i[ۂɋHɃt[YsC
+
+2020/4/27 ̕ύX_
+
+  EVOi擾ɓ]~߂邩ǂ肷tO .ini ɒǉ
+    ( FSUSB2N_LOCK_ON_SIGNALŕύX\ l1<bN> )
+
+2019/12/22 ̕ύX_
+
+  EVOi擾̍œK
+
+2019/12/8 ̕ύX_
+
+  ELbVAP[^hbvNƂ̂oOC[12/22]
+
+  E\[Xɂ񓯊obt@Ɋւ鐔l𒲐[12/21(ES)]
+
+    pPbgTCY̕ύXɔA񓯊obt@Ɋւȉ̋Kl
+
+      ASYNCTS_QUEUENUM c obt@ Kl66  3M (47K*66) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl660 30M (47K*660) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl22 1MB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl11 0.5MB
+
+  ELbVAP[^̃ANZXG[sC[12/21(ES)]
+
+2019/12/7 ̕ύX_
+
+  EWXgɔ񓯊obt@ɊւIvVǉ
+
+    WXg HKEY_CURRENT_USER\Software\tri.dw.land.to\FSUSB2N 
+    ȉ̂SڂDWORDlŕύX\B
+
+      ASYNCTS_QUEUENUM c obt@ Kl32  2M (64K*32) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl320 20M (64K*320) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl12 750KB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl6 375KB
+
+2018/3/4 ̕ύX_
+
+  EWXgɃLbVOɊւIvVǉ
+
+    WXg HKEY_CURRENT_USER\Software\tri.dw.land.to\FSUSB2N 
+    "TSCACHING_LEGACY"ƂDWORDl쐬ĒlƂ"1"Lq
+    tri.dw.land.to񒼓`̃LbVœ삳邱Ƃ\B
+    (s̃LbVɖ߂ɂ͒l̂폜邩lƂ"0"Lq)
+
+  EFIFOobt@OœK
+
+    Hɔhbv̏CB
+
+2015/1/4 ̕ύX_
+
+  EJ VisualStudio 2015 ɕύX
+  EIDŌʎwł@\̃t@C̏
+	 BonDriver_FSUSB2_ + ԍ + .dll 
+	 BonDriver_FSUSB2N_dev + ԍ + .dll ɕύX
+
+2015/1/3 ̕ύX_
+
+  EPurgeTSStream() R[ƍňTSXg[XgbvoOC
+
+
+gp
+
+  ۏ؁iNO WARRANTYj
+
+
diff -uPr BonD_FSHybrid-20201009_org/readme_mod_FSUSB2i.txt BonD_FSHybrid-20201009_mod10.1/readme_mod_FSUSB2i.txt
--- BonD_FSHybrid-20201009_org/readme_mod_FSUSB2i.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/readme_mod_FSUSB2i.txt	2022-05-03 14:53:50.000000000 +0900
@@ -0,0 +1,85 @@
+BonDriver_FSUSB2i.dll MOD @ 2022/5/3
+
+IWiłVɒǉ@\
+
+  ELbV̐ؑւɑΉ(2019/12/7)
+
+    WXg HKEY_CURRENT_USER\Software\trinity19683\FSUSB2i 
+    "TSCACHING_LEGACY"ƂDWORDl쐬ĒlƂ"1"Lq
+    trinity19683񒼓`̃LbVœ삳邱Ƃ\B
+    (s̃LbVɖ߂ɂ͒l̂폜邩lƂ"0"Lq)
+
+  Eobt@̍œK
+
+    Hɔhbv̏CB
+
+  EIDŌʎwł@\ǉ
+
+    BonDriver_FSUSB2i_dev + ID(ԍ) + .dll ̃t@C̋Lq@Ŏw\B
+    BonDriver_FSUSB2i_dev0.dll  ڑꂽPԖڂFSUSB2/V3
+    BonDriver_FSUSB2i_dev1.dll  ڑꂽQԖڂFSUSB2/V3
+    BonDriver_FSUSB2i_dev2.dll  ڑꂽRԖڂFSUSB2/V3
+    LȊŐLq̏ꍇ́A󂢂Ă@킩珇ɒTIWiɏB
+    BonDriver_FSUSB2i_A.dll ȂǂƋLqƂ܂܂Œʂ莩IDĂB
+
+
+  EƎ`lt@C@\ǉ
+
+    hCoƓOŊgq .ch.txt ɂ̂Ƀ`lLq
+    ƂɂƎ̃`lɃAW邱Ƃ\B
+    TvƂ BonDriver_FSUSB2i.ch.txt YtB
+
+
+XV
+
+2021/3/18 ̕ύX_
+
+  EIBonTransponderC^[tFCXɑΉ
+
+2020/5/22 ̕ύX_
+
+  EFastScanɑΉ ( .ini FSUSB2I_FASTSCAN[y/n]ŋ@\ؑ։ )
+
+2020/4/27 ̕ύX_
+
+  EBonDriver_FSUSB2iL̍{Iȃv`hbvC[it9175.c(515)]
+  EVOi擾ɓ]~߂邩ǂ肷tO .ini ɒǉ
+    ( FSUSB2I_LOCK_ON_SIGNALŕύX\ l1<bN> )
+
+2019/12/22 ̕ύX_
+
+  EVOi擾̊ȗƍœK
+
+2019/12/8 ̕ύX_
+
+  ELbVAP[^hbvNƂ̂oOC[12/22]
+
+  E\[Xɂ񓯊obt@Ɋւ鐔l𒲐[12/21(ES)]
+
+    pPbgTCY̕ύXɔA񓯊obt@Ɋւȉ̋Kl
+
+      ASYNCTS_QUEUENUM c obt@ Kl66  3M (47K*66) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl660 30M (47K*660) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl22 1MB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl11 0.5MB
+
+  ELbVAP[^̃ANZXG[sC[12/21(ES)]
+
+2019/12/7 ̕ύX_
+
+  EWXgɔ񓯊obt@ɊւIvVǉ
+
+    WXg HKEY_CURRENT_USER\Software\trinity19683\FSUSB2i 
+    ȉ̂SڂDWORDlŕύX\B
+
+      ASYNCTS_QUEUENUM c obt@ Kl32  2M (64K*32) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl320 20M (64K*320) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl12 750KB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl6 375KB
+
+
+gp
+
+  ۏ؁iNO WARRANTYj
+
+
diff -uPr BonD_FSHybrid-20201009_org/readme_mod_uSUNpTV.txt BonD_FSHybrid-20201009_mod10.1/readme_mod_uSUNpTV.txt
--- BonD_FSHybrid-20201009_org/readme_mod_uSUNpTV.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/readme_mod_uSUNpTV.txt	2022-05-03 14:52:34.000000000 +0900
@@ -0,0 +1,108 @@
+BonDriver_uSUNpTV.dll MOD @ 2022/5/3
+
+IWiłVɒǉ@\
+
+  ELbV̐ؑւɑΉ(2019/12/7)
+
+    WXg HKEY_CURRENT_USER\Software\trinity19683\FSUSB2i 
+    "TSCACHING_LEGACY"ƂDWORDl쐬ĒlƂ"1"Lq
+    trinity19683񒼓`̃LbVœ삳邱Ƃ\B
+    (s̃LbVɖ߂ɂ͒l̂폜邩lƂ"0"Lq)
+
+  ELbVŐ(2019/12/1)
+
+    obt@ỎP
+
+  EIDŌʎwł@\ǉ
+
+    BonDriver_uSUNpTV_dev + ID(ԍ) + .dll ̃t@C̋Lq@Ŏw\B
+    BonDriver_uSUNpTV_dev0.dll  ڑꂽPԖڂUS-3POUT
+    BonDriver_uSUNpTV_dev1.dll  ڑꂽQԖڂUS-3POUT
+    BonDriver_uSUNpTV_dev2.dll  ڑꂽRԖڂUS-3POUT
+    LȊŐLq̏ꍇ́A󂢂Ă@킩珇ɒTIWiɏB
+    BonDriver_uSUNpTV_A.dll ȂǂƋLqƂ܂܂Œʂ莩IDĂB
+
+
+  EƎ`lt@C@\ǉ
+
+    hCoƓOŊgq .ch.txt ɂ̂Ƀ`lLq
+    ƂɂƎ̃`lɃAW邱Ƃ\B
+    TvƂ BonDriver_uSUNpTV.ch.txt YtB
+
+
+XV
+
+2021/3/18 ̕ύX_
+
+  EIBonTransponderC^[tFCXɑΉ
+
+2020/10/9 ̕ύX_
+
+  EFastScanɑΉ ( .ini USUNPTV_FASTSCAN[y/n]ŋ@\ؑ։ )
+
+2020/5/22 ̕ύX_
+
+  EWindows8.1ȍ~œ삷AC\NiX](̌)ɑΉvWF
+    Ngt@C BonDriver_uSUNpTV_isoch.vcxproj Vɒǉ
+    (\[Vt@C uSUNpTV_isoch.sln \zĂB)
+
+2020/4/27 ̕ύX_
+
+  EVOi擾ɓ]~߂邩ǂ肷tO .ini ɒǉ
+    ( USUNPTV_LOCK_ON_SIGNALŕύX\ l1<bN> )
+
+2019/12/23 ̕ύX_
+
+  EVOi擾̍œK
+
+2019/12/22 ̕ύX_
+
+  ENHK BS1  X^[`l2/3 A`l BS15/TS1  BS15/TS2 
+    v BS15/TS0  BS15/TS1 ̊Ԉ`lƈv̏C
+    (PSKWX^甲tsid̉3rbg`l̃Xg[
+     ԍƎۂɈv邩ǂrĊmFR[hʓrǉđΉ)
+
+2019/12/9 ̕ύX_
+
+  ELbVAP[^hbvNƂ̂oOC[12/22]
+
+  EBS`l̃Xg[ؑւ̃^C~OĒ[12/21(ES)]
+    (PSKWX^tmcerrrbgNAmɎbҋ@Ătsidؑւ)
+
+  ELbVAP[^̃ANZXG[sC[12/21(ES)]
+
+2019/12/8 ̕ύX_
+
+  EUSB BULK Xg[̒ʐMpPbgTCYő47KBɕύX
+    ( 12/8C64KB͂R[hCYĂĐݒłĂȂB
+      R[hʁA47KB傫l͐ݒłȂۂB )
+
+  E񓯊obt@Ɋւ鐔l𒲐
+
+    pPbgTCY̕ύXɔA񓯊obt@Ɋւȉ̋Kl
+
+      ASYNCTS_QUEUENUM c obt@ Kl66  3M (47K*66) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl660 30M (47K*660) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl22 1MB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl11 0.5MB
+
+2019/12/7 ̕ύX_
+
+  E`lt@C̕`lTSID(ID[])Lqł鍀ڂǉ
+  EBS`l̃Xg[ؑւɋHɎs邱Ƃ̂錻ۂC
+  EWXgɔ񓯊obt@ɊւIvVǉ
+
+    WXg HKEY_CURRENT_USER\Software\trinity19683\FSUSB2i 
+    ȉ̂SڂDWORDlŕύX\B
+
+      ASYNCTS_QUEUENUM c obt@ Kl32  2M (64K*32) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl320 20M (64K*320) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl12 750KB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl6 375KB
+
+
+gp
+
+  ۏ؁iNO WARRANTYj
+
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_FSHybrid.ini BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_FSHybrid.ini
--- BonD_FSHybrid-20201009_org/sample/BonDriver_FSHybrid.ini	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_FSHybrid.ini	2022-05-03 19:39:08.000000000 +0900
@@ -0,0 +1,303 @@
+; BonDriver_FSHybrid.ini FSnBonDriver̋ʍ (2022/5/3)
+;
+;       eBonDriver̋ʍڂύXꍇ́Ãt@CҏW
+;     eBonDriver݂fBNg BonDriver_FSHybrid.ini Ƃ
+;     ̃t@CuƁAʍڂƂĊeBonDriverɐݒ肪ǂݏo܂B
+;       ܂Ãt@CeBonDriverDLLt@C̃vtBbNX+.ini
+;     OύXABonDriverƓfBNgɒuĂƁÅeDLL
+;     ʂ̐ݒƂēǂݍ܂邱Ƃ\łB
+;
+;     WXg .ini ɓ񂪑݂ꍇA.ini ̕D悳܂B
+;
+[BonTuner]
+
+; Lɂtrinity19683񒼓`̃LbVɕύX[y/N]
+TSCACHING_LEGACY=n
+
+; LbV𐮍邩ǂ[y/N]i肷邪ׂj
+TSCACHING_DEFRAGMENT=n
+
+; LbV𐮍ꍇ̃pPbgTCY[bytes]
+TSCACHING_DEFRAGSIZE=128*1024 ; 128KiB
+
+; oN][h̃I[o[ChpPbgTCY[bytes]
+;TSCACHING_BULKPACKETSIZE=1M ; 1MiB
+;TSCACHING_BULKPACKETSIZE=512K ; 512KiB
+;TSCACHING_BULKPACKETSIZE=256K ; 256KiB
+;TSCACHING_BULKPACKETSIZE=128K ; 128KiB
+;TSCACHING_BULKPACKETSIZE=64K ; 64KiB
+;TSCACHING_BULKPACKETSIZE=47K ; 47KiB same as EARTHSOFT PT series
+;TSCACHING_BULKPACKETSIZE=TS_PacketSize ; default packet size
+;TSCACHING_BULKPACKETSIZE=TS_LegacyPacketSize ; trinity19683 ver. packet size
+;TSCACHING_BULKPACKETSIZE=282K ; suitable for buggy UASP (AMD/ASMedia) mixed
+
+; NULLpPbgVbgAEg邩ǂ[Y/n]
+;  TSCACHING_BULKPACKETSIZE  47K 傫ꍇ́An 𐄏
+TSCACHING_DROPNULLPACKETS=y
+
+
+; TSXg[zXbh̃}`^XN[y/N]
+; (AC\NiX]LȊTSCACHING_LEGACY̒lyɕύXꍇ́A
+;  ̒lyɕύX삪肷͗lBA^C\サ܂B)
+TSTHREAD_DUPLEX=n
+
+; TSXg[zXbhWinUsbe֐R[rōsǂ[Y/n]
+; (삪sɂȂꍇA̒lnɕύXƉP邱Ƃ܂B)
+TSTHREAD_LOCK_ON_WINUSB=y
+
+; TSXg[zXbh̗D揇
+; (Default: THREAD_PRIORITY_HIGHEST)
+;TSTHREAD_PRIORITY=THREAD_PRIORITY_TIME_CRITICAL  ; A^C
+;TSTHREAD_PRIORITY=THREAD_PRIORITY_HIGHEST        ; 
+;TSTHREAD_PRIORITY=THREAD_PRIORITY_ABOVE_NORMAL   ;  
+;TSTHREAD_PRIORITY=THREAD_PRIORITY_NORMAL         ; ʏ
+;TSTHREAD_PRIORITY=THREAD_PRIORITY_BELOW_NORMAL   ;  
+;TSTHREAD_PRIORITY=THREAD_PRIORITY_LOWEST         ; Ⴂ
+;TSTHREAD_PRIORITY=THREAD_PRIORITY_IDLE           ; ACĥ
+
+; TSXg[zXbh̊eP^[őҋ@Ԑݒ[msec]
+TSTHREAD_POLL_TIMEOUT=25     ; Ҏ󂵂obt@I/OMɔ₷ő勖e
+TSTHREAD_SUBMIT_TIMEOUT=50   ; obt@I/OҎGgɔ₷ő勖e
+
+; TSXg[zXbhI/Oobt@ő哯쓮
+TSTHREAD_NUMIO=24 ; [4`256] pPbgxTSTHREAD_NUMIO ̑Ҏobt@쓮
+
+; TSXg[zXbhI/OҎGgΕۏobt@쓮
+; v́AANeBuI/OҎ쓮TSTHREAD_SUBMIT_IOLIMITȏɍŒێ
+; (Default: 4) 4 means keeping quadruple I/O packet buffer-driving at least
+TSTHREAD_SUBMIT_IOLIMIT=4 ; [4`TSTHREAD_NUMIO]
+
+
+; 񓯊LbVTSAP[VXbh̗D揇
+; (Default: THREAD_PRIORITY_HIGHEST)
+;TSALLOC_PRIORITY=THREAD_PRIORITY_TIME_CRITICAL  ; A^C
+;TSALLOC_PRIORITY=THREAD_PRIORITY_HIGHEST        ; 
+;TSALLOC_PRIORITY=THREAD_PRIORITY_ABOVE_NORMAL   ;  
+;TSALLOC_PRIORITY=THREAD_PRIORITY_NORMAL         ; ʏ
+;TSALLOC_PRIORITY=THREAD_PRIORITY_BELOW_NORMAL   ;  
+;TSALLOC_PRIORITY=THREAD_PRIORITY_LOWEST         ; Ⴂ
+;TSALLOC_PRIORITY=THREAD_PRIORITY_IDLE           ; ACĥ
+
+; 񓯊LbVTSAP[VXbhɊւeݒ
+TSALLOC_TIMEOUT=100     ; sĔzûP^[őҋ@[ms]
+TSALLOC_WAITING=n       ; sĔzuҋ@tO[y/N]
+TSALLOC_MODERATE=y      ; s(X[Y]/C[n])ɍĔzu
+
+
+; 񓯊LbṼobt@ݒ[pPbgxNN̒l]
+ASYNCTS_QUEUENUM=66     ; obt@
+ASYNCTS_QUEUEMAX=660    ; őĔzuobt@
+ASYNCTS_EMPTYBORDER=22  ; ĔzuJn̎cʃobt@is̃{[_[j
+ASYNCTS_EMPTYLIMIT=11   ; ŏcʃobt@Ίmېiobt@jۏᐔj
+
+
+; Ɏsꍇ̍Ďsݒ
+DEVICE_RETRY_TIMES=3       ; foCXĎső
+TUNER_RETRY_DURATION=3000  ; `[i[̃I[vőĎs[msec]
+
+; `[i[QƎɋ@̎QIDz悤ɂ邩ǂ
+; ̋@\𗘗pƁAނ̋@𕡐䓯gpꍇɃ`[i[
+; I[v鎞ɎIDUۂɈԏ߂ɗ񋓂̂̋@𖈉
+; ƂĎQƂ̂ł͂ȂAŌɎgp@IDWXgɋL
+; ĂAIDƂďXɏzQƂ邱ƂɂāAeX̋@̎Q
+; Ɨ𕽋ωAgppxɕ΂肪oȂ悤ɕۂƂŌʓIɓ폊L@
+; Ŝ̑IȌp팸AɕۂƂł悤ɂȂ܂B
+;   DEVICE_ID_ROTATION=y ɂƁAȉ̃WXgɏzIDۑ܂B
+;    FSUSB2N: \HKEY_CURRENT_USER\Software\tri.dw.land.to\FSUSB2N
+;    uSUNpTV/FSUSB2i: \HKEY_CURRENT_USER\Software\trinity19683\FSUSB2i
+;      l: ROTATION_DEVICE_ID(<`[i[>)
+;        ^: DWORD
+;   DEVICE_ID_ROTATION_VOLATILE=y ɂƁAQID̕֋L܂B
+;    n[hfBXNł͂ȂɋLׁAfBXNւ݂̏点
+;    AVXeċNƋLĂQID͏Ă܂܂B
+DEVICE_ID_ROTATION=n           ; WXg𗘗pIDzQƂ邩ǂ
+DEVICE_ID_ROTATION_VOLATILE=n  ; zQIDWXgɋL邩ǂ
+
+; x^C}[gĊݐx߂邩ǂ(Win10 2004ȍ~y)[y/N]
+HIGH_PRECISE_INTERRUPT=n
+
+; USBfoCX̃AChȓd͋@\𖳌ɂ邩ǂ[y/N]
+USBPOWERPOLICY_AVOID_SUSPEND=n
+
+; USBfoCX̃pCv|V[
+USBPIPEPOLICY_RAW_IO=y
+USBPIPEPOLICY_AUTO_CLEAR_STALL=y
+USBPIPEPOLICY_ALLOW_PARTIAL_READS=y
+USBPIPEPOLICY_AUTO_FLUSH=n
+USBPIPEPOLICY_IGNORE_SHORT_PACKETS=n
+USBPIPEPOLICY_SHORT_PACKET_TERMINATE=n
+USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT=5000
+USBPIPEPOLICY_RESET_PIPE_ON_RESUME=n
+
+
+; BonDriver_FSUSB2N ŗL̐ݒ
+FSUSB2N_INTERIM_WAIT=20 ; [msec]
+FSUSB2N_SETFREQ_TIMES=2
+FSUSB2N_RESETDEMOD_TIMES=1
+FSUSB2N_CHANNEL_WAIT=800 ; [msec]
+FSUSB2N_LOCK_ON_SIGNAL=y
+FSUSB2N_FASTSCAN=n
+
+; BonDriver_FSUSB2i ŗL̐ݒ
+FSUSB2I_SETFREQ_TIMES=2
+FSUSB2I_TUNING_WAIT=1500 ; [msec]
+FSUSB2I_CHANNEL_WAIT=800 ; [msec]
+FSUSB2I_LOCK_ON_SIGNAL=y
+FSUSB2I_FASTSCAN=n
+
+; BonDriver_uSUNpTV ŗL̐ݒ
+USUNPTV_SETSFREQ_TIMES=1
+USUNPTV_SETSTSID_TIMES=2
+USUNPTV_SETTFREQ_TIMES=1
+USUNPTV_SETSLOCK_WAIT=10 ; [msec]
+USUNPTV_SETSTSID_WAIT=800 ; [msec]
+USUNPTV_CHANNEL_WAIT=800 ; [msec]
+USUNPTV_LOCK_ON_SIGNAL=y
+USUNPTV_FASTSCAN=n
+
+  ; FastScan: `lXL
+  ; ( FSUSB2N_FASTSCAN=y / FSUSB2I_FASTSCAN=y / USUNPTV_FASTSCAN=y )
+  ;  FastScanɑΉEDCB̃Tv ( TVTest́AftHőΉĂ͗lc )
+  ;   URL: https://github.com/hyrolean/EDCB-Velmy_mod/releases/tag/sample1
+
+
+;  ȉ̃IvVύXʁAAvP[VŗL̃`l
+; ꍇAɔAvP[Ṽ`l̍폜
+; XLʓrKvɂȂ邱ƂׁAAvP[V̋cȂ
+; ꂮ\ɒӂȂ珑ĂB
+
+; ̃`lVHF܂߂邩ǂ[y/N]
+DEFSPACE_VHF=n
+; ̃`lUHF܂߂邩ǂ[Y/n]
+DEFSPACE_UHF=y
+; ̃`lCATV܂߂邩ǂ[y/N]
+DEFSPACE_CATV=n
+; ̃`lɃWXg̃`l܂߂邩ǂ[Y/n]
+DEFSPACE_AUX=y
+; ̎Og`[i[`lBS܂߂邩ǂ[Y/n]
+DEFSPACE_BS=y
+; ̎Og`[i[BS`l̊eXg[[0-8]
+DEFSPACE_BS_STREAMS=4
+; ̎Og`[i[BS`lXg[ɔzu邩ǂ[y/N]1
+DEFSPACE_BS_STREAM_STRIDE=n
+; ̎Og`[i[`lCS110܂߂邩ǂ[Y/n]
+DEFSPACE_CS110=y
+; ̎Og`[i[CS110`l̊eXg[[0-8]
+DEFSPACE_CS110_STREAMS=0
+; ̎Og`[i[CS110`lXg[ɔzu邩ǂ[y/N]1
+DEFSPACE_CS110_STREAM_STRIDE=n
+; ̃`ĺA`lt@C .ch.txt `Ă
+; ̃`lt@C̕D悳Ã`l͔j܂B
+
+; 1: DEFSPACE_BS_STREAM_STRIDE / DEFSPACE_CS110_STREAM_STRIDE ɂ
+;
+; `l̕тXg[̔zuɕבւ DEF_SPACE_BS_STREAMS /
+; DEFSPACE_CS110_STREAMS ̒l𑝌ĂAvŃXL`l
+; AԂ̏ԂAvăXLȂĂ̂܂܈ێ邱Ƃ\łB
+;
+; <arXg[̔zuύX>
+;
+;  DEFSPACE_BS_STREAM_STRIDE=n ̃`lzu igX|_̔zuj
+;     DEFSPACE_BS_STREAMS=4 ̂Ƃ
+;       [n] BS1/TS0  BS1/TS1  BS1/TS2  BS1/TS3  BS3/TS0 c
+;     DEFSPACE_BS_STREAMS=3 ̂Ƃ           
+;       [n] BS1/TS0  BS1/TS1  BS1/TS2  BS3/TS0  BS3/TS1 c
+;    (DEFSPACE_BS_STREAMS̒lςƃXL`l̘AԂ)
+;
+;  DEFSPACE_BS_STREAM_STRIDE=y ̃`lzu iXg[̔zuj
+;     DEFSPACE_BS_STREAMS=4 ̂Ƃ
+;       [n] BS1/TS0  BS3/TS0  BS5/TS0  BS7/TS0 c BS23/TS0 
+;          BS1/TS1  BS3/TS1  BS5/TS1  BS7/TS1 c BS23/TS1 
+;          BS1/TS2  BS3/TS2  BS5/TS2  BS7/TS2 c BS23/TS2 
+;          BS1/TS3  BS3/TS3  BS5/TS3  BS7/TS3 c BS23/TS3 [I]
+;     DEFSPACE_BS_STREAMS=3 ̂Ƃ
+;       [n] BS1/TS0  BS3/TS0  BS5/TS0  BS7/TS0 c BS23/TS0 
+;          BS1/TS1  BS3/TS1  BS5/TS1  BS7/TS1 c BS23/TS1 
+;          BS1/TS2  BS3/TS2  BS5/TS2  BS7/TS2 c BS23/TS2 [I]
+;       [  BS1/TS3  BS3/TS3 c ] ̕т邾
+;    (DEFSPACE_BS_STREAMS̒lςĂXL`l̘AԂ͋Ȃ)
+
+; IBonDriverSetChannelɃ`lt@C̒`gp邩ǂ[y/N]
+; (`lt@C݂ꍇɗL)
+BYTETUNING_USER=n
+
+; gpȂ`[i[Ԃ̗ InvisibleSpaces ɋLq
+; ̃`[i[Ԃƃ`ĺA܂B
+;InvisibleSpaces=VHF,CATV
+
+; `[i[Ԃ̗ SpaceArrangement ɋLqƂ̋Lqꂽ
+; ԒʂɃ`[i[Ԃבւĕ\邱Ƃ\łB
+;iLq̂Ȃ`[i[Ԃ͎IɍŌɒǋLBj
+;SpaceArrangement=UHF,AUX,BS,CS110
+
+
+[Channels]
+; ɃWXg̃`lƓ`̋LqsƂɂ背WXg
+; `lo^ȂĂAUX`[i[Ԃ̃`lƂēo^
+; Ƃł܂B
+; ȉ"CATV̎gϊpXX[̐ݒ背WXg"̓eƓłB
+; ̃`l𖳌ɂɂ́A[Channels]ZNV폜
+;   A[BonTuner]ZNVDEFSPACE_AUX̒lnɂĂB
+;--------------------------------------------------
+;2020/10/21łvZ悤ɂȂ܂B
+;{`l} = {CfbNX} <<24 | {gkHz}
+C13   = 0  <<24 | 111143
+C14   = 1  <<24 | 117143
+C15   = 2  <<24 | 123143
+C16   = 3  <<24 | 129143
+C17   = 4  <<24 | 135143
+C18   = 5  <<24 | 141143
+C19   = 6  <<24 | 147143
+C20   = 7  <<24 | 153143
+C21   = 8  <<24 | 159143
+C22   = 9  <<24 | 167143
+VHF4  = 10 <<24 | 173143
+VHF5  = 11 <<24 | 179143
+VHF6  = 12 <<24 | 185143
+VHF7  = 13 <<24 | 191143
+VHF8  = 14 <<24 | 197143
+VHF9  = 15 <<24 | 201143
+VHF10 = 16 <<24 | 207143
+VHF11 = 17 <<24 | 213143
+VHF12 = 18 <<24 | 219143
+C23   = 19 <<24 | 225143
+C24   = 20 <<24 | 231143
+C25   = 21 <<24 | 237143
+C26   = 22 <<24 | 243143
+C27   = 23 <<24 | 249143
+C28   = 24 <<24 | 255143
+C29   = 25 <<24 | 261143
+C30   = 26 <<24 | 267143
+C31   = 27 <<24 | 273143
+C32   = 28 <<24 | 279143
+C33   = 29 <<24 | 285143
+C34   = 30 <<24 | 291143
+C35   = 31 <<24 | 297143
+C36   = 32 <<24 | 303143
+C37   = 33 <<24 | 309143
+C38   = 34 <<24 | 315143
+C39   = 35 <<24 | 321143
+C40   = 36 <<24 | 327143
+C41   = 37 <<24 | 333143
+C42   = 38 <<24 | 339143
+C43   = 39 <<24 | 345143
+C44   = 40 <<24 | 351143
+C45   = 41 <<24 | 357143
+C46   = 42 <<24 | 363143
+C47   = 43 <<24 | 369143
+C48   = 44 <<24 | 375143
+C49   = 45 <<24 | 381143
+C50   = 46 <<24 | 387143
+C51   = 47 <<24 | 393143
+C52   = 48 <<24 | 399143
+C53   = 49 <<24 | 405143
+C54   = 50 <<24 | 411143
+C55   = 51 <<24 | 417143
+C56   = 52 <<24 | 423143
+C57   = 53 <<24 | 429143
+C58   = 54 <<24 | 435143
+C59   = 55 <<24 | 441143
+C60   = 56 <<24 | 447143
+C61   = 57 <<24 | 453143
+C62   = 58 <<24 | 459143
+C63   = 59 <<24 | 465143
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2N.ch - MHz.txt BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_FSUSB2N.ch - MHz.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2N.ch - MHz.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_FSUSB2N.ch - MHz.txt	2015-01-02 07:01:08.000000000 +0900
@@ -0,0 +1,135 @@
+; BonDriver_FSUSB2N p `lt@CgMHz\LC (2015/1/2)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; Xy[X, `lԍorgMHz, `l
+
+  ; VHF
+
+VHF, 93.143MHz, 1ch
+VHF, 99.143MHz, 2ch
+VHF,105.143MHz, 3ch
+VHF,173.143MHz, 4ch
+VHF,179.143MHz, 5ch
+VHF,185.143MHz, 6ch
+VHF,191.143MHz, 7ch
+VHF,195.143MHz, 8ch
+VHF,201.143MHz, 9ch
+VHF,207.143MHz,10ch
+VHF,213.143MHz,11ch
+VHF,219.143MHz,12ch
+
+  ; UHF
+
+UHF,473.143MHz,13ch
+UHF,479.143MHz,14ch
+UHF,485.143MHz,15ch
+UHF,491.143MHz,16ch
+UHF,497.143MHz,17ch
+UHF,503.143MHz,18ch
+UHF,509.143MHz,19ch
+UHF,515.143MHz,20ch
+UHF,521.143MHz,21ch
+UHF,527.143MHz,22ch
+UHF,533.143MHz,23ch
+UHF,539.143MHz,24ch
+UHF,545.143MHz,25ch
+UHF,551.143MHz,26ch
+UHF,557.143MHz,27ch
+UHF,563.143MHz,28ch
+UHF,569.143MHz,29ch
+UHF,575.143MHz,30ch
+UHF,581.143MHz,31ch
+UHF,587.143MHz,32ch
+UHF,593.143MHz,33ch
+UHF,599.143MHz,34ch
+UHF,605.143MHz,35ch
+UHF,611.143MHz,36ch
+UHF,617.143MHz,37ch
+UHF,623.143MHz,38ch
+UHF,629.143MHz,39ch
+UHF,635.143MHz,40ch
+UHF,641.143MHz,41ch
+UHF,647.143MHz,42ch
+UHF,653.143MHz,43ch
+UHF,659.143MHz,44ch
+UHF,665.143MHz,45ch
+UHF,671.143MHz,46ch
+UHF,677.143MHz,47ch
+UHF,683.143MHz,48ch
+UHF,689.143MHz,49ch
+UHF,695.143MHz,50ch
+UHF,701.143MHz,51ch
+UHF,707.143MHz,52ch
+UHF,713.143MHz,53ch
+UHF,719.143MHz,54ch
+UHF,725.143MHz,55ch
+UHF,731.143MHz,56ch
+UHF,737.143MHz,57ch
+UHF,743.143MHz,58ch
+UHF,749.143MHz,59ch
+UHF,755.143MHz,60ch
+UHF,761.143MHz,61ch
+UHF,767.143MHz,62ch
+
+  ; CATV
+
+CATV,111.143MHz,C13ch
+CATV,117.143MHz,C14ch
+CATV,123.143MHz,C15ch
+CATV,129.143MHz,C16ch
+CATV,135.143MHz,C17ch
+CATV,141.143MHz,C18ch
+CATV,147.143MHz,C19ch
+CATV,153.143MHz,C20ch
+CATV,159.143MHz,C21ch
+CATV,167.143MHz,C22ch
+CATV,225.143MHz,C23ch
+CATV,231.143MHz,C24ch
+CATV,237.143MHz,C25ch
+CATV,243.143MHz,C26ch
+CATV,249.143MHz,C27ch
+CATV,255.143MHz,C28ch
+CATV,261.143MHz,C29ch
+CATV,267.143MHz,C30ch
+CATV,273.143MHz,C31ch
+CATV,279.143MHz,C32ch
+CATV,285.143MHz,C33ch
+CATV,291.143MHz,C34ch
+CATV,297.143MHz,C35ch
+CATV,303.143MHz,C36ch
+CATV,309.143MHz,C37ch
+CATV,315.143MHz,C38ch
+CATV,321.143MHz,C39ch
+CATV,327.143MHz,C40ch
+CATV,333.143MHz,C41ch
+CATV,339.143MHz,C42ch
+CATV,345.143MHz,C43ch
+CATV,351.143MHz,C44ch
+CATV,357.143MHz,C45ch
+CATV,363.143MHz,C46ch
+CATV,369.143MHz,C47ch
+CATV,375.143MHz,C48ch
+CATV,381.143MHz,C49ch
+CATV,387.143MHz,C50ch
+CATV,393.143MHz,C51ch
+CATV,399.143MHz,C52ch
+CATV,405.143MHz,C53ch
+CATV,411.143MHz,C54ch
+CATV,417.143MHz,C55ch
+CATV,423.143MHz,C56ch
+CATV,429.143MHz,C57ch
+CATV,435.143MHz,C58ch
+CATV,441.143MHz,C59ch
+CATV,447.143MHz,C60ch
+CATV,453.143MHz,C61ch
+CATV,459.143MHz,C62ch
+CATV,465.143MHz,C63ch
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2N.ch.txt BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_FSUSB2N.ch.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2N.ch.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_FSUSB2N.ch.txt	2015-01-02 07:01:02.000000000 +0900
@@ -0,0 +1,135 @@
+; BonDriver_FSUSB2N p `lt@C (2015/1/2)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; Xy[X, `lԍorgMHz, `l
+
+  ; VHF
+
+VHF, 1, 1ch
+VHF, 2, 2ch
+VHF, 3, 3ch
+VHF, 4, 4ch
+VHF, 5, 5ch
+VHF, 6, 6ch
+VHF, 7, 7ch
+VHF, 8, 8ch
+VHF, 9, 9ch
+VHF,10,10ch
+VHF,11,11ch
+VHF,12,12ch
+
+  ; UHF
+
+UHF,13,13ch
+UHF,14,14ch
+UHF,15,15ch
+UHF,16,16ch
+UHF,17,17ch
+UHF,18,18ch
+UHF,19,19ch
+UHF,20,20ch
+UHF,21,21ch
+UHF,22,22ch
+UHF,23,23ch
+UHF,24,24ch
+UHF,25,25ch
+UHF,26,26ch
+UHF,27,27ch
+UHF,28,28ch
+UHF,29,29ch
+UHF,30,30ch
+UHF,31,31ch
+UHF,32,32ch
+UHF,33,33ch
+UHF,34,34ch
+UHF,35,35ch
+UHF,36,36ch
+UHF,37,37ch
+UHF,38,38ch
+UHF,39,39ch
+UHF,40,40ch
+UHF,41,41ch
+UHF,42,42ch
+UHF,43,43ch
+UHF,44,44ch
+UHF,45,45ch
+UHF,46,46ch
+UHF,47,47ch
+UHF,48,48ch
+UHF,49,49ch
+UHF,50,50ch
+UHF,51,51ch
+UHF,52,52ch
+UHF,53,53ch
+UHF,54,54ch
+UHF,55,55ch
+UHF,56,56ch
+UHF,57,57ch
+UHF,58,58ch
+UHF,59,59ch
+UHF,60,60ch
+UHF,61,61ch
+UHF,62,62ch
+
+  ; CATV
+
+CATV,113,C13ch
+CATV,114,C14ch
+CATV,115,C15ch
+CATV,116,C16ch
+CATV,117,C17ch
+CATV,118,C18ch
+CATV,119,C19ch
+CATV,120,C20ch
+CATV,121,C21ch
+CATV,122,C22ch
+CATV,123,C23ch
+CATV,124,C24ch
+CATV,125,C25ch
+CATV,126,C26ch
+CATV,127,C27ch
+CATV,128,C28ch
+CATV,129,C29ch
+CATV,130,C30ch
+CATV,131,C31ch
+CATV,132,C32ch
+CATV,133,C33ch
+CATV,134,C34ch
+CATV,135,C35ch
+CATV,136,C36ch
+CATV,137,C37ch
+CATV,138,C38ch
+CATV,139,C39ch
+CATV,140,C40ch
+CATV,141,C41ch
+CATV,142,C42ch
+CATV,143,C43ch
+CATV,144,C44ch
+CATV,145,C45ch
+CATV,146,C46ch
+CATV,147,C47ch
+CATV,148,C48ch
+CATV,149,C49ch
+CATV,150,C50ch
+CATV,151,C51ch
+CATV,152,C52ch
+CATV,153,C53ch
+CATV,154,C54ch
+CATV,155,C55ch
+CATV,156,C56ch
+CATV,157,C57ch
+CATV,158,C58ch
+CATV,159,C59ch
+CATV,160,C60ch
+CATV,161,C61ch
+CATV,162,C62ch
+CATV,163,C63ch
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2i.ch - MHz.txt BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_FSUSB2i.ch - MHz.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2i.ch - MHz.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_FSUSB2i.ch - MHz.txt	2018-02-07 00:16:20.000000000 +0900
@@ -0,0 +1,135 @@
+; BonDriver_FSUSB2i p `lt@CgMHz\LC (2018/2/7)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; Xy[X, `lԍorgMHz, `l
+
+  ; VHF
+
+;VHF, 93.143MHz, 1ch
+;VHF, 99.143MHz, 2ch
+;VHF,105.143MHz, 3ch
+;VHF,173.143MHz, 4ch
+;VHF,179.143MHz, 5ch
+;VHF,185.143MHz, 6ch
+;VHF,191.143MHz, 7ch
+;VHF,195.143MHz, 8ch
+;VHF,201.143MHz, 9ch
+;VHF,207.143MHz,10ch
+;VHF,213.143MHz,11ch
+;VHF,219.143MHz,12ch
+
+  ; UHF
+
+UHF,473.143MHz,13ch
+UHF,479.143MHz,14ch
+UHF,485.143MHz,15ch
+UHF,491.143MHz,16ch
+UHF,497.143MHz,17ch
+UHF,503.143MHz,18ch
+UHF,509.143MHz,19ch
+UHF,515.143MHz,20ch
+UHF,521.143MHz,21ch
+UHF,527.143MHz,22ch
+UHF,533.143MHz,23ch
+UHF,539.143MHz,24ch
+UHF,545.143MHz,25ch
+UHF,551.143MHz,26ch
+UHF,557.143MHz,27ch
+UHF,563.143MHz,28ch
+UHF,569.143MHz,29ch
+UHF,575.143MHz,30ch
+UHF,581.143MHz,31ch
+UHF,587.143MHz,32ch
+UHF,593.143MHz,33ch
+UHF,599.143MHz,34ch
+UHF,605.143MHz,35ch
+UHF,611.143MHz,36ch
+UHF,617.143MHz,37ch
+UHF,623.143MHz,38ch
+UHF,629.143MHz,39ch
+UHF,635.143MHz,40ch
+UHF,641.143MHz,41ch
+UHF,647.143MHz,42ch
+UHF,653.143MHz,43ch
+UHF,659.143MHz,44ch
+UHF,665.143MHz,45ch
+UHF,671.143MHz,46ch
+UHF,677.143MHz,47ch
+UHF,683.143MHz,48ch
+UHF,689.143MHz,49ch
+UHF,695.143MHz,50ch
+UHF,701.143MHz,51ch
+UHF,707.143MHz,52ch
+UHF,713.143MHz,53ch
+UHF,719.143MHz,54ch
+UHF,725.143MHz,55ch
+UHF,731.143MHz,56ch
+UHF,737.143MHz,57ch
+UHF,743.143MHz,58ch
+UHF,749.143MHz,59ch
+UHF,755.143MHz,60ch
+UHF,761.143MHz,61ch
+UHF,767.143MHz,62ch
+
+  ; CATV
+
+CATV,111.143MHz,C13ch
+CATV,117.143MHz,C14ch
+CATV,123.143MHz,C15ch
+CATV,129.143MHz,C16ch
+CATV,135.143MHz,C17ch
+CATV,141.143MHz,C18ch
+CATV,147.143MHz,C19ch
+CATV,153.143MHz,C20ch
+CATV,159.143MHz,C21ch
+CATV,167.143MHz,C22ch
+CATV,225.143MHz,C23ch
+CATV,231.143MHz,C24ch
+CATV,237.143MHz,C25ch
+CATV,243.143MHz,C26ch
+CATV,249.143MHz,C27ch
+CATV,255.143MHz,C28ch
+CATV,261.143MHz,C29ch
+CATV,267.143MHz,C30ch
+CATV,273.143MHz,C31ch
+CATV,279.143MHz,C32ch
+CATV,285.143MHz,C33ch
+CATV,291.143MHz,C34ch
+CATV,297.143MHz,C35ch
+CATV,303.143MHz,C36ch
+CATV,309.143MHz,C37ch
+CATV,315.143MHz,C38ch
+CATV,321.143MHz,C39ch
+CATV,327.143MHz,C40ch
+CATV,333.143MHz,C41ch
+CATV,339.143MHz,C42ch
+CATV,345.143MHz,C43ch
+CATV,351.143MHz,C44ch
+CATV,357.143MHz,C45ch
+CATV,363.143MHz,C46ch
+CATV,369.143MHz,C47ch
+CATV,375.143MHz,C48ch
+CATV,381.143MHz,C49ch
+CATV,387.143MHz,C50ch
+CATV,393.143MHz,C51ch
+CATV,399.143MHz,C52ch
+CATV,405.143MHz,C53ch
+CATV,411.143MHz,C54ch
+CATV,417.143MHz,C55ch
+CATV,423.143MHz,C56ch
+CATV,429.143MHz,C57ch
+CATV,435.143MHz,C58ch
+CATV,441.143MHz,C59ch
+CATV,447.143MHz,C60ch
+CATV,453.143MHz,C61ch
+CATV,459.143MHz,C62ch
+;CATV,465.143MHz,C63ch
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2i.ch.txt BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_FSUSB2i.ch.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2i.ch.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_FSUSB2i.ch.txt	2018-02-07 00:16:20.000000000 +0900
@@ -0,0 +1,135 @@
+; BonDriver_FSUSB2i p `lt@C (2018/2/7)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; Xy[X, `lԍorgMHz, `l
+
+  ; VHF
+
+;VHF, 1, 1ch
+;VHF, 2, 2ch
+;VHF, 3, 3ch
+;VHF, 4, 4ch
+;VHF, 5, 5ch
+;VHF, 6, 6ch
+;VHF, 7, 7ch
+;VHF, 8, 8ch
+;VHF, 9, 9ch
+;VHF,10,10ch
+;VHF,11,11ch
+;VHF,12,12ch
+
+  ; UHF
+
+UHF,13,13ch
+UHF,14,14ch
+UHF,15,15ch
+UHF,16,16ch
+UHF,17,17ch
+UHF,18,18ch
+UHF,19,19ch
+UHF,20,20ch
+UHF,21,21ch
+UHF,22,22ch
+UHF,23,23ch
+UHF,24,24ch
+UHF,25,25ch
+UHF,26,26ch
+UHF,27,27ch
+UHF,28,28ch
+UHF,29,29ch
+UHF,30,30ch
+UHF,31,31ch
+UHF,32,32ch
+UHF,33,33ch
+UHF,34,34ch
+UHF,35,35ch
+UHF,36,36ch
+UHF,37,37ch
+UHF,38,38ch
+UHF,39,39ch
+UHF,40,40ch
+UHF,41,41ch
+UHF,42,42ch
+UHF,43,43ch
+UHF,44,44ch
+UHF,45,45ch
+UHF,46,46ch
+UHF,47,47ch
+UHF,48,48ch
+UHF,49,49ch
+UHF,50,50ch
+UHF,51,51ch
+UHF,52,52ch
+UHF,53,53ch
+UHF,54,54ch
+UHF,55,55ch
+UHF,56,56ch
+UHF,57,57ch
+UHF,58,58ch
+UHF,59,59ch
+UHF,60,60ch
+UHF,61,61ch
+UHF,62,62ch
+
+  ; CATV
+
+CATV,113,C13ch
+CATV,114,C14ch
+CATV,115,C15ch
+CATV,116,C16ch
+CATV,117,C17ch
+CATV,118,C18ch
+CATV,119,C19ch
+CATV,120,C20ch
+CATV,121,C21ch
+CATV,122,C22ch
+CATV,123,C23ch
+CATV,124,C24ch
+CATV,125,C25ch
+CATV,126,C26ch
+CATV,127,C27ch
+CATV,128,C28ch
+CATV,129,C29ch
+CATV,130,C30ch
+CATV,131,C31ch
+CATV,132,C32ch
+CATV,133,C33ch
+CATV,134,C34ch
+CATV,135,C35ch
+CATV,136,C36ch
+CATV,137,C37ch
+CATV,138,C38ch
+CATV,139,C39ch
+CATV,140,C40ch
+CATV,141,C41ch
+CATV,142,C42ch
+CATV,143,C43ch
+CATV,144,C44ch
+CATV,145,C45ch
+CATV,146,C46ch
+CATV,147,C47ch
+CATV,148,C48ch
+CATV,149,C49ch
+CATV,150,C50ch
+CATV,151,C51ch
+CATV,152,C52ch
+CATV,153,C53ch
+CATV,154,C54ch
+CATV,155,C55ch
+CATV,156,C56ch
+CATV,157,C57ch
+CATV,158,C58ch
+CATV,159,C59ch
+CATV,160,C60ch
+CATV,161,C61ch
+CATV,162,C62ch
+;CATV,163,C63ch
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch - BSAlmighty.txt BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_uSUNpTV.ch - BSAlmighty.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch - BSAlmighty.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_uSUNpTV.ch - BSAlmighty.txt	2021-03-18 21:47:26.000000000 +0900
@@ -0,0 +1,211 @@
+; BonDriver_uSUNpTV p `lt@CarI[}CeB (2019/12/21)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; `lԍ̕\L@F
+;
+;   1`63               : nfW(VHF/UHFш)̕`l
+;   C13`C63            : CATVpXX[(UHFш)̕`l
+;   BS[1`23]/TS[0`7]  : BS̕`l(`lԍ/Xg[ԍ)
+;   BS[1`23]/ID[]  : BS̕`l(`lԍ/Xg[hc)
+;   ND[2`24]			: CS̕`l(`lԍ)
+;
+;     TS[0`7]AID[] ͏ȗB
+;
+; Xy[X, `lԍorgMHz[, `l(Ă)]
+
+  ; VHF
+
+;VHF, 1
+;VHF, 2
+;VHF, 3
+;VHF, 4
+;VHF, 5
+;VHF, 6
+;VHF, 7
+;VHF, 8
+;VHF, 9
+;VHF,10
+;VHF,11
+;VHF,12
+
+  ; UHF
+
+UHF,13
+UHF,14
+UHF,15
+UHF,16
+UHF,17
+UHF,18
+UHF,19
+UHF,20
+UHF,21
+UHF,22
+UHF,23
+UHF,24
+UHF,25
+UHF,26
+UHF,27
+UHF,28
+UHF,29
+UHF,30
+UHF,31
+UHF,32
+UHF,33
+UHF,34
+UHF,35
+UHF,36
+UHF,37
+UHF,38
+UHF,39
+UHF,40
+UHF,41
+UHF,42
+UHF,43
+UHF,44
+UHF,45
+UHF,46
+UHF,47
+UHF,48
+UHF,49
+UHF,50
+UHF,51
+UHF,52
+UHF,53
+UHF,54
+UHF,55
+UHF,56
+UHF,57
+UHF,58
+UHF,59
+UHF,60
+UHF,61
+UHF,62
+
+  ; CATV
+
+CATV,C13
+CATV,C14
+CATV,C15
+CATV,C16
+CATV,C17
+CATV,C18
+CATV,C19
+CATV,C20
+CATV,C21
+CATV,C22
+CATV,C23
+CATV,C24
+CATV,C25
+CATV,C26
+CATV,C27
+CATV,C28
+CATV,C29
+CATV,C30
+CATV,C31
+CATV,C32
+CATV,C33
+CATV,C34
+CATV,C35
+CATV,C36
+CATV,C37
+CATV,C38
+CATV,C39
+CATV,C40
+CATV,C41
+CATV,C42
+CATV,C43
+CATV,C44
+CATV,C45
+CATV,C46
+CATV,C47
+CATV,C48
+CATV,C49
+CATV,C50
+CATV,C51
+CATV,C52
+CATV,C53
+CATV,C54
+CATV,C55
+CATV,C56
+CATV,C57
+CATV,C58
+CATV,C59
+CATV,C60
+CATV,C61
+CATV,C62
+;CATV,C63
+
+  ; BS ( TS0`TS3 ׂ̂Ẳ\ɑΉ )
+
+BS, BS01/TS0
+BS, BS01/TS1
+BS, BS01/TS2
+BS, BS01/TS3
+BS, BS03/TS0
+BS, BS03/TS1
+BS, BS03/TS2
+BS, BS03/TS3
+BS, BS05/TS0
+BS, BS05/TS1
+BS, BS05/TS2
+BS, BS05/TS3
+BS, BS07/TS0
+BS, BS07/TS1
+BS, BS07/TS2
+BS, BS07/TS3
+BS, BS09/TS0
+BS, BS09/TS1
+BS, BS09/TS2
+BS, BS09/TS3
+BS, BS11/TS0
+BS, BS11/TS1
+BS, BS11/TS2
+BS, BS11/TS3
+BS, BS13/TS0
+BS, BS13/TS1
+BS, BS13/TS2
+BS, BS13/TS3
+BS, BS15/TS0
+BS, BS15/TS1
+BS, BS15/TS2
+BS, BS15/TS3
+BS, BS17/TS0
+BS, BS17/TS1
+BS, BS17/TS2
+BS, BS17/TS3
+BS, BS19/TS0
+BS, BS19/TS1
+BS, BS19/TS2
+BS, BS19/TS3
+BS, BS21/TS0
+BS, BS21/TS1
+BS, BS21/TS2
+BS, BS21/TS3
+BS, BS23/TS0
+BS, BS23/TS1
+BS, BS23/TS2
+BS, BS23/TS3
+
+  ; CS110
+
+CS110, ND2
+CS110, ND4
+CS110, ND6
+CS110, ND8
+CS110, ND10
+CS110, ND12
+CS110, ND14
+CS110, ND16
+CS110, ND18
+CS110, ND20
+CS110, ND22
+CS110, ND24
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch - MHz.txt BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_uSUNpTV.ch - MHz.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch - MHz.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_uSUNpTV.ch - MHz.txt	2022-05-03 18:22:51.000000000 +0900
@@ -0,0 +1,192 @@
+; BonDriver_uSUNpTV p `lt@CgMHz\L (2022/5/3)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; `lԍ̕\L@F
+;
+;   1`63               : nfW(VHF/UHFш)̕`l
+;   C13`C63            : CATVpXX[(UHFш)̕`l
+;   BS[1`23]/TS[0`7]  : BS̕`l(`lԍ/Xg[ԍ)
+;   BS[1`23]/ID[]  : BS̕`l(`lԍ/Xg[hc)
+;   ND[2`24]			: CS̕`l(`lԍ)
+;
+;     TS[0`7]AID[] ͏ȗB
+;
+; Xy[X, `lԍorgMHz[, `l(Ă)]
+
+  ; VHF
+
+;VHF, 93.143MHz, 1ch
+;VHF, 99.143MHz, 2ch
+;VHF,105.143MHz, 3ch
+;VHF,173.143MHz, 4ch
+;VHF,179.143MHz, 5ch
+;VHF,185.143MHz, 6ch
+;VHF,191.143MHz, 7ch
+;VHF,195.143MHz, 8ch
+;VHF,201.143MHz, 9ch
+;VHF,207.143MHz,10ch
+;VHF,213.143MHz,11ch
+;VHF,219.143MHz,12ch
+
+  ; UHF
+
+UHF,473.143MHz,13ch
+UHF,479.143MHz,14ch
+UHF,485.143MHz,15ch
+UHF,491.143MHz,16ch
+UHF,497.143MHz,17ch
+UHF,503.143MHz,18ch
+UHF,509.143MHz,19ch
+UHF,515.143MHz,20ch
+UHF,521.143MHz,21ch
+UHF,527.143MHz,22ch
+UHF,533.143MHz,23ch
+UHF,539.143MHz,24ch
+UHF,545.143MHz,25ch
+UHF,551.143MHz,26ch
+UHF,557.143MHz,27ch
+UHF,563.143MHz,28ch
+UHF,569.143MHz,29ch
+UHF,575.143MHz,30ch
+UHF,581.143MHz,31ch
+UHF,587.143MHz,32ch
+UHF,593.143MHz,33ch
+UHF,599.143MHz,34ch
+UHF,605.143MHz,35ch
+UHF,611.143MHz,36ch
+UHF,617.143MHz,37ch
+UHF,623.143MHz,38ch
+UHF,629.143MHz,39ch
+UHF,635.143MHz,40ch
+UHF,641.143MHz,41ch
+UHF,647.143MHz,42ch
+UHF,653.143MHz,43ch
+UHF,659.143MHz,44ch
+UHF,665.143MHz,45ch
+UHF,671.143MHz,46ch
+UHF,677.143MHz,47ch
+UHF,683.143MHz,48ch
+UHF,689.143MHz,49ch
+UHF,695.143MHz,50ch
+UHF,701.143MHz,51ch
+UHF,707.143MHz,52ch
+UHF,713.143MHz,53ch
+UHF,719.143MHz,54ch
+UHF,725.143MHz,55ch
+UHF,731.143MHz,56ch
+UHF,737.143MHz,57ch
+UHF,743.143MHz,58ch
+UHF,749.143MHz,59ch
+UHF,755.143MHz,60ch
+UHF,761.143MHz,61ch
+UHF,767.143MHz,62ch
+
+  ; CATV
+
+CATV,111.143MHz,C13ch
+CATV,117.143MHz,C14ch
+CATV,123.143MHz,C15ch
+CATV,129.143MHz,C16ch
+CATV,135.143MHz,C17ch
+CATV,141.143MHz,C18ch
+CATV,147.143MHz,C19ch
+CATV,153.143MHz,C20ch
+CATV,159.143MHz,C21ch
+CATV,167.143MHz,C22ch ; C22
+CATV,225.143MHz,C23ch
+CATV,231.143MHz,C24ch
+CATV,237.143MHz,C25ch
+CATV,243.143MHz,C26ch
+CATV,249.143MHz,C27ch
+CATV,255.143MHz,C28ch
+CATV,261.143MHz,C29ch
+CATV,267.143MHz,C30ch
+CATV,273.143MHz,C31ch
+CATV,279.143MHz,C32ch
+CATV,285.143MHz,C33ch
+CATV,291.143MHz,C34ch
+CATV,297.143MHz,C35ch
+CATV,303.143MHz,C36ch
+CATV,309.143MHz,C37ch
+CATV,315.143MHz,C38ch
+CATV,321.143MHz,C39ch
+CATV,327.143MHz,C40ch
+CATV,333.143MHz,C41ch
+CATV,339.143MHz,C42ch
+CATV,345.143MHz,C43ch
+CATV,351.143MHz,C44ch
+CATV,357.143MHz,C45ch
+CATV,363.143MHz,C46ch
+CATV,369.143MHz,C47ch
+CATV,375.143MHz,C48ch
+CATV,381.143MHz,C49ch
+CATV,387.143MHz,C50ch
+CATV,393.143MHz,C51ch
+CATV,399.143MHz,C52ch
+CATV,405.143MHz,C53ch
+CATV,411.143MHz,C54ch
+CATV,417.143MHz,C55ch
+CATV,423.143MHz,C56ch
+CATV,429.143MHz,C57ch
+CATV,435.143MHz,C58ch
+CATV,441.143MHz,C59ch
+CATV,447.143MHz,C60ch
+CATV,453.143MHz,C61ch
+CATV,459.143MHz,C62ch
+;CATV,465.143MHz,C63ch
+
+  ; BS
+
+BS, 1049.48MHz/TS0,BS01/TS0 ;arP
+BS, 1049.48MHz/TS1,BS01/TS1 ;ar|sar
+BS, 1049.48MHz/TS2,BS01/TS2 ;are
+BS, 1087.84MHz/TS0,BS03/TS0 ;vnvnvvC
+BS, 1087.84MHz/TS1,BS03/TS1 ;mgjarv~A
+BS, 1126.20MHz/TS0,BS05/TS0 ;vnvnvCu
+BS, 1126.20MHz/TS1,BS05/TS1 ;vnvnvVl}
+BS, 1202.92MHz/TS0,BS09/TS0 ;arPPCu
+BS, 1202.92MHz/TS1,BS09/TS1 ;X^[`lP
+BS, 1202.92MHz/TS2,BS09/TS2 ;arPQgDGr
+BS, 1241.28MHz/TS1,BS11/TS1 ;arXJp[I
+BS, 1241.28MHz/TS2,BS11/TS2 ;w
+BS, 1241.28MHz/TS3,BS11/TS3 ;arނrW
+BS, 1279.64MHz/TS0,BS13/TS0 ;are
+BS, 1279.64MHz/TS1,BS13/TS1 ;artWEPWP
+BS, 1279.64MHz/TS2,BS13/TS2 ;arAj}bNX
+BS, 1318.00MHz/TS1,BS15/TS1 ;mgjarP
+BS, 1318.00MHz/TS2,BS15/TS2 ;X^[`lQ
+BS, 1394.72MHz/TS0,BS19/TS0 ;i@ronqsr@S
+BS, 1394.72MHz/TS1,BS19/TS1 ;i@ronqsr@P
+BS, 1394.72MHz/TS2,BS19/TS2 ;i@ronqsr@Q
+BS, 1394.72MHz/TS3,BS19/TS3 ;i@ronqsr@R
+BS, 1433.08MHz/TS0,BS21/TS0 ;vnvnvvX
+BS, 1433.08MHz/TS1,BS21/TS1 ;{f傃
+BS, 1433.08MHz/TS2,BS21/TS2 ;O[`l
+BS, 1471.44MHz/TS0,BS23/TS0 ;fBYj[
+BS, 1471.44MHz/TS1,BS23/TS1 ;ar悵
+BS, 1471.44MHz/TS2,BS23/TS2 ;ari
+BS, 1471.44MHz/TS3,BS23/TS3 ;ar|}
+
+  ; CS110
+
+CS110, 1613.00MHz,ND02
+CS110, 1653.00MHz,ND04
+CS110, 1693.00MHz,ND06
+CS110, 1733.00MHz,ND08
+CS110, 1773.00MHz,ND10
+CS110, 1813.00MHz,ND12
+CS110, 1853.00MHz,ND14
+CS110, 1893.00MHz,ND16
+CS110, 1933.00MHz,ND18
+CS110, 1973.00MHz,ND20
+CS110, 2013.00MHz,ND22
+CS110, 2053.00MHz,ND24
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch - TSID.txt BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_uSUNpTV.ch - TSID.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch - TSID.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_uSUNpTV.ch - TSID.txt	2022-05-03 18:22:52.000000000 +0900
@@ -0,0 +1,192 @@
+; BonDriver_uSUNpTV p `lt@CTSID\Zi\L (2022/5/3)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; `lԍ̕\L@F
+;
+;   1`63               : nfW(VHF/UHFш)̕`l
+;   C13`C63            : CATVpXX[(UHFш)̕`l
+;   BS[1`23]/TS[0`7]  : BS̕`l(`lԍ/Xg[ԍ)
+;   BS[1`23]/ID[]  : BS̕`l(`lԍ/Xg[hc)
+;   ND[2`24]			: CS̕`l(`lԍ)
+;
+;     TS[0`7]AID[] ͏ȗB
+;
+; Xy[X, `lԍorgMHz[, `l(Ă)]
+
+  ; VHF
+
+;VHF, 1
+;VHF, 2
+;VHF, 3
+;VHF, 4
+;VHF, 5
+;VHF, 6
+;VHF, 7
+;VHF, 8
+;VHF, 9
+;VHF,10
+;VHF,11
+;VHF,12
+
+  ; UHF
+
+UHF,13
+UHF,14
+UHF,15
+UHF,16
+UHF,17
+UHF,18
+UHF,19
+UHF,20
+UHF,21
+UHF,22
+UHF,23
+UHF,24
+UHF,25
+UHF,26
+UHF,27
+UHF,28
+UHF,29
+UHF,30
+UHF,31
+UHF,32
+UHF,33
+UHF,34
+UHF,35
+UHF,36
+UHF,37
+UHF,38
+UHF,39
+UHF,40
+UHF,41
+UHF,42
+UHF,43
+UHF,44
+UHF,45
+UHF,46
+UHF,47
+UHF,48
+UHF,49
+UHF,50
+UHF,51
+UHF,52
+UHF,53
+UHF,54
+UHF,55
+UHF,56
+UHF,57
+UHF,58
+UHF,59
+UHF,60
+UHF,61
+UHF,62
+
+  ; CATV
+
+CATV,C13
+CATV,C14
+CATV,C15
+CATV,C16
+CATV,C17
+CATV,C18
+CATV,C19
+CATV,C20
+CATV,C21
+CATV,C22
+CATV,C23
+CATV,C24
+CATV,C25
+CATV,C26
+CATV,C27
+CATV,C28
+CATV,C29
+CATV,C30
+CATV,C31
+CATV,C32
+CATV,C33
+CATV,C34
+CATV,C35
+CATV,C36
+CATV,C37
+CATV,C38
+CATV,C39
+CATV,C40
+CATV,C41
+CATV,C42
+CATV,C43
+CATV,C44
+CATV,C45
+CATV,C46
+CATV,C47
+CATV,C48
+CATV,C49
+CATV,C50
+CATV,C51
+CATV,C52
+CATV,C53
+CATV,C54
+CATV,C55
+CATV,C56
+CATV,C57
+CATV,C58
+CATV,C59
+CATV,C60
+CATV,C61
+CATV,C62
+;CATV,C63
+
+  ; BS
+
+BS, BS1/ID0x4010,BS01/TS0 ;arP
+BS, BS1/ID0x4011,BS01/TS1 ;ar|sar
+BS, BS1/ID0x4012,BS01/TS2 ;are
+BS, BS3/ID0x4030,BS03/TS0 ;vnvnvvC
+BS, BS3/ID0x4031,BS03/TS1 ;mgjarv~A
+BS, BS5/ID0x4450,BS05/TS0 ;vnvnvCu
+BS, BS5/ID0x4451,BS05/TS1 ;vnvnvVl}
+BS, BS9/ID0x4090,BS09/TS0 ;arPPCu
+BS, BS9/ID0x4091,BS09/TS1 ;X^[`lP
+BS, BS9/ID0x4092,BS09/TS2 ;arPQgDGr
+BS, BS11/ID0x46B1,BS11/TS1 ;arXJp[I
+BS, BS11/ID0x46B2,BS11/TS2 ;w
+BS, BS11/ID0x46B3,BS11/TS3 ;arނrW
+BS, BS13/ID0x40D0,BS13/TS0 ;are
+BS, BS13/ID0x40D1,BS13/TS1 ;artWEPWP
+BS, BS13/ID0x46D2,BS13/TS2 ;arAj}bNX
+BS, BS15/ID0x40F1,BS15/TS1 ;mgjarP
+BS, BS15/ID0x40F2,BS15/TS2 ;X^[`lQ
+BS, BS19/ID0x4730,BS19/TS0 ;i@ronqsr@S
+BS, BS19/ID0x4731,BS19/TS1 ;i@ronqsr@P
+BS, BS19/ID0x4732,BS19/TS2 ;i@ronqsr@Q
+BS, BS19/ID0x4733,BS19/TS3 ;i@ronqsr@R
+BS, BS21/ID0x4750,BS21/TS0 ;vnvnvvX
+BS, BS21/ID0x4751,BS21/TS1 ;{f傃
+BS, BS21/ID0x4752,BS21/TS2 ;O[`l
+BS, BS23/ID0x4770,BS23/TS0 ;fBYj[
+BS, BS23/ID0x4971,BS23/TS1 ;ar悵
+BS, BS23/ID0x4972,BS23/TS2 ;ari
+BS, BS23/ID0x4973,BS23/TS3 ;ar|}
+
+  ; CS110
+
+CS110, ND2/ID0x6020,ND02
+CS110, ND4/ID0x7040,ND04
+CS110, ND6/ID0x7060,ND06
+CS110, ND8/ID0x6080,ND08
+CS110, ND10/ID0x60A0,ND10
+CS110, ND12/ID0x70C0,ND12
+CS110, ND14/ID0x70E0,ND14
+CS110, ND16/ID0x7100,ND16
+CS110, ND18/ID0x7120,ND18
+CS110, ND20/ID0x7140,ND20
+CS110, ND22/ID0x7160,ND22
+CS110, ND24/ID0x7180,ND24
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch.txt BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_uSUNpTV.ch.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/sample/BonDriver_uSUNpTV.ch.txt	2022-05-03 18:22:52.000000000 +0900
@@ -0,0 +1,192 @@
+; BonDriver_uSUNpTV p `lt@CȈՕ\L (2022/5/3)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; `lԍ̕\L@F
+;
+;   1`63               : nfW(VHF/UHFш)̕`l
+;   C13`C63            : CATVpXX[(UHFш)̕`l
+;   BS[1`23]/TS[0`7]  : BS̕`l(`lԍ/Xg[ԍ)
+;   BS[1`23]/ID[]  : BS̕`l(`lԍ/Xg[hc)
+;   ND[2`24]			: CS̕`l(`lԍ)
+;
+;     TS[0`7]AID[] ͏ȗB
+;
+; Xy[X, `lԍorgMHz[, `l(Ă)]
+
+  ; VHF
+
+;VHF, 1
+;VHF, 2
+;VHF, 3
+;VHF, 4
+;VHF, 5
+;VHF, 6
+;VHF, 7
+;VHF, 8
+;VHF, 9
+;VHF,10
+;VHF,11
+;VHF,12
+
+  ; UHF
+
+UHF,13
+UHF,14
+UHF,15
+UHF,16
+UHF,17
+UHF,18
+UHF,19
+UHF,20
+UHF,21
+UHF,22
+UHF,23
+UHF,24
+UHF,25
+UHF,26
+UHF,27
+UHF,28
+UHF,29
+UHF,30
+UHF,31
+UHF,32
+UHF,33
+UHF,34
+UHF,35
+UHF,36
+UHF,37
+UHF,38
+UHF,39
+UHF,40
+UHF,41
+UHF,42
+UHF,43
+UHF,44
+UHF,45
+UHF,46
+UHF,47
+UHF,48
+UHF,49
+UHF,50
+UHF,51
+UHF,52
+UHF,53
+UHF,54
+UHF,55
+UHF,56
+UHF,57
+UHF,58
+UHF,59
+UHF,60
+UHF,61
+UHF,62
+
+  ; CATV
+
+CATV,C13
+CATV,C14
+CATV,C15
+CATV,C16
+CATV,C17
+CATV,C18
+CATV,C19
+CATV,C20
+CATV,C21
+CATV,C22
+CATV,C23
+CATV,C24
+CATV,C25
+CATV,C26
+CATV,C27
+CATV,C28
+CATV,C29
+CATV,C30
+CATV,C31
+CATV,C32
+CATV,C33
+CATV,C34
+CATV,C35
+CATV,C36
+CATV,C37
+CATV,C38
+CATV,C39
+CATV,C40
+CATV,C41
+CATV,C42
+CATV,C43
+CATV,C44
+CATV,C45
+CATV,C46
+CATV,C47
+CATV,C48
+CATV,C49
+CATV,C50
+CATV,C51
+CATV,C52
+CATV,C53
+CATV,C54
+CATV,C55
+CATV,C56
+CATV,C57
+CATV,C58
+CATV,C59
+CATV,C60
+CATV,C61
+CATV,C62
+;CATV,C63
+
+  ; BS
+
+BS, BS1/TS0 ;arP
+BS, BS1/TS1 ;ar|sar
+BS, BS1/TS2 ;are
+BS, BS3/TS0 ;vnvnvvC
+BS, BS3/TS1 ;mgjarv~A
+BS, BS5/TS0 ;vnvnvCu
+BS, BS5/TS1 ;vnvnvVl}
+BS, BS9/TS0 ;arPPCu
+BS, BS9/TS1 ;X^[`lP
+BS, BS9/TS2 ;arPQgDGr
+BS, BS11/TS1 ;arXJp[I
+BS, BS11/TS2 ;w
+BS, BS11/TS3 ;arނrW
+BS, BS13/TS0 ;are
+BS, BS13/TS1 ;artWEPWP
+BS, BS13/TS2 ;arAj}bNX
+BS, BS15/TS1 ;mgjarP
+BS, BS15/TS2 ;X^[`lQ
+BS, BS19/TS0 ;i@ronqsr@S
+BS, BS19/TS1 ;i@ronqsr@P
+BS, BS19/TS2 ;i@ronqsr@Q
+BS, BS19/TS3 ;i@ronqsr@R
+BS, BS21/TS0 ;vnvnvvX
+BS, BS21/TS1 ;{f傃
+BS, BS21/TS2 ;O[`l
+BS, BS23/TS0 ;fBYj[
+BS, BS23/TS1 ;ar悵
+BS, BS23/TS2 ;ari
+BS, BS23/TS3 ;ar|}
+
+  ; CS110
+
+CS110, ND2
+CS110, ND4
+CS110, ND6
+CS110, ND8
+CS110, ND10
+CS110, ND12
+CS110, ND14
+CS110, ND16
+CS110, ND18
+CS110, ND20
+CS110, ND22
+CS110, ND24
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver.rc BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/BonDriver.rc
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver.rc	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/BonDriver.rc	2022-08-11 13:28:36.000000000 +0900
@@ -0,0 +1,42 @@
+#include <windows.h>
+
+LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT
+1 VERSIONINFO
+ FILEVERSION 0,2022,8,11
+ PRODUCTVERSION 0,2022,8,11
+ FILEFLAGSMASK 0x17L
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS VOS_NT
+ FILETYPE VFT_DLL
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "041104b0"
+        BEGIN
+            VALUE "CompanyName", "hyrolean-dtv inspired by trinity19683"
+            VALUE "FileVersion", "0,2022,8,11"
+#ifdef INCLUDE_ISOCH_XFER
+            VALUE "FileDescription", "Hybrid BonDriver for FSUSB2N/FSUSB2i/uSUNpTV (isoch support)"
+            VALUE "InternalName", "BonDriver_FSHybrid_isoch.dll"
+            VALUE "OriginalFilename", "BonDriver_FSHybrid_isoch.dll"
+            VALUE "ProductName", "BonDriver_FSHybrid_isoch"
+#else
+            VALUE "FileDescription", "Hybrid BonDriver for FSUSB2N/FSUSB2i/uSUNpTV"
+            VALUE "InternalName", "BonDriver_FSHybrid.dll"
+            VALUE "OriginalFilename", "BonDriver_FSHybrid.dll"
+            VALUE "ProductName", "BonDriver_FSHybrid"
+#endif
+            VALUE "LegalCopyright", "hyrolean-dtv 2019-2022 inspired by trinity19683 2015-2016"
+            VALUE "ProductVersion", "0,2022,8,11"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x411, 1200
+    END
+END
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcproj	2022-05-02 21:56:26.000000000 +0900
@@ -0,0 +1,1309 @@
+<?xml version="1.0" encoding="shift_jis"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="BonDriver_FSHybrid"
+	ProjectGUID="{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}"
+	RootNamespace="BonDriver_FSHybrid"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="196613"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSHybrid.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSHybrid_x64.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSHybrid.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSHybrid_x64.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="\[X t@C"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\bonhybrid.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\dllmain.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\em2874.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\em287x.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\em287x_usb.c"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\it9175_usb.c"
+				>
+			</File>
+			<File
+				RelativePath="..\ktv.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\message.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\mxl136.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\osdepend.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\pryutil.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\HRTimer.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx2.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tc90522.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tda20142.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tsthread.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbops.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="wb_[ t@C"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\bonhybrid.h"
+				>
+			</File>
+			<File
+				RelativePath="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.h"
+				>
+			</File>
+			<File
+				RelativePath="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.h"
+				>
+			</File>
+			<File
+				RelativePath="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em2874.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x_priv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x_usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonTransponder.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_fw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_priv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\ktv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\message.h"
+				>
+			</File>
+			<File
+				RelativePath="..\mxl136.h"
+				>
+			</File>
+			<File
+				RelativePath="..\osdepend.h"
+				>
+			</File>
+			<File
+				RelativePath="..\pryutil.h"
+				>
+			</File>
+			<File
+				RelativePath="..\HRTimer.h"
+				>
+			</File>
+			<File
+				RelativePath=".\resource.h"
+				>
+			</File>
+			<File
+				RelativePath=".\stdafx.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\stdint_.h"
+				>
+			</File>
+			<File
+				RelativePath="..\targetver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tc90522.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tda20142.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsbuff.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsthread.h"
+				>
+			</File>
+			<File
+				RelativePath="..\twindbg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\types_u.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb100.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb200.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbops.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusbio.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="\[X t@C"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\BonDriver.rc"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcxproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcxproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcxproj	2022-05-02 21:56:27.000000000 +0900
@@ -0,0 +1,267 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>FSHybrid</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
+    <UseDebugLibraries>true</UseDebugLibraries>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'" Label="Configuration">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <EmbedManifest>false</EmbedManifest>
+    <IncludePath>..\inc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='Win32'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.h" />
+    <ClInclude Include="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.h" />
+    <ClInclude Include="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.h" />
+    <ClInclude Include="..\bonhybrid.h" />
+    <ClInclude Include="..\em2874.h" />
+    <ClInclude Include="..\em287x.h" />
+    <ClInclude Include="..\em287x_priv.h" />
+    <ClInclude Include="..\em287x_usb.h" />
+    <ClInclude Include="..\it9175.h" />
+    <ClInclude Include="..\it9175_fw.h" />
+    <ClInclude Include="..\it9175_priv.h" />
+    <ClInclude Include="..\it9175_usb.h" />
+    <ClInclude Include="..\ktv.h" />
+    <ClInclude Include="..\message.h" />
+    <ClInclude Include="..\mxl136.h" />
+    <ClInclude Include="..\targetver.h" />
+    <ClInclude Include="..\osdepend.h" />
+    <ClInclude Include="..\tc90522.h" />
+    <ClInclude Include="..\tda20142.h" />
+    <ClInclude Include="..\tsbuff.h" />
+    <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
+    <ClInclude Include="..\types_u.h" />
+    <ClInclude Include="..\usbdevfile.h" />
+    <ClInclude Include="..\usbops.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="..\HRTimer.h" />
+    <ClInclude Include="stdafx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\em2874.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\em287x.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\em287x_usb.c" />
+    <ClCompile Include="..\it9175.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\it9175_usb.c" />
+    <ClCompile Include="..\ktv.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\message.c" />
+    <ClCompile Include="..\mxl136.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c" />
+    <ClCompile Include="..\tc90522.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tda20142.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tsthread.c" />
+    <ClCompile Include="..\usbdevfile.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\usbops.c" />
+    <ClCompile Include="dllmain.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\HRTimer.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="stdafx.c">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="stdafx2.cpp">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid_isoch.vcxproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/BonDriver_FSHybrid_isoch.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid_isoch.vcxproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/BonDriver_FSHybrid_isoch.vcxproj	2022-05-02 21:56:27.000000000 +0900
@@ -0,0 +1,279 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{58814608-686F-46B4-9061-B647F45A1151}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>FSHybrid</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
+    <UseDebugLibraries>true</UseDebugLibraries>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'" Label="Configuration">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <EmbedManifest>false</EmbedManifest>
+    <IncludePath>..\inc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='Win32'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.h" />
+    <ClInclude Include="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.h" />
+    <ClInclude Include="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.h" />
+    <ClInclude Include="..\bonhybrid.h" />
+    <ClInclude Include="..\em2874.h" />
+    <ClInclude Include="..\em287x.h" />
+    <ClInclude Include="..\em287x_priv.h" />
+    <ClInclude Include="..\em287x_usb.h" />
+    <ClInclude Include="..\it9175.h" />
+    <ClInclude Include="..\it9175_fw.h" />
+    <ClInclude Include="..\it9175_priv.h" />
+    <ClInclude Include="..\it9175_usb.h" />
+    <ClInclude Include="..\ktv.h" />
+    <ClInclude Include="..\message.h" />
+    <ClInclude Include="..\mxl136.h" />
+    <ClInclude Include="..\targetver.h" />
+    <ClInclude Include="..\osdepend.h" />
+    <ClInclude Include="..\tc90522.h" />
+    <ClInclude Include="..\tda20142.h" />
+    <ClInclude Include="..\tsbuff.h" />
+    <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
+    <ClInclude Include="..\types_u.h" />
+    <ClInclude Include="..\usbdevfile.h" />
+    <ClInclude Include="..\usbops.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="..\HRTimer.h" />
+    <ClInclude Include="stdafx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\em2874.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\em287x.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\em287x_usb.c" />
+    <ClCompile Include="..\it9175.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\it9175_usb.c" />
+    <ClCompile Include="..\ktv.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\message.c" />
+    <ClCompile Include="..\mxl136.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c" />
+    <ClCompile Include="..\tc90522.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tda20142.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tsthread.c" />
+    <ClCompile Include="..\usbdevfile.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\usbops.c" />
+    <ClCompile Include="dllmain.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\HRTimer.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="stdafx.c">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="stdafx2.cpp">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/dllmain.cpp BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/dllmain.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/dllmain.cpp	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/dllmain.cpp	2020-01-07 03:24:36.000000000 +0900
@@ -0,0 +1,68 @@
+//# 2020-1-3
+//#   BonDriver_FSUSB2N.dll / BonDriver_FSUSB2i.dll / BonDriver_uSUNpTV.dll
+//#   Hybrid dll entry point.
+//# Coded by 2019-2020 LVhJPic0JSk5LiQ1ITskKVk9UGBg
+#include "stdafx.h"
+#include <cstring>
+#include <string>
+#include "IBonDriver2.h"
+#include "../BonDriver_FSUSB2N/BonTuner_FSUSB2N.h"
+#include "../BonDriver_FSUSB2i/BonTuner_FSUSB2i.h"
+#include "../BonDriver_uSUNpTV/BonTuner_uSUNpTV.h"
+#include "../pryutil.h"
+
+using namespace std ;
+
+enum BONDRIVER_FSHYBRID {
+	BONDRIVER_UNKNOWN,
+	BONDRIVER_FSUSB2N,
+	BONDRIVER_FSUSB2I,
+	BONDRIVER_USUNPTV,
+};
+
+BONDRIVER_FSHYBRID FSHybrid = BONDRIVER_UNKNOWN;
+
+void FSIdentify(HMODULE hModule)
+{
+	char path[_MAX_PATH] ;
+	GetModuleFileNameA( hModule, path, _MAX_PATH ) ;
+	std::string prefix = upper_case(file_prefix_of(path)) ;
+	#define IDENTIFY(name) do { \
+		if(prefix.substr(0,strlen(#name))==string(#name)) \
+		{FSHybrid=name;return;} } while(0)
+	IDENTIFY(BONDRIVER_FSUSB2N) ;
+	IDENTIFY(BONDRIVER_FSUSB2I) ;
+	IDENTIFY(BONDRIVER_USUNPTV) ;
+	#undef IDENTIFY
+	FSHybrid = BONDRIVER_UNKNOWN;
+}
+
+BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )
+{
+	switch (ul_reason_for_call) {
+	case DLL_PROCESS_ATTACH:
+		FSIdentify(hModule) ;
+		CBonFSHybrid::m_hModule = hModule;
+		break;
+	case DLL_PROCESS_DETACH:
+		if(CBonFSHybrid::m_pThis)CBonFSHybrid::m_pThis->Release();
+		break;
+	}
+	return TRUE;
+}
+
+#pragma warning( disable : 4273 )
+extern "C" __declspec(dllexport) IBonDriver *CreateBonDriver()
+{
+	switch(FSHybrid) {
+		case BONDRIVER_FSUSB2N:
+			return BonFSCreate<FSUSB2N::CBonTuner>();
+		case BONDRIVER_FSUSB2I:
+			return BonFSCreate<FSUSB2i::CBonTuner>();
+		case BONDRIVER_USUNPTV:
+			return BonFSCreate<uSUNpTV::CBonTuner>();
+	}
+	return NULL ;
+}
+#pragma warning( default : 4273 )
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx.c BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/stdafx.c
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx.c	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/stdafx.c	2015-12-09 05:03:22.000000000 +0900
@@ -0,0 +1 @@
+#include "stdafx.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx.h BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/stdafx.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/stdafx.h	2022-05-02 22:15:45.000000000 +0900
@@ -0,0 +1,12 @@
+#pragma once
+#include "../targetver.h"
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <tchar.h>
+#include <process.h>
+
+#include "../message.h"
+
+#include "../twindbg.h"
+
+#include "../HRTimer.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx2.cpp BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/stdafx2.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx2.cpp	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSHybrid/stdafx2.cpp	2015-12-10 03:50:18.000000000 +0900
@@ -0,0 +1 @@
+#include "stdafx.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver.rc BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonDriver.rc
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver.rc	2012-09-29 04:42:03.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonDriver.rc	2022-08-11 13:28:36.000000000 +0900
@@ -4,8 +4,8 @@
 
 LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT
 1 VERSIONINFO
- FILEVERSION 1,0,1,3
- PRODUCTVERSION 1,0,1,3
+ FILEVERSION 0,2022,8,11
+ PRODUCTVERSION 0,2022,8,11
  FILEFLAGSMASK 0x17L
 #ifdef _DEBUG
  FILEFLAGS 0x1L
@@ -20,14 +20,21 @@
     BEGIN
         BLOCK "041104b0"
         BEGIN
-            VALUE "CompanyName", "WPjeGg6tSA"
+            VALUE "CompanyName", "hyrolean-dtv inspired by WPjeGg6tSA"
+            VALUE "FileVersion", "0,2022,8,11"
+#ifdef INCLUDE_ISOCH_XFER
+            VALUE "FileDescription", "BonDriver for FSUSB2N (isoch support)"
+            VALUE "InternalName", "BonDriver_FSUSB2N_isoch.dll"
+            VALUE "OriginalFilename", "BonDriver_FSUSB2N_isoch.dll"
+            VALUE "ProductName", "BonDriver_FSUSB2N_isoch"
+#else
             VALUE "FileDescription", "BonDriver for FSUSB2N"
-            VALUE "FileVersion", "1,0,1,3"
             VALUE "InternalName", "BonDriver_FSUSB2N.dll"
-            VALUE "LegalCopyright", "WPjeGg6tSA 2009-2012"
             VALUE "OriginalFilename", "BonDriver_FSUSB2N.dll"
             VALUE "ProductName", "BonDriver_FSUSB2N"
-            VALUE "ProductVersion", "1,0,1,3"
+#endif
+            VALUE "LegalCopyright", "hyrolean-dtv 2014-2022 inspired by WPjeGg6tSA 2009-2012"
+            VALUE "ProductVersion", "0,2022,8,11"
         END
     END
     BLOCK "VarFileInfo"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcproj	2012-09-28 02:45:21.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcproj	2022-05-02 21:56:27.000000000 +0900
@@ -2,9 +2,9 @@
 <VisualStudioProject
 	ProjectType="Visual C++"
 	Version="9.00"
-	Name="BonDriver"
+	Name="BonDriver_FSUSB2N"
 	ProjectGUID="{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}"
-	RootNamespace="BonDriver"
+	RootNamespace="BonDriver_FSUSB2N"
 	Keyword="Win32Proj"
 	TargetFrameworkVersion="196613"
 	>
@@ -12,14 +12,17 @@
 		<Platform
 			Name="Win32"
 		/>
+		<Platform
+			Name="x64"
+		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
 	<Configurations>
 		<Configuration
 			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
 			ConfigurationType="2"
 			CharacterSet="1"
 			>
@@ -41,7 +44,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="../inc"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -92,9 +95,85 @@
 			/>
 		</Configuration>
 		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2N_x64.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
 			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
 			ConfigurationType="2"
 			CharacterSet="1"
 			WholeProgramOptimization="1"
@@ -118,7 +197,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="2"
 				EnableIntrinsicFunctions="true"
-				AdditionalIncludeDirectories="../inc"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="false"
@@ -170,6 +249,86 @@
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2N_x64.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
 	</Configurations>
 	<References>
 	</References>
@@ -180,7 +339,11 @@
 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
 			>
 			<File
-				RelativePath=".\BonTuner.cpp"
+				RelativePath="..\bonhybrid.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\BonTuner_FSUSB2N.cpp"
 				>
 			</File>
 			<File
@@ -196,6 +359,15 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
 					Name="Release|Win32"
 					>
 					<Tool
@@ -204,6 +376,15 @@
 						CompileAsManaged="0"
 					/>
 				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
 			</File>
 			<File
 				RelativePath="..\em2874.cpp"
@@ -222,6 +403,94 @@
 				>
 			</File>
 			<File
+				RelativePath="..\message.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\osdepend.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\pryutil.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\pryutil.h"
+				>
+			</File>
+			<File
+				RelativePath="..\HRTimer.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\HRTimer.h"
+				>
+			</File>
+			<File
 				RelativePath=".\stdafx.cpp"
 				>
 				<FileConfiguration
@@ -233,6 +502,14 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
 					Name="Release|Win32"
 					>
 					<Tool
@@ -240,11 +517,99 @@
 						UsePrecompiledHeader="1"
 					/>
 				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx2.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tsthread.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
 			</File>
 			<File
 				RelativePath="..\twindbg.h"
 				>
 			</File>
+			<File
+				RelativePath="..\usbdevfile.cpp"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="wb_[ t@C"
@@ -252,7 +617,11 @@
 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
 			>
 			<File
-				RelativePath=".\BonTuner.h"
+				RelativePath="..\bonhybrid.h"
+				>
+			</File>
+			<File
+				RelativePath=".\BonTuner_FSUSB2N.h"
 				>
 			</File>
 			<File
@@ -264,9 +633,33 @@
 				>
 			</File>
 			<File
+				RelativePath="..\message.h"
+				>
+			</File>
+			<File
+				RelativePath="..\osdepend.h"
+				>
+			</File>
+			<File
 				RelativePath=".\stdafx.h"
 				>
 			</File>
+			<File
+				RelativePath="..\tsbuff.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsthread.h"
+				>
+			</File>
+			<File
+				RelativePath="..\types_u.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.h"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="\[X t@C"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcxproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcxproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcxproj	2022-05-02 21:56:27.000000000 +0900
@@ -0,0 +1,271 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}</ProjectGuid>
+    <RootNamespace>BonDriver_FSUSB2N</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>14.0.25431.1</_ProjectFileVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <TargetName>$(ProjectName)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\bonhybrid.cpp" />
+    <ClCompile Include="..\em2874.cpp" />
+    <ClCompile Include="..\ktv.cpp" />
+    <ClCompile Include="..\message.c">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\tsthread.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\usbdevfile.cpp" />
+    <ClCompile Include="BonTuner_FSUSB2N.cpp" />
+    <ClCompile Include="dllmain.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp" />
+    <ClCompile Include="..\HRTimer.cpp" />
+    <ClCompile Include="stdafx.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="stdafx2.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\bonhybrid.h" />
+    <ClInclude Include="..\em2874.h" />
+    <ClInclude Include="..\inc\IBonDriver.h" />
+    <ClInclude Include="..\inc\IBonDriver2.h" />
+    <ClInclude Include="..\ktv.h" />
+    <ClInclude Include="..\osdepend.h" />
+    <ClInclude Include="..\tsbuff.h" />
+    <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
+    <ClInclude Include="..\types_u.h" />
+    <ClInclude Include="..\usbdevfile.h" />
+    <ClInclude Include="BonTuner_FSUSB2N.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="..\HRTimer.h" />
+    <ClInclude Include="stdafx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N_isoch.vcxproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N_isoch.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N_isoch.vcxproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N_isoch.vcxproj	2022-05-02 21:56:27.000000000 +0900
@@ -0,0 +1,283 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}</ProjectGuid>
+    <RootNamespace>BonDriver_FSUSB2N</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>14.0.25431.1</_ProjectFileVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <TargetName>$(ProjectName)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\bonhybrid.cpp" />
+    <ClCompile Include="..\em2874.cpp" />
+    <ClCompile Include="..\ktv.cpp" />
+    <ClCompile Include="..\message.c">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\tsthread.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\usbdevfile.cpp" />
+    <ClCompile Include="BonTuner_FSUSB2N.cpp" />
+    <ClCompile Include="dllmain.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp" />
+    <ClCompile Include="..\HRTimer.cpp" />
+    <ClCompile Include="stdafx.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="stdafx2.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\bonhybrid.h" />
+    <ClInclude Include="..\em2874.h" />
+    <ClInclude Include="..\inc\IBonDriver.h" />
+    <ClInclude Include="..\inc\IBonDriver2.h" />
+    <ClInclude Include="..\ktv.h" />
+    <ClInclude Include="..\osdepend.h" />
+    <ClInclude Include="..\tsbuff.h" />
+    <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
+    <ClInclude Include="..\types_u.h" />
+    <ClInclude Include="..\usbdevfile.h" />
+    <ClInclude Include="BonTuner_FSUSB2N.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="..\HRTimer.h" />
+    <ClInclude Include="stdafx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.cpp BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.cpp	2012-09-29 04:43:19.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.cpp	2022-05-02 23:18:22.000000000 +0900
@@ -1,105 +1,100 @@
 
 #include "stdafx.h"
-#include "BonTuner.h"
-#include "../twindbg.h"
+#include "BonTuner_FSUSB2N.h"
 
-#pragma warning( disable : 4273 )
-extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
-{
-	return (CBonTuner::m_pThis)? CBonTuner::m_pThis : ((IBonDriver *) new CBonTuner);
-}
-#pragma warning( default : 4273 )
+using namespace std ;
+
+namespace FSUSB2N {
 
-// ÓIo
-CBonTuner * CBonTuner::m_pThis = NULL;
-HINSTANCE CBonTuner::m_hModule = NULL;
+DWORD FSUSB2N_INTERIM_WAIT     = 20    ;
+DWORD FSUSB2N_SETFREQ_TIMES    = 2     ;
+DWORD FSUSB2N_RESETDEMOD_TIMES = 1     ;
+DWORD FSUSB2N_CHANNEL_WAIT     = 800   ;
+BOOL  FSUSB2N_LOCK_ON_SIGNAL   = TRUE  ;
+BOOL  FSUSB2N_FASTSCAN         = FALSE ;
 
 const TCHAR *g_RegKey = TEXT("Software\\tri.dw.land.to\\FSUSB2N");
 
 CBonTuner::CBonTuner()
-: m_dwCurSpace(0) , m_dwCurChannel(0) , usbDev(NULL) , pDev(NULL) , m_TsBuffSize(NULL) , m_ChannelList(NULL)
-#ifndef NO_TSTHREAD
-, m_hThread(NULL)
-#endif
+: CBonFSHybrid(), m_dwCurSpace(0), m_dwCurChannel(0), usbDev(NULL), pDev(NULL),
+  m_hDev(NULL), m_hUsbDev(NULL)
 {
-	m_pThis = this;
-	this->LoadData();
+	ZeroMemory(&m_USBEP, sizeof m_USBEP);
 }
 
 CBonTuner::~CBonTuner()
 {
 	// JĂꍇ͕
 	CloseTuner();
+}
 
-	if(m_ChannelList != NULL) ::GlobalFree(m_ChannelList);
-	m_pThis = NULL;
+const TCHAR *CBonTuner::RegName()
+{
+	return g_RegKey ;
 }
 
-inline void WaitSleep (const DWORD dwStart, const DWORD dwTime)
+int CBonTuner::UserDecidedDeviceIdx()
 {
-	DWORD dwLeft = dwStart + dwTime - ::GetTickCount();
-	if(dwLeft < 60000U)
-		::Sleep(dwLeft);
+	int idx=0 ;
+	if(sscanf_s( upper_case(file_prefix_of(ModuleFileName())).c_str() , "BONDRIVER_FSUSB2N_DEV%d", &idx )==1)
+	  return idx ;
+
+	return -1 ;
 }
 
-const BOOL CBonTuner::OpenTuner()
+const BOOL CBonTuner::TryOpenTuner()
 {
 	CloseTuner();
 
 	if(IsTunerOpening())return FALSE;
 
 	try{
-		// AllocTuner
-		for(int idx = 0;;)
-		{
-			EM2874Device* pDevTmp = EM2874Device::AllocDevice(idx);
-			if(pDevTmp == NULL) {
-				// DeviceȂꍇ
-				throw (const DWORD)__LINE__;
-			}
-			// Devicemۂ
-			usbDev = pDevTmp;
-			break;
+
+		//# AllocTuner
+		if(!FindDevice(GUID_WINUSB_FSUSB2N_DRV,m_hDev,m_hUsbDev)) {
+		  if(m_hDev==NULL) throw (const DWORD)__LINE__;
+		  if(m_hUsbDev==NULL) throw (const DWORD)__LINE__;
+		}
+		usbDev = EM2874Device::AllocDevice(m_hDev,m_hUsbDev);
+		if(usbDev == NULL) {
+			// DeviceȂꍇ
+			throw (const DWORD)__LINE__;
 		}
+
 		// Device
 		usbDev->initDevice2();
 
-		DWORD dwTime = ::GetTickCount();
-		::Sleep(80);
+		DWORD dwStart = PastSleep();
+		HRSleep(80);
 		if(usbDev->getDeviceID() == 2) {
 			pDev = new Ktv2Device(usbDev);
 		}else{
 			pDev = new Ktv1Device(usbDev);
 		}
 
-		WaitSleep(dwTime, 160);
+		PastSleep(160,dwStart);
 		pDev->InitTuner();
 
-		WaitSleep(dwTime, 180);
+		PastSleep(180,dwStart);
 		pDev->InitDeMod();
 		pDev->ResetDeMod();
 
-		WaitSleep(dwTime, 500);
-		//
-		m_TsBuffSize = (int*)VirtualAlloc( NULL, RINGBUFF_SIZE*USBBULK_XFERSIZE + 0x1000, MEM_COMMIT, PAGE_READWRITE );
-		if(m_TsBuffSize == NULL)	throw (const DWORD)__LINE__;
-		m_pTsBuff = (BYTE*)(m_TsBuffSize + 0x400);
-		m_indexTsBuff = 0;
-
-		usbDev->SetBuffer( (void*)m_TsBuffSize );
-		usbDev->TransferStart();
-#ifndef NO_TSTHREAD
-		m_hThread = (HANDLE)_beginthreadex( NULL, 0, TsThread, (PVOID)this, 0, NULL );
-		if(m_hThread == INVALID_HANDLE_VALUE) {
-			m_hThread = NULL;
-		}else{
-			::SetThreadPriority( m_hThread, THREAD_PRIORITY_TIME_CRITICAL );
-			m_hTsRecv = ::CreateEvent ( NULL, FALSE, FALSE, NULL );
-		}
-#endif
+		PastSleep(500,dwStart);
+
+		usbDev->SetupUSBEndPoint(&m_USBEP);
+
+		// FIFO
+		if(!FifoInitialize(&m_USBEP)) throw (const DWORD)__LINE__;
+
 		// foCXgp Iǂ͂܂
+		DBGOUT("OpenTuner done.\n");
 	}
-	catch (const DWORD dwErrorStep) {
+	catch (
+		const DWORD
+#ifdef _DEBUG
+		dwErrorStep
+#endif
+		) {
 		// Error
 		DBG_INFO("BonDriver_FSUSB2N:OpenTuner dwErrorStep = %lu\n", dwErrorStep);
 
@@ -111,24 +106,10 @@
 
 void CBonTuner::CloseTuner()
 {
-	if(m_TsBuffSize)
-	{
-		usbDev->TransferStop();
-		usbDev->SetBuffer(NULL);
-		::VirtualFree( (LPVOID)m_TsBuffSize, 0, MEM_RELEASE );
-		m_TsBuffSize = NULL;
-	}
 
-#ifndef NO_TSTHREAD
-	if(m_hThread != NULL) {
-		if(::WaitForSingleObject(m_hThread, 1500) != WAIT_OBJECT_0) {
-			::TerminateThread(m_hThread, 0);
-		}
-		::CloseHandle(m_hThread);
-		::CloseHandle(m_hTsRecv);
-		m_hThread = NULL;
-	}
-#endif
+	FifoFinalize() ;
+
+	if(usbDev) usbDev->CleanupUSBEndPoint(&m_USBEP);
 
 	if(pDev) {
 		delete pDev;
@@ -139,142 +120,27 @@
 		delete usbDev;
 		usbDev = NULL;
 	}
-}
 
-const BOOL CBonTuner::SetChannel(const BYTE bCh)
-{
-	// IBonDriverƂ̌݊ۂ߂Ɏb
+	FreeDevice(m_hDev,m_hUsbDev);
 
-	if(bCh < 13 || bCh > 52) return FALSE;
-	else return SetChannel(0UL, bCh - 13U);
+	DBGOUT("CloseTuner done.\n");
 }
 
 const float CBonTuner::GetSignalLevel(void)
 {
 	if(pDev == NULL) return 0.0f;
-	return pDev->DeMod_GetQuality() * 0.01f;
-}
 
-const DWORD CBonTuner::WaitTsStream(const DWORD dwTimeOut)
-{
-	if(GetReadyCount() > 0)
-	{
-		return WAIT_OBJECT_0;
-	}
-	if(m_TsBuffSize == NULL)
-	{
-		::Sleep(dwTimeOut < 2000 ? dwTimeOut : 2000 );
-		return WAIT_TIMEOUT;
-	}
-#ifdef NO_TSTHREAD
-	DWORD dwRet = ::WaitForSingleObject( usbDev->GetHandle() , dwTimeOut );
-
-	if( dwRet == WAIT_OBJECT_0  )
-	{
-		int nRet = usbDev->DispatchTSRead();
-		if( nRet < 0 )	return WAIT_FAILED;
-	}
-	return dwRet;
-#else
-	return ::WaitForSingleObject(m_hTsRecv, dwTimeOut);
-#endif
-}
-
-const DWORD CBonTuner::GetReadyCount()
-{
-	// o\TSf[^擾
-	if(m_TsBuffSize == NULL) return 0;
-	const int indexCurrent = m_indexTsBuff;
-	int val;
-
-#ifdef NO_TSTHREAD
-	DWORD dwRet = ::WaitForSingleObject( usbDev->GetHandle() , 0 );
-
-	if( dwRet == WAIT_FAILED )
-	{
-		return 0;
-	}else if( dwRet == WAIT_OBJECT_0 || dwRet == WAIT_TIMEOUT )
-	{
-		usbDev->DispatchTSRead();
-	}
-#endif
-
-	// size=0skip
-	do {
-		val = m_TsBuffSize[m_indexTsBuff];
-		if(val > 0 || val == -1) {
-			break;
-		}else if(val <= -2) {
-			m_indexTsBuff = 0;
-		}else if(val == 0) {
-			m_indexTsBuff++;
-		}
-	} while(m_indexTsBuff != indexCurrent);
-
-	return m_TsBuffSize[m_indexTsBuff] < 0 ? 0 : 1;
-}
+	const bool do_locking = FSUSB2N_LOCK_ON_SIGNAL && m_USBEP.dev && m_USBEP.lockunlockFunc ;
 
-const BOOL CBonTuner::GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	BYTE *pSrc = NULL;
-
-	// TSf[^Buffero
-	if(GetTsStream(&pSrc, pdwSize, pdwRemain)){
-		if(*pdwSize) {
-			::CopyMemory(pDst, pSrc, *pdwSize);
-		}
-		return TRUE;
-	}
-	
-	return FALSE;
-}
+	if(do_locking) //# lock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,1);
 
-const BOOL CBonTuner::GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	//
-	if(m_TsBuffSize == NULL) return FALSE;
-	const unsigned int BuffBlockSize = -m_TsBuffSize[0x3ff];
-	int val;
-
-	if(GetReadyCount() == 0) {
-		// o\ȃf[^Ȃ
-		*pdwSize = 0;
-		*pdwRemain = 0;
-		return TRUE;
-	}
+	float db = pDev->DeMod_GetQuality() * 0.01f;
 
-	*ppDst = m_pTsBuff + (m_indexTsBuff * BuffBlockSize);
-	int dataLen = 0;
-	do {
-		val = m_TsBuffSize[m_indexTsBuff];
-
-		if(val >= 0) {
-			dataLen += val;
-			m_indexTsBuff++;
-		}
-	} while(val == BuffBlockSize);
+	if(do_locking) //# unlock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,0);
 
-	*pdwSize = dataLen;
-	*pdwRemain = GetReadyCount();
-	return TRUE;
-}
-
-void CBonTuner::PurgeTsStream()
-{
-	if(m_TsBuffSize == NULL) return;
-	if(m_TsBuffSize[m_indexTsBuff] < 0) return;
-
-	// Buffero\f[^p[W
-	for(int i = 0; i <= 0x3fe; i++) {
-		if(m_TsBuffSize[i] == -1)
-		{
-			m_indexTsBuff = i;
-			return;
-		}else if(m_TsBuffSize[i] == -2)
-		{
-			return;
-		}
-	}
+	return db ;
 }
 
 void CBonTuner::Release()
@@ -286,81 +152,66 @@
 LPCTSTR CBonTuner::GetTunerName(void)
 {
 	// `[iԂ
-	return TEXT("KTV-FSUSB2V");
+	return TEXT("FSUSB2N");
 }
 
 const BOOL CBonTuner::IsTunerOpening(void)
 {
-	return pDev ? TRUE : FALSE;
-}
-
-LPCTSTR CBonTuner::EnumTuningSpace(const DWORD dwSpace)
-{
-	// gp\ȃ`[jOԂԂ
-	if(dwSpace == 0U) return TEXT("nfW");
-	else if(m_ChannelList != NULL && dwSpace == 1U) return TEXT("nfW(ǉ)");
-	return NULL;
-}
-
-LPCTSTR CBonTuner::EnumChannelName(const DWORD dwSpace, const DWORD dwChannel)
-{
-	// gp\ChannelԂ
-
-	static const TCHAR ChannelNameT[][3] = 
-	{
-		TEXT("13"), TEXT("14"), TEXT("15"), TEXT("16"), TEXT("17"), TEXT("18"), TEXT("19"),
-		TEXT("20"), TEXT("21"), TEXT("22"), TEXT("23"), TEXT("24"), TEXT("25"), TEXT("26"), TEXT("27"), TEXT("28"), TEXT("29"),
-		TEXT("30"), TEXT("31"), TEXT("32"), TEXT("33"), TEXT("34"), TEXT("35"), TEXT("36"), TEXT("37"), TEXT("38"), TEXT("39"), 
-		TEXT("40"), TEXT("41"), TEXT("42"), TEXT("43"), TEXT("44"), TEXT("45"), TEXT("46"), TEXT("47"), TEXT("48"), TEXT("49"), 
-		TEXT("50"), TEXT("51"), TEXT("52")
-	};
-
-	if(m_ChannelList != NULL && dwSpace == 1U) {
-		/* [U[` */
-		DWORD dwChannelLen		= m_ChannelList[0] >> 16;
-		DWORD dwNumOfChannels	= m_ChannelList[0] & 0xffff;
-		TCHAR *ptrStr = (TCHAR*)(m_ChannelList + dwNumOfChannels + 1);
-		if(dwChannel < dwNumOfChannels)	return ptrStr + (dwChannelLen * dwChannel);
-	}else if(dwSpace == 0U) {
-		if(dwChannel < 40)
-			return ChannelNameT[dwChannel];
-	}
-	return NULL;
+	return m_hUsbDev ? TRUE : FALSE;
 }
 
 const BOOL CBonTuner::SetChannel(const DWORD dwSpace, const DWORD dwChannel)
 {
-	if(pDev == NULL) return FALSE;
-	if(NULL == EnumChannelName(dwSpace, dwChannel)) return FALSE;
+	if(NULL == pDev) return FALSE;
+	if(NULL == tsthr) return FALSE;
 
-	DWORD dwFreq;
 
-	if(m_ChannelList != NULL && dwSpace == 1U) {
-		/* [U[` */
-		dwFreq = m_ChannelList[dwChannel + 1];
-	}else if(dwSpace == 0U) {
-		dwFreq = dwChannel * 6000U + 473143U;
-	}else{
-		return FALSE;
-	}
+    DWORD dwFreq = GetChannel(dwSpace,dwChannel).Freq ;
+
 	if(dwFreq < 90000U || dwFreq > 772000U) return FALSE;
 
 	// ChannelύX
-	usbDev->TransferPause();
 
-	pDev->SetFrequency(dwFreq);
-	::Sleep(5);
-	pDev->ResetDeMod();
-	::Sleep(20);
-	usbDev->TransferResume();
-	::Sleep(10);
+	FifoStop();
+	HRSleep(FSUSB2N_INTERIM_WAIT);
+
+	const bool do_locking = FSUSB2N_LOCK_ON_SIGNAL && m_USBEP.dev && m_USBEP.lockunlockFunc ;
+
+	if(do_locking) //# lock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,1);
+
+	for(DWORD i=FSUSB2N_SETFREQ_TIMES;i;i--) {
+		pDev->SetFrequency(dwFreq);
+		HRSleep(FSUSB2N_INTERIM_WAIT);
+	}
+	for(DWORD i=FSUSB2N_RESETDEMOD_TIMES;i;i--) {
+		pDev->ResetDeMod();
+		HRSleep(FSUSB2N_INTERIM_WAIT);
+	}
+
+	BOOL locked = FALSE ;
+	for(DWORD e=0,s=Elapsed();FSUSB2N_CHANNEL_WAIT>e;e=Elapsed(s)) {
+		HRSleep(40);
+		if(pDev->DeMod_GetSequenceState() < 6)
+			continue;
+		locked=TRUE;
+		break;
+	}
+
+	if(do_locking) //# unlock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,0);
+
+	FifoStart();
+	HRSleep(FSUSB2N_INTERIM_WAIT);
+
 	PurgeTsStream();
 
+
 	// ChannelXV
 	m_dwCurSpace = dwSpace;
 	m_dwCurChannel = dwChannel;
 
-	return TRUE;
+	return FSUSB2N_FASTSCAN? locked: TRUE;
 }
 
 const DWORD CBonTuner::GetCurSpace(void)
@@ -375,107 +226,24 @@
 	return m_dwCurChannel;
 }
 
-#ifndef NO_TSTHREAD
-unsigned int __stdcall CBonTuner::TsThread (PVOID pv)
+void CBonTuner::LoadValues(const IValueLoader *Loader)
 {
-	DWORD dwRet;
-	int nRet;
-	EM2874Device *pUsbDev;
-
-	if(pv && ((CBonTuner*)pv)->usbDev)
-	{
-		pUsbDev = ((CBonTuner*)pv)->usbDev;
-	}else{
-		::_endthreadex (0);
-		return 0;
-	}
-
-	for(;;)
-	{
-		dwRet = ::WaitForSingleObject( pUsbDev->GetHandle() , 1000 );
-
-		if( dwRet == WAIT_FAILED )
-		{
-			break;
-		}else if( dwRet == WAIT_OBJECT_0 || dwRet == WAIT_TIMEOUT )
-		{
-			nRet = pUsbDev->DispatchTSRead();
-			if(nRet > 0)	::SetEvent(((CBonTuner*)pv)->m_hTsRecv);
-			if(nRet < 0)	break;
-		}
-	}
-	::_endthreadex (0);
-	return 0;
-}
-#endif
-
+	DWORD FunctionMode = DWORD(EM2874Device::UserSettings&0xffff) | DWORD(KtvDevice::UserSettings)<<16 ;
 
-bool CBonTuner::LoadData ()
-{
-	HKEY hKey;
+	CBonFSHybrid::LoadValues (Loader) ;
+	#define LOADDW(val) do { val = Loader->ReadDWORD(L#val,val); } while(0)
+	LOADDW(FunctionMode);
+	LOADDW(FSUSB2N_INTERIM_WAIT);
+	LOADDW(FSUSB2N_SETFREQ_TIMES);
+	LOADDW(FSUSB2N_RESETDEMOD_TIMES);
+	LOADDW(FSUSB2N_CHANNEL_WAIT);
+	LOADDW(FSUSB2N_LOCK_ON_SIGNAL);
+	LOADDW(FSUSB2N_FASTSCAN);
+	#undef LOADDW
 
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, g_RegKey, 0, KEY_READ, &hKey))
-	{
-		ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, g_RegKey, 0, KEY_READ, &hKey))
-	{
-		ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-
-	return true;
+	EM2874Device::UserSettings = FunctionMode & 0xffff;
+	KtvDevice::UserSettings = FunctionMode >> 16;
 }
 
-void CBonTuner::ReadRegMode (HKEY hPKey)
-{
-	DWORD dwValue, dwLen, dwType;
-
-	dwLen = sizeof(dwValue);
-	if(ERROR_SUCCESS != RegQueryValueEx( hPKey, TEXT("FunctionMode"), NULL, &dwType, (BYTE*)&dwValue, &dwLen)
-		|| dwLen != sizeof(DWORD) ) {
-		return;
-	}
-	EM2874Device::UserSettings = dwValue & 0xffff;
-	KtvDevice::UserSettings = dwValue >> 16;
-}
+} // End of namespace FSUSB2N
 
-void CBonTuner::ReadRegChannels (HKEY hPKey)
-{
-	if(m_ChannelList != NULL) return;
-	//
-	HKEY hKey;
-	DWORD NumOfValues;
-	TCHAR szValueName[32];
-	DWORD dwValue, dwLen, dwType, dwByte, dwMaxValueName;
-	if(ERROR_SUCCESS != RegOpenKeyEx( hPKey, TEXT("Channels"), 0, KEY_READ, &hKey)) {
-		return;
-	}
-	if(ERROR_SUCCESS != RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumOfValues, &dwMaxValueName, NULL, NULL, NULL)) {
-		RegCloseKey(hKey);
-		return;
-	}
-	dwMaxValueName++;
-	m_ChannelList = (DWORD*) GlobalAlloc(GMEM_FIXED, NumOfValues * (dwMaxValueName * sizeof(TCHAR) + sizeof(DWORD)) + sizeof(DWORD) );
-	m_ChannelList[0] = dwMaxValueName << 16 | NumOfValues;
-	ZeroMemory( m_ChannelList + 1, sizeof(DWORD) * NumOfValues );
-	TCHAR *ptrStr;
-	for(DWORD dwIdx = 0; dwIdx < NumOfValues; dwIdx++ ) {
-		dwLen = 32;
-		dwByte = sizeof(dwValue);
-		if(ERROR_SUCCESS != RegEnumValue( hKey, dwIdx, szValueName, &dwLen, NULL, &dwType, (BYTE*)&dwValue, &dwByte)
-			|| dwByte != sizeof(DWORD)) {
-			break;
-		}
-		dwByte = dwValue >> 24; // Index
-		if( dwByte >= NumOfValues ) continue;
-		m_ChannelList[dwByte + 1] = dwValue & 0x00ffffffU;
-		ptrStr = (TCHAR*)(m_ChannelList + NumOfValues + 1);
-		ptrStr += dwMaxValueName * dwByte;
-		lstrcpyn( ptrStr, szValueName, dwMaxValueName );
-	}
-	RegCloseKey(hKey);
-}
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.h BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.h	2012-09-28 01:55:04.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.h	2020-11-02 23:20:02.000000000 +0900
@@ -3,66 +3,56 @@
 // BonTuner.h: CBonTuner NX̃C^[tFCX
 //////////////////////////////////////////////////
 
+#include <vector>
+#include <queue>
+#include <cstdlib>
 #include "IBonDriver2.h"
 #include "../ktv.h"
+#include "../usbdevfile.h"
+#include "../bonhybrid.h"
 
-class CBonTuner : public IBonDriver2
+namespace FSUSB2N {
+
+class CBonTuner : public CBonFSHybrid
 {
+protected:
+	const TCHAR *RegName() ;
+	int UserDecidedDeviceIdx() ;
+    void LoadValues(const IValueLoader *Loader);
+	const BOOL TryOpenTuner(void);
+
 public:
 	CBonTuner();
 	virtual ~CBonTuner();
 
 // IBonDriver
-	const BOOL OpenTuner(void);
 	void CloseTuner(void);
 
-	const BOOL SetChannel(const BYTE bCh);
 	const float GetSignalLevel(void);
 
-	const DWORD WaitTsStream(const DWORD dwTimeOut = 0);
-	const DWORD GetReadyCount(void);
-
-	const BOOL GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain);
-	const BOOL GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain);
-
-	void PurgeTsStream(void);
-
 // IBonDriver2(b)
 	LPCTSTR GetTunerName(void);
 
 	const BOOL IsTunerOpening(void);
-	
-	LPCTSTR EnumTuningSpace(const DWORD dwSpace);
-	LPCTSTR EnumChannelName(const DWORD dwSpace, const DWORD dwChannel);
 
 	const BOOL SetChannel(const DWORD dwSpace, const DWORD dwChannel);
-	
+
 	const DWORD GetCurSpace(void);
 	const DWORD GetCurChannel(void);
 
 	void Release(void);
 
-	static CBonTuner * m_pThis;
-	static HINSTANCE m_hModule;
-
 protected:
 	DWORD m_dwCurSpace;
 	DWORD m_dwCurChannel;
-	DWORD *m_ChannelList;
 
+	HANDLE m_hDev;
+	HANDLE m_hUsbDev;
+	struct usb_endpoint_st  m_USBEP;
 	EM2874Device *usbDev;
 	KtvDevice *pDev;
-	BYTE *m_pTsBuff;
-	volatile int *m_TsBuffSize;		// 32bit signed
-	volatile int m_indexTsBuff;
-
-#ifndef NO_TSTHREAD
-	HANDLE m_hThread;
-	HANDLE m_hTsRecv;
-	static unsigned int __stdcall TsThread (PVOID pv);
-#endif
-
-	bool LoadData ();
-	void ReadRegMode (HKEY hPKey);
-	void ReadRegChannels (HKEY hPKey);
+
 };
+
+} // End of namespace FSUSB2N
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/dllmain.cpp BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/dllmain.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/dllmain.cpp	2009-09-02 03:28:53.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/dllmain.cpp	2020-01-07 03:20:04.000000000 +0900
@@ -1,10 +1,12 @@
 // dllmain.cpp : DLL AvP[ṼGg |Cg`܂B
 #include "stdafx.h"
-#include "BonTuner.h"
+#include "BonTuner_FSUSB2N.h"
+
+using namespace FSUSB2N;
 
 BOOL APIENTRY DllMain( HMODULE hModule,
-                       DWORD  ul_reason_for_call,
-                       LPVOID lpReserved
+					   DWORD  ul_reason_for_call,
+					   LPVOID lpReserved
 					 )
 {
 	switch (ul_reason_for_call)
@@ -14,10 +16,15 @@
 		CBonTuner::m_hModule = hModule;
 		break;
 	case DLL_PROCESS_DETACH:
-		// J̏ꍇ̓CX^XJ		
+		// J̏ꍇ̓CX^XJ
 		if(CBonTuner::m_pThis)CBonTuner::m_pThis->Release();
 		break;
 	}
 	return TRUE;
 }
 
+#pragma warning( disable : 4273 )
+extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
+{return BonFSCreate<CBonTuner>();}
+#pragma warning( default : 4273 )
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/stdafx.h BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/stdafx.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/stdafx.h	2009-09-02 03:29:22.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/stdafx.h	2022-05-02 22:17:21.000000000 +0900
@@ -6,3 +6,9 @@
 #include <windows.h>
 #include <tchar.h>
 #include <process.h>
+
+#include "../message.h"
+
+#include "../twindbg.h"
+
+#include "../HRTimer.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/stdafx2.c BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/stdafx2.c
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/stdafx2.c	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2N/stdafx2.c	2015-12-09 05:03:24.000000000 +0900
@@ -0,0 +1 @@
+#include "stdafx.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver.rc BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/BonDriver.rc
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver.rc	2016-02-18 20:22:16.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/BonDriver.rc	2022-08-11 13:28:36.000000000 +0900
@@ -2,8 +2,8 @@
 
 LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT
 1 VERSIONINFO
- FILEVERSION 0,1,5,5
- PRODUCTVERSION 0,1,5,5
+ FILEVERSION 0,2022,8,11
+ PRODUCTVERSION 0,2022,8,11
  FILEFLAGSMASK 0x17L
 #ifdef _DEBUG
  FILEFLAGS 0x1L
@@ -18,14 +18,14 @@
     BEGIN
         BLOCK "041104b0"
         BEGIN
-            VALUE "CompanyName", "trinity19683"
+            VALUE "CompanyName", "hyrolean-dtv inspired by trinity19683"
             VALUE "FileDescription", "BonDriver for FSUSB2i"
-            VALUE "FileVersion", "0,1,5,5"
+            VALUE "FileVersion", "0,2022,8,11"
             VALUE "InternalName", "BonDriver_FSUSB2i.dll"
-            VALUE "LegalCopyright", "trinity19683 2015-2016"
+            VALUE "LegalCopyright", "hyrolean-dtv 2018-2022 inspired by trinity19683 2015-2016"
             VALUE "OriginalFilename", "BonDriver_FSUSB2i.dll"
             VALUE "ProductName", "BonDriver_FSUSB2i"
-            VALUE "ProductVersion", "0,1,5,5"
+            VALUE "ProductVersion", "0,2022,8,11"
         END
     END
     BLOCK "VarFileInfo"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcproj	2022-05-02 21:56:27.000000000 +0900
@@ -0,0 +1,1009 @@
+<?xml version="1.0" encoding="shift_jis"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="BonDriver_FSUSB2i"
+	ProjectGUID="{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}"
+	RootNamespace="BonDriver_FSUSB2i"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="196613"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2i.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2i_x64.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2i.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2i_x64.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="\[X t@C"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\bonhybrid.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\BonTuner_FSUSB2i.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\dllmain.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\it9175.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\it9175_usb.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\message.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\osdepend.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\pryutil.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\HRTimer.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx2.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tsthread.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbops.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="wb_[ t@C"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\bonhybrid.h"
+				>
+			</File>
+			<File
+				RelativePath=".\BonTuner_FSUSB2i.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_fw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_priv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\message.h"
+				>
+			</File>
+			<File
+				RelativePath="..\osdepend.h"
+				>
+			</File>
+			<File
+				RelativePath="..\pryutil.h"
+				>
+			</File>
+			<File
+				RelativePath="..\HRTimer.h"
+				>
+			</File>
+			<File
+				RelativePath=".\stdafx.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\stdint_.h"
+				>
+			</File>
+			<File
+				RelativePath="..\targetver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsbuff.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsthread.h"
+				>
+			</File>
+			<File
+				RelativePath="..\twindbg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\types_u.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb100.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb200.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbops.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusbio.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="\[X t@C"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\BonDriver.rc"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcxproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcxproj	2016-02-11 08:58:44.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcxproj	2022-05-02 21:56:27.000000000 +0900
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Debug|Win32">
       <Configuration>Debug</Configuration>
@@ -22,6 +22,7 @@
     <ProjectGuid>{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>FSUSB2i</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Label="Configuration">
@@ -36,7 +37,13 @@
     <WholeProgramOptimization>true</WholeProgramOptimization>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='x64'" Label="Configuration">
-    <PlatformToolset>Windows7.1SDK</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
@@ -65,10 +72,28 @@
     <LinkIncremental>false</LinkIncremental>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='Win32'">
-    <LibraryPath>..\lib;$(LibraryPath)</LibraryPath>
+    <LibraryPath>$(LibraryPath)</LibraryPath>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='x64'">
-    <LibraryPath>..\lib64;$(LibraryPath)</LibraryPath>
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
   </PropertyGroup>
   <ItemDefinitionGroup>
     <ClCompile>
@@ -106,23 +131,32 @@
     <ClCompile>
       <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;FSUSB2I_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
+    <Link />
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;FSUSB2I_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
+    <Link>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+    </Link>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
     <ClCompile>
       <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;FSUSB2I_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
+    <Link />
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <ClCompile>
       <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;FSUSB2I_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
+    <Link>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+    </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClInclude Include="..\bonhybrid.h" />
     <ClInclude Include="..\it9175.h" />
     <ClInclude Include="..\it9175_fw.h" />
     <ClInclude Include="..\it9175_priv.h" />
@@ -135,10 +169,18 @@
     <ClInclude Include="..\types_u.h" />
     <ClInclude Include="..\usbdevfile.h" />
     <ClInclude Include="..\usbops.h" />
-    <ClInclude Include="BonTuner.h" />
+    <ClInclude Include="BonTuner_FSUSB2i.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="..\HRTimer.h" />
     <ClInclude Include="stdafx.h" />
   </ItemGroup>
   <ItemGroup>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="..\it9175.c">
       <PrecompiledHeader>NotUsing</PrecompiledHeader>
     </ClCompile>
@@ -150,7 +192,13 @@
       <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
     <ClCompile Include="..\usbops.c" />
-    <ClCompile Include="BonTuner.cpp">
+    <ClCompile Include="BonTuner_FSUSB2i.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\HRTimer.cpp">
       <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
     <ClCompile Include="dllmain.cpp">
BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2iȯ: BonDriver_FSUSB2i.vcxproj.filters
BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2iȯ: BonDriver_FSUSB2i.vcxproj.user
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.cpp BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.cpp	2016-02-12 00:14:10.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.cpp	2022-05-02 23:18:22.000000000 +0900
@@ -3,37 +3,48 @@
   BonTuner.cpp
   2016-02-12
 */
-
 #include "stdafx.h"
+
 #include <tchar.h>
-#include "BonTuner.h"
+#include "BonTuner_FSUSB2i.h"
 #include "../usbdevfile.h"
 
-#pragma warning( disable : 4273 )
-extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
-{ return (CBonTuner::m_pThis)? CBonTuner::m_pThis : ((IBonDriver *) new CBonTuner); }
-#pragma warning( default : 4273 )
-
-//# initialize static member variables
-CBonTuner * CBonTuner::m_pThis = NULL;
-HINSTANCE CBonTuner::m_hModule = NULL;
+using namespace std ;
+
+namespace FSUSB2i {
+
+DWORD FSUSB2I_SETFREQ_TIMES  = 2     ;
+DWORD FSUSB2I_TUNING_WAIT    = 1500  ;
+DWORD FSUSB2I_CHANNEL_WAIT   = 800   ;
+BOOL  FSUSB2I_LOCK_ON_SIGNAL = TRUE  ;
+BOOL  FSUSB2I_FASTSCAN       = FALSE ;
 
 const TCHAR* const g_RegKey = TEXT("Software\\trinity19683\\FSUSB2i");
 
 CBonTuner::CBonTuner()
-: m_dwCurSpace(0), m_dwCurChannel(0), m_hDev(NULL), m_hUsbDev(NULL), pDev(NULL), tsthr(NULL),
- m_ChannelList(NULL)
-{ m_pThis = this; }
+: CBonFSHybrid(), m_dwCurSpace(0), m_dwCurChannel(0), m_hDev(NULL), m_hUsbDev(NULL), pDev(NULL)
+{}
 
 CBonTuner::~CBonTuner()
 {
 	CloseTuner();
+}
 
-	if(m_ChannelList != NULL) ::GlobalFree(m_ChannelList);
-	m_pThis = NULL;
+const TCHAR *CBonTuner::RegName()
+{
+	return g_RegKey ;
 }
 
-const BOOL CBonTuner::OpenTuner()
+int CBonTuner::UserDecidedDeviceIdx()
+{
+	int idx=0 ;
+	if(sscanf_s( upper_case(file_prefix_of(ModuleFileName())).c_str() , "BONDRIVER_FSUSB2I_DEV%d", &idx )==1)
+	  return idx ;
+
+	return -1 ;
+}
+
+const BOOL CBonTuner::TryOpenTuner()
 {
 	//# if already open, close tuner
 	CloseTuner();
@@ -41,30 +52,18 @@
 
 	try{
 		//# AllocTuner
-		for(unsigned int idx = 0; idx < 40;) {
-			HANDLE hDev;
-			if((hDev = usbdevfile_alloc(&idx) ) == NULL) {   //# not found
-				throw (const DWORD)__LINE__;
-			}
-			//# found
-			m_hDev = hDev;
-			if((hDev = usbdevfile_init(m_hDev) ) == NULL) {   //# failed
-				throw (const DWORD)__LINE__;
-			}
-			m_hUsbDev = hDev;
-			break;
+		if(!FindDevice(GUID_WINUSB_FSUSB2V3_DRV,m_hDev,m_hUsbDev)) {
+		  if(m_hDev==NULL) throw (const DWORD)__LINE__;
+		  if(m_hUsbDev==NULL) throw (const DWORD)__LINE__;
 		}
 		//# device initialize
 		m_USBEP.fd = m_hUsbDev;
-		if(it9175_create(&pDev, &m_USBEP) != 0) {
-			throw (const DWORD)__LINE__;
-		}
-		if(tsthread_create(&tsthr, &m_USBEP) != 0) {
-			throw (const DWORD)__LINE__;
-		}
+		if(it9175_create(&pDev, &m_USBEP) != 0) throw (const DWORD)__LINE__;
+		//# fifo
+		if(!FifoInitialize(&m_USBEP)) throw (const DWORD)__LINE__;
 
 		//# device has been ready.
-		LoadData();
+		//LoadData();
 	}
 	catch (const DWORD dwErrorStep) {
 		//# Error
@@ -78,89 +77,31 @@
 
 void CBonTuner::CloseTuner()
 {
-	if(tsthr) {
-		tsthread_stop(tsthr);
-		tsthread_destroy(tsthr);
-		tsthr = NULL;
-	}
+	FifoFinalize() ;
 	if(pDev) {
 		it9175_destroy(pDev);
 		pDev = NULL;
 	}
-	if(m_hUsbDev) {
-		usbdevfile_free(m_hUsbDev);
-		m_hUsbDev = NULL;
-	}
-	if(m_hDev) {
-		::CloseHandle( m_hDev );
-		m_hDev = NULL;
-	}
-}
-
-const BOOL CBonTuner::SetChannel(const BYTE bCh)
-{
-	//# compatible with IBonDriver
-	if(bCh < 13 || bCh > 52) return FALSE;
-	else return SetChannel(0, bCh - 13);
+	FreeDevice(m_hDev,m_hUsbDev);
+	m_USBEP.dev=NULL;
 }
 
 const float CBonTuner::GetSignalLevel(void)
 {
 	if(NULL == pDev) return 0.0f;
-	uint8_t statData[44];
-	if(it9175_readStatistic(pDev, statData) != 0) return 0.1f;
-	return statData[3] * 1.0f;
-}
 
-const DWORD CBonTuner::WaitTsStream(const DWORD dwTimeOut)
-{
-	const int remainTime = (dwTimeOut < 0x10000000) ? dwTimeOut : 0x10000000;
-	if(NULL == tsthr) return WAIT_FAILED;
-
-	const int r = tsthread_wait(tsthr, remainTime);
-	if(0 > r)  return WAIT_FAILED;
-	else if(0 < r)  return WAIT_OBJECT_0;
-	else  return WAIT_TIMEOUT;
-}
+    bool do_locking = FSUSB2I_LOCK_ON_SIGNAL && m_USBEP.dev && m_USBEP.lockunlockFunc ;
 
-const DWORD CBonTuner::GetReadyCount()
-{//# number of call GetTsStream()
-	if(NULL == tsthr) return 0;
-	const int ret = tsthread_readable(tsthr);
-	return (ret > 0) ? 1 : 0;
-}
+    if(do_locking) //# lock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,1);
 
-const BOOL CBonTuner::GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	BYTE *pSrc = NULL;
-	if(GetTsStream(&pSrc, pdwSize, pdwRemain)){
-		if(*pdwSize) ::CopyMemory(pDst, pSrc, *pdwSize);
-		return TRUE;
-	}
-	return FALSE;
-}
-
-const BOOL CBonTuner::GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	if(! tsthr) return FALSE;
-	const int ret = tsthread_readable(tsthr);
-	if(ret <= 0) {
-		//# no readable data
-		*pdwSize = 0;
-		*pdwRemain = 0;
-		return TRUE;
-	}
-	*pdwSize = tsthread_read(tsthr, (void**)ppDst);
-	*pdwRemain = GetReadyCount();
-	//dmsg("GetTsStream(%p,%u,%u)", ppDst, *pdwSize, *pdwRemain);
-	return TRUE;
-}
-
-void CBonTuner::PurgeTsStream()
-{
-	if(! tsthr) return;
-	//# purge available data in TS buffer
-	tsthread_read(tsthr, NULL);
+	uint8_t dB; float lv ;
+	if(it9175_readSNRatio(pDev, &dB) != 0) lv = 0.1f;
+	else lv = dB * 1.0f;
+
+    if(do_locking) //# unlock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,0);
+    return lv ;
 }
 
 void CBonTuner::Release()  //# release the instance
@@ -172,67 +113,50 @@
 const BOOL CBonTuner::IsTunerOpening(void)
 { return m_hUsbDev ? TRUE : FALSE; }
 
-LPCTSTR CBonTuner::EnumTuningSpace(const DWORD dwSpace)
-{ return (dwSpace == 0) ? TEXT("nfW") : NULL; }
-
-LPCTSTR CBonTuner::EnumChannelName(const DWORD dwSpace, const DWORD dwChannel)
-{
-	if(dwSpace == 0) {
-		if(m_ChannelList != NULL) {
-			//# User-defined channels
-			const DWORD dwChannelLen    = m_ChannelList[0] >> 16;
-			const DWORD dwNumOfChannels = m_ChannelList[0] & 0xFFFF;
-			TCHAR* const ptrStr = (TCHAR*)(m_ChannelList + dwNumOfChannels + 1);
-			if(dwChannel < dwNumOfChannels)	return ptrStr + (dwChannelLen * dwChannel);
-		}else if(dwChannel < 40) {
-			static TCHAR buf[6];
-			_sntprintf_s(buf, sizeof(buf)/sizeof(TCHAR), _TRUNCATE, TEXT("%u"), dwChannel + 13);
-			return buf;    //# The caller must copy data from this buffer.
-		}
-	}
-	return NULL;
-}
-
 const BOOL CBonTuner::SetChannel(const DWORD dwSpace, const DWORD dwChannel)
 {
 	if(NULL == pDev) return FALSE;
 	if(NULL == tsthr) return FALSE;
 
-	DWORD dwFreq = 0;
+	DWORD dwFreq = GetChannel(dwSpace,dwChannel).Freq ;
 
-	if(dwSpace == 0) {
-		if(m_ChannelList != NULL) {  //# User-defined channels
-			const DWORD dwNumOfChannels = m_ChannelList[0] & 0xFFFF;
-			if(dwChannel < dwNumOfChannels)
-				dwFreq = m_ChannelList[dwChannel + 1];
-		}else{  //# UHF standard channels
-			if(dwChannel < 40)
-				dwFreq = dwChannel * 6000 + 473143;
-		}
-	}else if(dwSpace == 114514) {  //# dwChannel as freq/kHz
-		dwFreq = dwChannel;
-	}
 	if(dwFreq < 61000 || dwFreq > 874000 ) return FALSE;
 
 	//# change channel
-	tsthread_stop(tsthr);
+	FifoStop();
 
 	int ret;
-	if(it9175_setFreq(pDev, dwFreq) != 0) return FALSE;
+	int cnt=0 ;
+	do {
+	  if(it9175_setFreq(pDev, dwFreq) != 0) {
+		if(++cnt==FSUSB2I_SETFREQ_TIMES) return FALSE;
+		continue ;
+	  }
+	  break ;
+	}while(1) ;
 	//# set variables
 	m_dwCurSpace = dwSpace;
 	m_dwCurChannel = dwChannel;
-	::Sleep( 80 );
+	HRSleep( 80 );
+
+	FifoStart();
 
-	tsthread_start(tsthr);
+	if((ret = it9175_waitTuning(pDev, FSUSB2I_TUNING_WAIT)) < 0) return FALSE;
 
-	if((ret = it9175_waitTuning(pDev, 1500)) < 0) return FALSE;
-	//# ignore check empty channel
-	//# ignore check TS sync lock
+	//# check empty channel
+	//# check TS sync lock
+	uint8_t statics[10];
+	BOOL locked = FALSE ;
+	for(DWORD e=0,s=Elapsed();FSUSB2I_CHANNEL_WAIT>e;e=Elapsed(s)) {
+		HRSleep( 40 );
+		if(it9175_readStatistic(pDev, statics)==0) {
+			if((statics[0]&3)==3) { locked =  TRUE ; break ; }
+		}
+	}
 
 	PurgeTsStream();
 
-	return TRUE;
+	return FSUSB2I_FASTSCAN? locked: TRUE;
 }
 
 const DWORD CBonTuner::GetCurSpace(void)
@@ -242,62 +166,18 @@
 { return m_dwCurChannel; }
 
 
-bool CBonTuner::LoadData ()
+void CBonTuner::LoadValues(const IValueLoader *Loader)
 {
-	HKEY hKey;
-
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, g_RegKey, 0, KEY_READ, &hKey)) {
-		//ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, g_RegKey, 0, KEY_READ, &hKey)) {
-		//ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-
-	return true;
+	CBonFSHybrid::LoadValues (Loader) ;
+	#define LOADDW(val) do { val = Loader->ReadDWORD(L#val,val); } while(0)
+	LOADDW(FSUSB2I_SETFREQ_TIMES);
+	LOADDW(FSUSB2I_TUNING_WAIT);
+	LOADDW(FSUSB2I_CHANNEL_WAIT);
+    LOADDW(FSUSB2I_LOCK_ON_SIGNAL);
+	LOADDW(FSUSB2I_FASTSCAN);
+	#undef LOADDW
 }
 
-void CBonTuner::ReadRegMode (HKEY hPKey)
-{ return; }
-
-void CBonTuner::ReadRegChannels (HKEY hPKey)
-{
-	if(m_ChannelList != NULL) return;
-
-	HKEY hKey;
-	DWORD NumOfValues;
-	TCHAR szValueName[32];
-	DWORD dwValue, dwLen, dwType, dwByte, dwMaxValueName;
-	if(ERROR_SUCCESS != RegOpenKeyEx( hPKey, TEXT("Channels"), 0, KEY_READ, &hKey)) {
-		return;
-	}
-	if(ERROR_SUCCESS != RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumOfValues, &dwMaxValueName, NULL, NULL, NULL)) {
-		RegCloseKey(hKey);
-		return;
-	}
-	dwMaxValueName++;
-	m_ChannelList = (DWORD*) ::GlobalAlloc(GMEM_FIXED, NumOfValues * (dwMaxValueName * sizeof(TCHAR) + sizeof(DWORD)) + sizeof(DWORD) );
-	m_ChannelList[0] = dwMaxValueName << 16 | NumOfValues;
-	ZeroMemory( m_ChannelList + 1, sizeof(DWORD) * NumOfValues );
-	TCHAR *ptrStr;
-	for(DWORD dwIdx = 0; dwIdx < NumOfValues; dwIdx++ ) {
-		dwLen = 32;
-		dwByte = sizeof(dwValue);
-		if(ERROR_SUCCESS != RegEnumValue( hKey, dwIdx, szValueName, &dwLen, NULL, &dwType, (BYTE*)&dwValue, &dwByte)
-			|| dwByte != sizeof(DWORD)) {
-			break;
-		}
-		dwByte = dwValue >> 24; //# Index
-		if( dwByte >= NumOfValues ) continue;
-		m_ChannelList[dwByte + 1] = dwValue & 0x00ffffff;
-		ptrStr = (TCHAR*)(m_ChannelList + NumOfValues + 1);
-		ptrStr += dwMaxValueName * dwByte;
-		lstrcpyn( ptrStr, szValueName, dwMaxValueName );
-	}
-	RegCloseKey(hKey);
-}
+} // End of namespace FSUSB2i
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.h BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.h	2016-02-02 20:43:16.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.h	2020-11-02 23:20:00.000000000 +0900
@@ -9,59 +9,52 @@
 extern "C" {
 #include "../it9175.h"
 #include "../tsthread.h"
+#include "../tsbuff.h"
 }
 
-class CBonTuner : public IBonDriver2
+#include "../bonhybrid.h"
+
+namespace FSUSB2i {
+
+class CBonTuner : public CBonFSHybrid
 {
+protected:
+	const TCHAR *RegName() ;
+	int UserDecidedDeviceIdx() ;
+	void LoadValues(const IValueLoader *Loader) ;
+	const BOOL TryOpenTuner(void);
+
 public:
 	CBonTuner();
 	virtual ~CBonTuner();
 
 //# IBonDriver
-	const BOOL OpenTuner(void);
 	void CloseTuner(void);
 
-	const BOOL SetChannel(const BYTE bCh);
 	const float GetSignalLevel(void);
 
-	const DWORD WaitTsStream(const DWORD dwTimeOut = 0);
-	const DWORD GetReadyCount(void);
-
-	const BOOL GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain);
-	const BOOL GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain);
-
-	void PurgeTsStream(void);
-
 //# IBonDriver2
 	LPCTSTR GetTunerName(void);
 
 	const BOOL IsTunerOpening(void);
-	
-	LPCTSTR EnumTuningSpace(const DWORD dwSpace);
-	LPCTSTR EnumChannelName(const DWORD dwSpace, const DWORD dwChannel);
 
 	const BOOL SetChannel(const DWORD dwSpace, const DWORD dwChannel);
-	
+
 	const DWORD GetCurSpace(void);
 	const DWORD GetCurChannel(void);
 
 	void Release(void);
 
-	static CBonTuner * m_pThis;
-	static HINSTANCE m_hModule;
-
 protected:
 	DWORD m_dwCurSpace;
 	DWORD m_dwCurChannel;
-	DWORD *m_ChannelList;
 
 	HANDLE m_hDev;
 	HANDLE m_hUsbDev;
 	struct usb_endpoint_st  m_USBEP;
 	it9175_state pDev;
-	tsthread_ptr tsthr;
 
-	bool LoadData ();
-	void ReadRegMode (HKEY hPKey);
-	void ReadRegChannels (HKEY hPKey);
 };
+
+} // End of namespace FSUSB2i
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/dllmain.cpp BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/dllmain.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/dllmain.cpp	2015-12-09 05:06:04.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/dllmain.cpp	2020-01-07 03:20:04.000000000 +0900
@@ -1,5 +1,7 @@
 #include "stdafx.h"
-#include "BonTuner.h"
+#include "BonTuner_FSUSB2i.h"
+
+using namespace FSUSB2i;
 
 BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )
 {
@@ -13,3 +15,9 @@
 	}
 	return TRUE;
 }
+
+#pragma warning( disable : 4273 )
+extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
+{return BonFSCreate<CBonTuner>();}
+#pragma warning( default : 4273 )
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/stdafx.h BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/stdafx.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/stdafx.h	2015-12-30 16:04:20.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_FSUSB2i/stdafx.h	2022-05-02 22:17:21.000000000 +0900
@@ -4,3 +4,7 @@
 #include <windows.h>
 
 #include "../message.h"
+
+#include "../twindbg.h"
+
+#include "../HRTimer.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver.rc BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver.rc
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver.rc	2016-02-18 20:22:18.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver.rc	2022-08-11 13:28:36.000000000 +0900
@@ -2,8 +2,8 @@
 
 LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT
 1 VERSIONINFO
- FILEVERSION 0,1,3,1
- PRODUCTVERSION 0,1,3,1
+ FILEVERSION 0,2022,8,11
+ PRODUCTVERSION 0,2022,8,11
  FILEFLAGSMASK 0x17L
 #ifdef _DEBUG
  FILEFLAGS 0x1L
@@ -18,15 +18,21 @@
     BEGIN
         BLOCK "041104b0"
         BEGIN
-            VALUE "CompanyName", "trinity19683"
+            VALUE "CompanyName", "hyrolean-dtv inspired by trinity19683"
+            VALUE "FileVersion", "0,2022,8,11"
+#ifdef INCLUDE_ISOCH_XFER
+            VALUE "FileDescription", "BonDriver for uSUNpTV (isoch support)"
+            VALUE "InternalName", "BonDriver_uSUNpTV_isoch.dll"
+            VALUE "OriginalFilename", "BonDriver_uSUNpTV_isoch.dll"
+            VALUE "ProductName", "BonDriver_uSUNpTV_isoch"
+#else
             VALUE "FileDescription", "BonDriver for uSUNpTV"
-//            VALUE "FileDescription", "BonDriver for uSUNpTV (isoch support)"
-            VALUE "FileVersion", "0,1,3,1"
             VALUE "InternalName", "BonDriver_uSUNpTV.dll"
-            VALUE "LegalCopyright", "trinity19683 2016"
             VALUE "OriginalFilename", "BonDriver_uSUNpTV.dll"
             VALUE "ProductName", "BonDriver_uSUNpTV"
-            VALUE "ProductVersion", "0,1,3,1"
+#endif
+            VALUE "LegalCopyright", "hyrolean-dtv 2019-2022 inspired by trinity19683 2016"
+            VALUE "ProductVersion", "0,2022,8,11"
         END
     END
     BLOCK "VarFileInfo"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcproj	2022-05-02 21:56:28.000000000 +0900
@@ -0,0 +1,1093 @@
+<?xml version="1.0" encoding="shift_jis"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="BonDriver_uSUNpTV"
+	ProjectGUID="{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}"
+	RootNamespace="BonDriver_uSUNpTV"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="196613"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_uSUNpTV.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_uSUNpTV_x64.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_uSUNpTV.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_uSUNpTV_x64.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="\[X t@C"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\bonhybrid.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\BonTuner_uSUNpTV.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\dllmain.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\em287x.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\em287x_usb.c"
+				>
+			</File>
+			<File
+				RelativePath="..\message.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\mxl136.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\osdepend.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\pryutil.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\HRTimer.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx2.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tc90522.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tda20142.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tsthread.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbops.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="wb_[ t@C"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\bonhybrid.h"
+				>
+			</File>
+			<File
+				RelativePath=".\BonTuner_uSUNpTV.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x_priv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x_usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonTransponder.h"
+				>
+			</File>
+			<File
+				RelativePath="..\message.h"
+				>
+			</File>
+			<File
+				RelativePath="..\mxl136.h"
+				>
+			</File>
+			<File
+				RelativePath="..\osdepend.h"
+				>
+			</File>
+			<File
+				RelativePath="..\pryutil.h"
+				>
+			</File>
+			<File
+				RelativePath="..\HRTimer.h"
+				>
+			</File>
+			<File
+				RelativePath=".\stdafx.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\stdint_.h"
+				>
+			</File>
+			<File
+				RelativePath="..\targetver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tc90522.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tda20142.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsbuff.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsthread.h"
+				>
+			</File>
+			<File
+				RelativePath="..\twindbg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\types_u.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb100.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb200.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbops.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusbio.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="\[X t@C"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\BonDriver.rc"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj	2016-02-02 02:27:20.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj	2022-05-02 21:56:28.000000000 +0900
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Debug|Win32">
       <Configuration>Debug</Configuration>
@@ -22,6 +22,8 @@
     <ProjectGuid>{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>uSUNpTV</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+    <ProjectName>BonDriver_uSUNpTV</ProjectName>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Label="Configuration">
@@ -36,7 +38,13 @@
     <WholeProgramOptimization>true</WholeProgramOptimization>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='x64'" Label="Configuration">
-    <PlatformToolset>Windows7.1SDK</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
@@ -65,10 +73,28 @@
     <LinkIncremental>false</LinkIncremental>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='Win32'">
-    <LibraryPath>..\lib;$(LibraryPath)</LibraryPath>
+    <LibraryPath>$(LibraryPath)</LibraryPath>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='x64'">
-    <LibraryPath>..\lib64;$(LibraryPath)</LibraryPath>
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
   </PropertyGroup>
   <ItemDefinitionGroup>
     <ClCompile>
@@ -123,6 +149,7 @@
     </ClCompile>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClInclude Include="..\bonhybrid.h" />
     <ClInclude Include="..\em287x.h" />
     <ClInclude Include="..\em287x_priv.h" />
     <ClInclude Include="..\em287x_usb.h" />
@@ -134,13 +161,22 @@
     <ClInclude Include="..\tda20142.h" />
     <ClInclude Include="..\tsbuff.h" />
     <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
     <ClInclude Include="..\types_u.h" />
     <ClInclude Include="..\usbdevfile.h" />
     <ClInclude Include="..\usbops.h" />
-    <ClInclude Include="BonTuner.h" />
+    <ClInclude Include="BonTuner_uSUNpTV.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="..\HRTimer.h" />
     <ClInclude Include="stdafx.h" />
   </ItemGroup>
   <ItemGroup>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="..\em287x.c">
       <PrecompiledHeader>NotUsing</PrecompiledHeader>
     </ClCompile>
@@ -161,12 +197,18 @@
       <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
     <ClCompile Include="..\usbops.c" />
-    <ClCompile Include="BonTuner.cpp">
+    <ClCompile Include="BonTuner_uSUNpTV.cpp">
       <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
     <ClCompile Include="dllmain.cpp">
       <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\HRTimer.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="stdafx.c">
       <PrecompiledHeader>Create</PrecompiledHeader>
     </ClCompile>
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj.filters BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj.filters
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj.filters	2016-02-02 02:27:14.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj.filters	2019-12-31 18:11:54.000000000 +0900
@@ -21,9 +21,6 @@
     <ClInclude Include="..\targetver.h">
       <Filter>ヘッダー ファイル</Filter>
     </ClInclude>
-    <ClInclude Include="BonTuner.h">
-      <Filter>ヘッダー ファイル</Filter>
-    </ClInclude>
     <ClInclude Include="..\tsthread.h">
       <Filter>ヘッダー ファイル</Filter>
     </ClInclude>
@@ -63,11 +60,20 @@
     <ClInclude Include="..\mxl136.h">
       <Filter>ヘッダー ファイル</Filter>
     </ClInclude>
+    <ClInclude Include="..\twindbg.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="BonTuner_uSUNpTV.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\pryutil.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\bonhybrid.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
-    <ClCompile Include="BonTuner.cpp">
-      <Filter>ソース ファイル</Filter>
-    </ClCompile>
     <ClCompile Include="..\tsthread.c">
       <Filter>ソース ファイル</Filter>
     </ClCompile>
@@ -107,6 +113,15 @@
     <ClCompile Include="..\mxl136.c">
       <Filter>ソース ファイル</Filter>
     </ClCompile>
+    <ClCompile Include="BonTuner_uSUNpTV.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="BonDriver.rc">
BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTVȯ: BonDriver_uSUNpTV.vcxproj.user
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj	2022-05-02 21:56:28.000000000 +0900
@@ -0,0 +1,238 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{264FED43-93BD-4D55-B545-DD16668B7BB7}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>uSUNpTV</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+    <ProjectName>BonDriver_uSUNpTV_isoch</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
+    <UseDebugLibraries>true</UseDebugLibraries>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'" Label="Configuration">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <EmbedManifest>false</EmbedManifest>
+    <IncludePath>..\inc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='Win32'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="..\bonhybrid.h" />
+    <ClInclude Include="..\em287x.h" />
+    <ClInclude Include="..\em287x_priv.h" />
+    <ClInclude Include="..\em287x_usb.h" />
+    <ClInclude Include="..\message.h" />
+    <ClInclude Include="..\mxl136.h" />
+    <ClInclude Include="..\targetver.h" />
+    <ClInclude Include="..\osdepend.h" />
+    <ClInclude Include="..\tc90522.h" />
+    <ClInclude Include="..\tda20142.h" />
+    <ClInclude Include="..\tsbuff.h" />
+    <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
+    <ClInclude Include="..\types_u.h" />
+    <ClInclude Include="..\usbdevfile.h" />
+    <ClInclude Include="..\usbops.h" />
+    <ClInclude Include="BonTuner_uSUNpTV.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="..\HRTimer.h" />
+    <ClInclude Include="stdafx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\em287x.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\em287x_usb.c" />
+    <ClCompile Include="..\message.c" />
+    <ClCompile Include="..\mxl136.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c" />
+    <ClCompile Include="..\tc90522.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tda20142.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tsthread.c" />
+    <ClCompile Include="..\usbdevfile.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\usbops.c" />
+    <ClCompile Include="BonTuner_uSUNpTV.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="dllmain.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\HRTimer.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="stdafx.c">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="stdafx2.cpp">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj.filters BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj.filters
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj.filters	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj.filters	2019-12-31 18:11:54.000000000 +0900
@@ -0,0 +1,131 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="ソース ファイル">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="ヘッダー ファイル">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="リソース ファイル">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="stdafx.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\targetver.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\tsthread.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\types_u.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\usbdevfile.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\usbops.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\message.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\osdepend.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\tsbuff.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\em287x_priv.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\em287x_usb.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\em287x.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\tc90522.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\tda20142.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\mxl136.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\twindbg.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="BonTuner_uSUNpTV.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\pryutil.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\bonhybrid.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\tsthread.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\usbops.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\usbdevfile.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="stdafx2.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="stdafx.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\message.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="dllmain.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\em287x.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\em287x_usb.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\tc90522.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\tda20142.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\mxl136.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="BonTuner_uSUNpTV.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc">
+      <Filter>リソース ファイル</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.cpp BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.cpp	2016-02-10 06:01:58.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.cpp	2022-05-03 03:20:17.000000000 +0900
@@ -3,10 +3,10 @@
   BonTuner.cpp
   2016-02-10
 */
-
 #include "stdafx.h"
+
 #include <tchar.h>
-#include "BonTuner.h"
+#include "BonTuner_uSUNpTV.h"
 #include "../usbdevfile.h"
 extern "C" {
 #include "../tc90522.h"
@@ -14,37 +14,49 @@
 #include "../mxl136.h"
 }
 
-#pragma warning( disable : 4273 )
-extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
-{ return (CBonTuner::m_pThis)? CBonTuner::m_pThis : ((IBonDriver *) new CBonTuner); }
-#pragma warning( default : 4273 )
-
-//# initialize static member variables
-CBonTuner * CBonTuner::m_pThis = NULL;
-HINSTANCE CBonTuner::m_hModule = NULL;
+using namespace std ;
+
+namespace uSUNpTV {
+
+DWORD USUNPTV_SETSFREQ_TIMES  = 1     ;
+DWORD USUNPTV_SETSTSID_TIMES  = 2     ;
+DWORD USUNPTV_SETTFREQ_TIMES  = 1     ;
+DWORD USUNPTV_SETSLOCK_WAIT   = 10    ;
+DWORD USUNPTV_SETSTSID_WAIT   = 800   ;
+DWORD USUNPTV_CHANNEL_WAIT    = 800   ;
+BOOL  USUNPTV_LOCK_ON_SIGNAL  = TRUE  ;
+BOOL  USUNPTV_FASTSCAN        = FALSE ;
 
 const TCHAR* const g_RegKey = TEXT("Software\\trinity19683\\FSUSB2i");
 
 CBonTuner::CBonTuner()
-: m_dwCurSpace(123), m_dwCurChannel(0), m_hDev(NULL), m_hUsbDev(NULL), pDev(NULL), demodDev(NULL), m_selectedTuner(-1), tsthr(NULL),
- m_ChannelList(NULL)
+: CBonFSHybrid(true), m_dwCurSpace(123), m_dwCurChannel(0), m_hasStream(FALSE),
+ m_hDev(NULL), m_hUsbDev(NULL),pDev(NULL), demodDev(NULL), m_selectedTuner(-1),
+ m_chCur()
 {
-	int i;
-	m_pThis = this;
-	for(i = 0; i < 2; i++ ) {
-		tunerDev[i] = NULL;
-	}
+	fill_n(tunerDev, 2, (void*)NULL);
 }
 
 CBonTuner::~CBonTuner()
 {
 	CloseTuner();
+}
 
-	if(m_ChannelList != NULL) ::GlobalFree(m_ChannelList);
-	m_pThis = NULL;
+const TCHAR *CBonTuner::RegName()
+{
+	return g_RegKey ;
 }
 
-const BOOL CBonTuner::OpenTuner()
+int CBonTuner::UserDecidedDeviceIdx()
+{
+	int idx=0 ;
+	if(sscanf_s( upper_case(file_prefix_of(ModuleFileName())).c_str() , "BONDRIVER_USUNPTV_DEV%d", &idx )==1)
+	  return idx ;
+
+	return -1 ;
+}
+
+const BOOL CBonTuner::TryOpenTuner()
 {
 	//# if already open, close tuner
 	CloseTuner();
@@ -52,71 +64,45 @@
 
 	try{
 		//# AllocTuner
-		for(unsigned int idx = 0; idx < 40;) {
-			HANDLE hDev;
-			if((hDev = usbdevfile_alloc(&idx) ) == NULL) {   //# not found
-				throw (const DWORD)__LINE__;
-			}
-			//# found
-			m_hDev = hDev;
-			if((hDev = usbdevfile_init(m_hDev) ) == NULL) {   //# failed
-				throw (const DWORD)__LINE__;
-			}
-			m_hUsbDev = hDev;
-			break;
+		if(!FindDevice(GUID_WINUSB_US3POUT_DRV,m_hDev,m_hUsbDev)) {
+		  if(m_hDev==NULL) throw (const DWORD)__LINE__;
+		  if(m_hUsbDev==NULL) throw (const DWORD)__LINE__;
 		}
 		//# device initialize
 		m_USBEP.fd = m_hUsbDev;
-		if( em287x_create(&pDev, &m_USBEP) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( em287x_create(&pDev, &m_USBEP) ) throw (const DWORD)__LINE__;
 		struct i2c_device_st* pI2C;
 		//# demod
-		if( tc90522_create(&demodDev) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( tc90522_create(&demodDev) ) throw (const DWORD)__LINE__;
 		pI2C = (struct i2c_device_st*)tc90522_i2c_ptr(demodDev);
 		pI2C->addr = 0x20;
 		em287x_attach(pDev, pI2C);
-		if( tc90522_init(demodDev) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( tc90522_init(demodDev) ) throw (const DWORD)__LINE__;
 		//# tuner 0 terra
-		if( mxl136_create(&tunerDev[0]) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( mxl136_create(&tunerDev[0]) ) throw (const DWORD)__LINE__;
 		pI2C = (struct i2c_device_st*)mxl136_i2c_ptr(tunerDev[0]);
 		pI2C->addr = 0xc0;
 		tc90522_attach(demodDev, 0, pI2C);
-		if( mxl136_init(tunerDev[0]) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( mxl136_init(tunerDev[0]) ) throw (const DWORD)__LINE__;
 		//# tuner 1 BS/CS
-		if( tda20142_create(&tunerDev[1]) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( tda20142_create(&tunerDev[1]) ) throw (const DWORD)__LINE__;
 		pI2C = (struct i2c_device_st*)tda20142_i2c_ptr(tunerDev[1]);
 		pI2C->addr = 0xa8;
 		tc90522_attach(demodDev, 1, pI2C);
-		if( tda20142_init(tunerDev[1]) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( tda20142_init(tunerDev[1]) ) throw (const DWORD)__LINE__;
 		//# demod set params
-		if( tc90522_selectDevice(demodDev, 1) ) {
-			throw (const DWORD)__LINE__;
-		}
-		//# TS receive thread
-		if( tsthread_create(&tsthr, &m_USBEP) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( tc90522_selectDevice(demodDev, 1) ) throw (const DWORD)__LINE__;
+		//# fifo
+		if(!FifoInitialize(&m_USBEP)) throw (const DWORD)__LINE__;
 
 		//# device has been ready.
-		LoadData();
+
+		DBGOUT("-*- device has been ready -*-\n") ;
 	}
 	catch (const DWORD dwErrorStep) {
 		//# Error
 		warn_msg(0,"BonDriver_uSUNpTV:OpenTuner dwErrorStep = %u", dwErrorStep);
-
+		DBGOUT("BonDriver_uSUNpTV::OpenTuner(Line: %u): failed.\n", dwErrorStep);
 		CloseTuner();
 		return FALSE;
 	}
@@ -125,11 +111,7 @@
 
 void CBonTuner::CloseTuner()
 {
-	if(tsthr) {
-		tsthread_stop(tsthr);
-		tsthread_destroy(tsthr);
-		tsthr = NULL;
-	}
+	FifoFinalize() ;
 	if(tunerDev[0]) {
 		mxl136_destroy(tunerDev[0]);
 		tunerDev[0] = NULL;
@@ -146,153 +128,60 @@
 		em287x_destroy(pDev);
 		pDev = NULL;
 	}
-	if(m_hUsbDev) {
-		usbdevfile_free(m_hUsbDev);
-		m_hUsbDev = NULL;
-	}
-	if(m_hDev) {
-		::CloseHandle( m_hDev );
-		m_hDev = NULL;
-	}
-}
-
-const BOOL CBonTuner::SetChannel(const BYTE bCh)
-{
-	//# compatible with IBonDriver
-	if(bCh < 13 || bCh > 52) return FALSE;
-	else return SetChannel(0, bCh - 13);
+	FreeDevice(m_hDev,m_hUsbDev);
+	m_USBEP.dev=NULL;
+	m_chCur = CHANNEL();
+	m_selectedTuner = -1 ;
 }
 
 const float CBonTuner::GetSignalLevel(void)
 {
 	if(0 > m_selectedTuner || (! demodDev) ) return -3.1f;
+	if(!m_hasStream) return 0.f ;
 	unsigned statData[4];
-	if(tc90522_readStatistic(demodDev, m_selectedTuner, statData) ) return -3.2f;
-	return statData[1] * 0.01f;
-}
+	float lv ;
 
-const DWORD CBonTuner::WaitTsStream(const DWORD dwTimeOut)
-{
-	const int remainTime = (dwTimeOut < 0x10000000) ? dwTimeOut : 0x10000000;
-	if(! tsthr) return WAIT_FAILED;
+	const bool do_locking = USUNPTV_LOCK_ON_SIGNAL && m_USBEP.dev && m_USBEP.lockunlockFunc ;
 
-	const int r = tsthread_wait(tsthr, remainTime);
-	if(0 > r)  return WAIT_FAILED;
-	else if(0 < r)  return WAIT_OBJECT_0;
-	else  return WAIT_TIMEOUT;
-}
+	if(do_locking) //# lock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,1);
 
-const DWORD CBonTuner::GetReadyCount()
-{//# number of call GetTsStream()
-	if(! tsthr) return 0;
-	const int ret = tsthread_readable(tsthr);
-	return (ret > 0) ? 1 : 0;
-}
+	if(tc90522_readStatistic(demodDev, m_selectedTuner, statData) )
+		lv = -3.2f;
+	else
+		lv = statData[1] * 0.01f;
 
-const BOOL CBonTuner::GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	BYTE *pSrc = NULL;
-	if(GetTsStream(&pSrc, pdwSize, pdwRemain)){
-		if(*pdwSize) ::CopyMemory(pDst, pSrc, *pdwSize);
-		return TRUE;
-	}
-	return FALSE;
-}
+	if(do_locking) //# unlock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,0);
 
-const BOOL CBonTuner::GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	if(! tsthr) return FALSE;
-	const int ret = tsthread_readable(tsthr);
-	if(ret <= 0) {
-		//# no readable data
-		*pdwSize = 0;
-		*pdwRemain = 0;
-		return TRUE;
-	}
-	*pdwSize = tsthread_read(tsthr, (void**)ppDst);
-	*pdwRemain = GetReadyCount();
-	//dmsg("GetTsStream(%p,%u,%u)", ppDst, *pdwSize, *pdwRemain);
-	return TRUE;
-}
-
-void CBonTuner::PurgeTsStream()
-{
-	if(! tsthr) return;
-	//# purge available data in TS buffer
-	tsthread_read(tsthr, NULL);
+	return lv ;
 }
 
 void CBonTuner::Release()  //# release the instance
 { delete this; }
 
 LPCTSTR CBonTuner::GetTunerName(void)
-{ return TEXT("U"); }
+{ return TEXT("uSUNpTV"); }
 
 const BOOL CBonTuner::IsTunerOpening(void)
 { return m_hUsbDev ? TRUE : FALSE; }
 
-LPCTSTR CBonTuner::EnumTuningSpace(const DWORD dwSpace)
-{
-	if(0 == dwSpace)  return TEXT("nfW");
-	else if(1 == dwSpace)  return TEXT("BS");
-	else if(2 == dwSpace)  return TEXT("CS");
-	return NULL;
-}
-
-LPCTSTR CBonTuner::EnumChannelName(const DWORD dwSpace, const DWORD dwChannel)
-{
-	static TCHAR buf[6];
-	if(0 == dwSpace) {
-		if(m_ChannelList != NULL) {
-			//# User-defined channels
-			const DWORD dwChannelLen    = m_ChannelList[0] >> 16;
-			const DWORD dwNumOfChannels = m_ChannelList[0] & 0xFFFF;
-			TCHAR* const ptrStr = (TCHAR*)(m_ChannelList + dwNumOfChannels + 1);
-			if(dwChannel < dwNumOfChannels)	return ptrStr + (dwChannelLen * dwChannel);
-		}else if(dwChannel < 40) {
-			_sntprintf_s(buf, sizeof(buf)/sizeof(TCHAR), _TRUNCATE, TEXT("%u"), dwChannel + 13);
-			return buf;    //# The caller must copy data from this buffer.
-		}
-	}else if(1 == dwSpace && dwChannel < 12 * 8) {
-		_sntprintf_s(buf, sizeof(buf)/sizeof(TCHAR), _TRUNCATE, TEXT("%02u.%u"), (dwChannel >> 3)*2 + 1, dwChannel & 0x7);
-		return buf;
-	}else if(2 == dwSpace && dwChannel < 12 * 8) {
-		_sntprintf_s(buf, sizeof(buf)/sizeof(TCHAR), _TRUNCATE, TEXT("%02u.%u"), (dwChannel >> 3)*2 + 2, dwChannel & 0x7);
-		return buf;
-	}
-	return NULL;
-}
-
-const BOOL CBonTuner::SetChannel(const DWORD dwSpace, const DWORD dwChannel)
+BOOL CBonTuner::select_ch(const CHANNEL &ch, BOOL doSetFreq, BOOL doSetTSID)
 {
-	DWORD dwFreq = 0;
+	BOOL hasStream = TRUE ;
 	int tunerNum = 0;
-	bool hasStream = TRUE;
 
-	if(0 == dwSpace) {
-		if(m_ChannelList != NULL) {  //# User-defined channels
-			const DWORD dwNumOfChannels = m_ChannelList[0] & 0xFFFF;
-			if(dwChannel < dwNumOfChannels)
-				dwFreq = m_ChannelList[dwChannel + 1];
-		}else{  //# UHF standard channels
-			if(dwChannel < 40)
-				dwFreq = dwChannel * 6000 + 473143;
-		}
-	}else if(1 == dwSpace && dwChannel < 12 * 8) {
-		dwFreq = (dwChannel >> 3) * 38360 + 1049480;
-	}else if(2 == dwSpace && dwChannel < 12 * 8) {
-		dwFreq = (dwChannel >> 3) * 40000 + 1613000;
-	}else if(dwSpace == 114514) {  //# dwChannel as freq/kHz
-		dwFreq = dwChannel;
+	if(ch.Band==BAND_na) {
+		warn_msg(0,"BonDriver_uSUNpTV:doSetChannel(BAND=na) invalid!");
+		return FALSE;
 	}
-	if(dwFreq < 60000 || dwFreq > 2456123 ) {
-		warn_msg(0,"BonDriver_uSUNpTV:SetChannel(%u,%u) invalid!", dwSpace, dwChannel);
+
+	if(ch.Freq < 60000 || ch.Freq > 2456123 ) {
+		warn_msg(0,"BonDriver_uSUNpTV:doSetChannel(Freq=%d) invalid!", ch.Freq);
 		return FALSE;
 	}
-	if( dwFreq >= 900000 ) tunerNum = 1;
+	if( ch.Freq >= 900000 ) tunerNum = 1;
 
-	//# change channel
-	if(tsthr) tsthread_stop(tsthr);
 
 	if(tunerNum != m_selectedTuner) {
 		if( tc90522_selectDevice(demodDev, tunerNum) ) return FALSE;
@@ -300,49 +189,94 @@
 			mxl136_sleep(tunerDev[0]);
 		}else{
 			mxl136_wakeup(tunerDev[0]);
+			HRSleep( 30 );
 		}
+		m_selectedTuner = tunerNum;
 	}
 	if(tunerNum & 0x1) {
-		if( m_selectedTuner != tunerNum || (m_dwCurChannel ^ dwChannel) >> 3 ) {
-			if( tda20142_setFreq(tunerDev[1], dwFreq) ) return FALSE;
-			::Sleep( 30 );
-			if( tc90522_resetDemod(demodDev, tunerNum ) ) return FALSE;
-			::Sleep( 50 );
+		if(doSetFreq) {
+			for(DWORD n=USUNPTV_SETSFREQ_TIMES;n;n--)
+			if( m_chCur.Band!=ch.Band || m_chCur.Freq != ch.Freq ) {
+				unsigned fail=0 ;
+				if( tda20142_setFreq(tunerDev[1], ch.Freq) ) fail++ ;
+				HRSleep( 30 );
+				if( !fail && tc90522_resetDemod(demodDev, tunerNum ) ) fail++ ;
+				if(n>1) HRSleep( 50 );
+				if(fail&&n==1) return FALSE;
+			}
+		}
+		if(doSetTSID) for(DWORD n=USUNPTV_SETSTSID_TIMES;n;n--) {
+			hasStream = FALSE;
+			unsigned fail=0, lock=0 ;
+			for(DWORD e=0,s=Elapsed();USUNPTV_SETSTSID_WAIT>e;e=Elapsed(s)) {
+				int ret ;
+				if(!lock) {
+					unsigned data[2] ;
+					ret =tc90522_readStatistic(demodDev, tunerNum, data);
+					if(0 == ret) {
+						lock = data[0]&0x10 ;  //# check lock bit
+						if(lock) HRSleep(USUNPTV_SETSLOCK_WAIT) ;
+					}
+				}else {
+					if(ch.TSID>0)
+						ret = tc90522_setTSID(demodDev, tunerNum, ch.TSID );
+					else
+						ret = tc90522_selectStream(demodDev, tunerNum, ch.Stream );
+					if(0 == ret) { hasStream = TRUE; break; }
+					else if(0 > ret) fail++ ;
+				}
+				HRSleep( 40 );
+			}
+			if(n>1&&hasStream)
+				HRSleep( 40 );
+			if(fail&&n==1) return FALSE;
+		}
+	}else if(doSetFreq) for(DWORD n=USUNPTV_SETTFREQ_TIMES;n;n--) {
+		unsigned fail=0 ;
+		if( mxl136_setFreq(tunerDev[0], ch.Freq) ) fail++ ;
+		HRSleep( 30 );
+		if( !fail && tc90522_resetDemod(demodDev, tunerNum ) ) fail++ ;
+		HRSleep( 50 );
+		if(fail&&n==1) return FALSE;
+	}
+
+	if(hasStream && doSetTSID) {
+		hasStream=FALSE;
+		for(DWORD e=0,s=Elapsed();USUNPTV_CHANNEL_WAIT>e;e=Elapsed(s)) {
+			unsigned statData[4];
+			HRSleep( 40 );
+			if( tc90522_readStatistic(demodDev, tunerNum, statData) ) continue;
+			if( statData[0] & 0x10 ) { hasStream=TRUE; break; }
 		}
-		DWORD dwTime = ::GetTickCount() + 800;
-		hasStream = FALSE;
-		do {
-			int ret = tc90522_selectStream(demodDev, tunerNum, dwChannel & 0x7 );
-			if(0 == ret) {
-				hasStream = TRUE;
-				break;
-			}else if(0 > ret)  return FALSE;
-			::Sleep( 40 );
-		} while( (int)(dwTime - ::GetTickCount()) > 0);
-	}else{
-		if( mxl136_setFreq(tunerDev[0], dwFreq) ) return FALSE;
-		::Sleep( 30 );
-		if( tc90522_resetDemod(demodDev, tunerNum ) ) return FALSE;
-		::Sleep( 50 );
 	}
+
+	return hasStream ;
+}
+
+
+const BOOL CBonTuner::SetChannel(const DWORD dwSpace, const DWORD dwChannel)
+{
+	BOOL hasStream = TRUE;
+
+	CHANNEL ch = GetChannel(dwSpace,dwChannel) ;
+
+	//# change channel
+	m_hasStream=FALSE ;
+	FifoStop() ;
+
+	hasStream = select_ch(ch) ;
+
 	//# set variables
 	m_dwCurSpace = dwSpace;
 	m_dwCurChannel = dwChannel;
-	m_selectedTuner = tunerNum;
-
-	if(tsthr && hasStream) tsthread_start(tsthr);
+	m_chCur = ch ;
+	m_hasStream = hasStream ;
 
-	DWORD dwTime = ::GetTickCount() + 480;
-	do {
-		unsigned statData[4];
-		::Sleep( 40 );
-		if( tc90522_readStatistic(demodDev, tunerNum, statData) ) continue;
-		if( statData[0] & 0x10 ) break;
-	} while( (int)(dwTime - ::GetTickCount()) > 0);
+	if(hasStream) FifoStart() ;
 
 	PurgeTsStream();
 
-	return TRUE;
+	return USUNPTV_FASTSCAN ? hasStream : TRUE;
 }
 
 const DWORD CBonTuner::GetCurSpace(void)
@@ -351,63 +285,116 @@
 const DWORD CBonTuner::GetCurChannel(void)
 { return m_dwCurChannel; }
 
+void CBonTuner::LoadValues(const IValueLoader *Loader)
+{
+	CBonFSHybrid::LoadValues (Loader) ;
+	#define LOADDW(val) do { val = Loader->ReadDWORD(L#val,val); } while(0)
+	LOADDW(USUNPTV_SETSFREQ_TIMES);
+	LOADDW(USUNPTV_SETSTSID_TIMES);
+	LOADDW(USUNPTV_SETTFREQ_TIMES);
+	LOADDW(USUNPTV_SETSLOCK_WAIT);
+	LOADDW(USUNPTV_SETSTSID_WAIT);
+	LOADDW(USUNPTV_CHANNEL_WAIT);
+    LOADDW(USUNPTV_LOCK_ON_SIGNAL);
+	LOADDW(USUNPTV_FASTSCAN);
+	#undef LOADDW
+}
+
+  // IBonTransponder
 
-bool CBonTuner::LoadData ()
+const BOOL CBonTuner::TransponderSelect(const DWORD dwSpace, const DWORD dwTransponder)
 {
-	HKEY hKey;
+  if(!IsTunerOpening()) return FALSE;
 
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, g_RegKey, 0, KEY_READ, &hKey)) {
-		//ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, g_RegKey, 0, KEY_READ, &hKey)) {
-		//ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
+  int idx = transponder_index_of(dwSpace, dwTransponder) ;
+  if(idx<0) return FALSE ;
+
+  BOOL res = select_ch(m_Transponders[idx], TRUE, FALSE) ;
 
-	return true;
+  if(res) {
+    m_dwCurSpace = dwSpace;
+    m_dwCurChannel = dwTransponder | TRANSPONDER_CHMASK ;
+    m_chCur = m_Transponders[idx] ;
+    m_hasStream = FALSE; // TransponderSetCurID ͂܂sĂȂ̂
+  }
+
+  return res ;
 }
 
-void CBonTuner::ReadRegMode (HKEY hPKey)
-{ return; }
+const BOOL CBonTuner::TransponderGetIDList(LPDWORD lpIDList, LPDWORD lpdwNumID)
+{
+  if(!IsTunerOpening()) return FALSE;
+  if(m_chCur.Band!=BAND_BS&&m_chCur.Band!=BAND_ND) return FALSE;
+
+  const DWORD numId = 8 ;
+
+  if(lpdwNumID==NULL) {
+    return FALSE ;
+  }else if(lpIDList==NULL) {
+    *lpdwNumID = numId ;
+    return TRUE ;
+  }
+
+  uint8_t tmcc[44] ;
+  if(tc90522_readTMCC(demodDev, 1, tmcc)) return FALSE;
+
+  DWORD num = min(8,*lpdwNumID) ;
+  uint8_t *p = tmcc + 28 ;
+  for(DWORD i=0;i<num;i++) {
+    DWORD id = *p++ ; id<<=8 ; id |= *p++ ;
+	if(id==0||id==0xffff) id = 0xFFFFFFFF ;
+	lpIDList[i] = id ;
+  }
+  *lpdwNumID = num ;
 
-void CBonTuner::ReadRegChannels (HKEY hPKey)
+  return TRUE ;
+}
+
+const BOOL CBonTuner::TransponderSetCurID(const DWORD dwID)
 {
-	if(m_ChannelList != NULL) return;
+  if(!IsTunerOpening()) return FALSE;
+  if(m_chCur.Band!=BAND_BS&&m_chCur.Band!=BAND_ND) return FALSE;
 
-	HKEY hKey;
-	DWORD NumOfValues;
-	TCHAR szValueName[32];
-	DWORD dwValue, dwLen, dwType, dwByte, dwMaxValueName;
-	if(ERROR_SUCCESS != RegOpenKeyEx( hPKey, TEXT("Channels"), 0, KEY_READ, &hKey)) {
-		return;
-	}
-	if(ERROR_SUCCESS != RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumOfValues, &dwMaxValueName, NULL, NULL, NULL)) {
-		RegCloseKey(hKey);
-		return;
-	}
-	dwMaxValueName++;
-	m_ChannelList = (DWORD*) ::GlobalAlloc(GMEM_FIXED, NumOfValues * (dwMaxValueName * sizeof(TCHAR) + sizeof(DWORD)) + sizeof(DWORD) );
-	m_ChannelList[0] = dwMaxValueName << 16 | NumOfValues;
-	ZeroMemory( m_ChannelList + 1, sizeof(DWORD) * NumOfValues );
-	TCHAR *ptrStr;
-	for(DWORD dwIdx = 0; dwIdx < NumOfValues; dwIdx++ ) {
-		dwLen = 32;
-		dwByte = sizeof(dwValue);
-		if(ERROR_SUCCESS != RegEnumValue( hKey, dwIdx, szValueName, &dwLen, NULL, &dwType, (BYTE*)&dwValue, &dwByte)
-			|| dwByte != sizeof(DWORD)) {
-			break;
-		}
-		dwByte = dwValue >> 24; //# Index
-		if( dwByte >= NumOfValues ) continue;
-		m_ChannelList[dwByte + 1] = dwValue & 0x00ffffff;
-		ptrStr = (TCHAR*)(m_ChannelList + NumOfValues + 1);
-		ptrStr += dwMaxValueName * dwByte;
-		lstrcpyn( ptrStr, szValueName, dwMaxValueName );
-	}
-	RegCloseKey(hKey);
+  //# change channel
+  m_hasStream=FALSE ;
+  FifoStop() ;
+
+  CHANNEL ch = m_chCur ;
+  ch.TSID = (WORD) (dwID&0xFFFF) ;
+  BOOL res = select_ch(ch, FALSE, TRUE) ;
+
+  if(res) {
+    m_chCur = ch ;
+    m_hasStream = TRUE ;
+    FifoStart() ;
+  }
+
+  PurgeTsStream();
+
+  return res ;
+}
+
+const BOOL CBonTuner::TransponderGetCurID(LPDWORD lpdwID)
+{
+  if(!IsTunerOpening()) return FALSE;
+  if(m_chCur.Band!=BAND_BS&&m_chCur.Band!=BAND_ND) return FALSE;
+
+  if(!m_hasStream) {
+    *lpdwID=0xFFFFFFFF;
+    return TRUE;
+  }
+
+  uint8_t tmcc[44] ;
+  if(tc90522_readTMCC(demodDev, 1, tmcc)) return FALSE;
+
+  uint8_t *p = tmcc + 2 ;
+  DWORD id = *p++ ; id<<=8 ; id |= *p++ ;
+  if(id==0||id==0xffff) id = 0xFFFFFFFF ;
+  *lpdwID = id ;
+
+  return TRUE;
 }
 
-/*EOF*/
\ ե˲Ԥޤ
+} // End of namespace uSUNpTV
+
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.h BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.h	2016-01-23 15:23:50.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.h	2022-05-03 03:07:54.000000000 +0900
@@ -9,51 +9,54 @@
 extern "C" {
 #include "../em287x.h"
 #include "../tsthread.h"
+#include "../tsbuff.h"
 }
 
-class CBonTuner : public IBonDriver2
+#include "../bonhybrid.h"
+
+namespace uSUNpTV {
+
+class CBonTuner : public CBonFSHybrid
 {
+protected:
+	const TCHAR *RegName() ;
+	int UserDecidedDeviceIdx() ;
+	virtual void LoadValues(const IValueLoader *Loader);
+	const BOOL TryOpenTuner(void);
+
 public:
 	CBonTuner();
 	virtual ~CBonTuner();
 
 //# IBonDriver
-	const BOOL OpenTuner(void);
 	void CloseTuner(void);
 
-	const BOOL SetChannel(const BYTE bCh);
 	const float GetSignalLevel(void);
 
-	const DWORD WaitTsStream(const DWORD dwTimeOut = 0);
-	const DWORD GetReadyCount(void);
-
-	const BOOL GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain);
-	const BOOL GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain);
-
-	void PurgeTsStream(void);
-
 //# IBonDriver2
 	LPCTSTR GetTunerName(void);
 
 	const BOOL IsTunerOpening(void);
-	
-	LPCTSTR EnumTuningSpace(const DWORD dwSpace);
-	LPCTSTR EnumChannelName(const DWORD dwSpace, const DWORD dwChannel);
 
 	const BOOL SetChannel(const DWORD dwSpace, const DWORD dwChannel);
-	
+
 	const DWORD GetCurSpace(void);
 	const DWORD GetCurChannel(void);
 
 	void Release(void);
 
-	static CBonTuner * m_pThis;
-	static HINSTANCE m_hModule;
+// IBonTransponder
+	const BOOL TransponderSelect(const DWORD dwSpace, const DWORD dwTransponder);
+	const BOOL TransponderGetIDList(LPDWORD lpIDList, LPDWORD lpdwNumID);
+	const BOOL TransponderSetCurID(const DWORD dwID);
+	const BOOL TransponderGetCurID(LPDWORD lpdwID);
 
 protected:
 	DWORD m_dwCurSpace;
 	DWORD m_dwCurChannel;
-	DWORD *m_ChannelList;
+    BOOL m_hasStream;
+	CHANNEL m_chCur ;
+	BOOL select_ch(const CHANNEL &ch, BOOL doSetFreq=TRUE, BOOL doSetTSID=TRUE) ;
 
 	HANDLE m_hDev;
 	HANDLE m_hUsbDev;
@@ -62,9 +65,8 @@
 	void* demodDev;
 	void* tunerDev[2];
 	int m_selectedTuner;
-	tsthread_ptr tsthr;
 
-	bool LoadData ();
-	void ReadRegMode (HKEY hPKey);
-	void ReadRegChannels (HKEY hPKey);
 };
+
+} // End of namespace uSUNpTV
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/dllmain.cpp BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/dllmain.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/dllmain.cpp	2015-12-09 05:06:04.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/dllmain.cpp	2020-01-07 03:20:04.000000000 +0900
@@ -1,5 +1,7 @@
 #include "stdafx.h"
-#include "BonTuner.h"
+#include "BonTuner_uSUNpTV.h"
+
+using namespace uSUNpTV;
 
 BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )
 {
@@ -13,3 +15,9 @@
 	}
 	return TRUE;
 }
+
+#pragma warning( disable : 4273 )
+extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
+{return BonFSCreate<CBonTuner>();}
+#pragma warning( default : 4273 )
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/stdafx.h BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/stdafx.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/stdafx.h	2015-12-30 16:04:20.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/BonDriver_uSUNpTV/stdafx.h	2022-05-02 22:17:21.000000000 +0900
@@ -4,3 +4,7 @@
 #include <windows.h>
 
 #include "../message.h"
+
+#include "../twindbg.h"
+
+#include "../HRTimer.h"
diff -uPr BonD_FSHybrid-20201009_org/src/FSHybrid.sln BonD_FSHybrid-20201009_mod10.1/src/FSHybrid.sln
--- BonD_FSHybrid-20201009_org/src/FSHybrid.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/FSHybrid.sln	2019-12-20 14:56:02.000000000 +0900
@@ -0,0 +1,28 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.24720.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSHybrid", "BonDriver_FSHybrid\BonDriver_FSHybrid.vcxproj", "{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x64.ActiveCfg = Debug|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x64.Build.0 = Debug|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x86.ActiveCfg = Debug|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x86.Build.0 = Debug|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x64.ActiveCfg = Release|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x64.Build.0 = Release|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x86.ActiveCfg = Release|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSHybrid_VS2008.sln BonD_FSHybrid-20201009_mod10.1/src/FSHybrid_VS2008.sln
--- BonD_FSHybrid-20201009_org/src/FSHybrid_VS2008.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/FSHybrid_VS2008.sln	2019-12-20 14:50:42.000000000 +0900
@@ -0,0 +1,26 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSHybrid", "BonDriver_FSHybrid\BonDriver_FSHybrid.vcproj", "{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|Win32.Build.0 = Debug|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x64.ActiveCfg = Debug|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x64.Build.0 = Debug|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|Win32.ActiveCfg = Release|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|Win32.Build.0 = Release|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x64.ActiveCfg = Release|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSHybrid_isoch.sln BonD_FSHybrid-20201009_mod10.1/src/FSHybrid_isoch.sln
--- BonD_FSHybrid-20201009_org/src/FSHybrid_isoch.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/FSHybrid_isoch.sln	2020-10-03 19:38:34.000000000 +0900
@@ -0,0 +1,28 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.25420.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSHybrid_isoch", "BonDriver_FSHybrid\BonDriver_FSHybrid_isoch.vcxproj", "{58814608-686F-46B4-9061-B647F45A1151}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{58814608-686F-46B4-9061-B647F45A1151}.Debug|x64.ActiveCfg = Debug|x64
+		{58814608-686F-46B4-9061-B647F45A1151}.Debug|x64.Build.0 = Debug|x64
+		{58814608-686F-46B4-9061-B647F45A1151}.Debug|x86.ActiveCfg = Debug|Win32
+		{58814608-686F-46B4-9061-B647F45A1151}.Debug|x86.Build.0 = Debug|Win32
+		{58814608-686F-46B4-9061-B647F45A1151}.Release|x64.ActiveCfg = Release|x64
+		{58814608-686F-46B4-9061-B647F45A1151}.Release|x64.Build.0 = Release|x64
+		{58814608-686F-46B4-9061-B647F45A1151}.Release|x86.ActiveCfg = Release|Win32
+		{58814608-686F-46B4-9061-B647F45A1151}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSUSB2N.sln BonD_FSHybrid-20201009_mod10.1/src/FSUSB2N.sln
--- BonD_FSHybrid-20201009_org/src/FSUSB2N.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/FSUSB2N.sln	2019-12-16 05:04:18.000000000 +0900
@@ -0,0 +1,28 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.24720.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2N", "BonDriver_FSUSB2N\BonDriver_FSUSB2N.vcxproj", "{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x64.ActiveCfg = Debug|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x64.Build.0 = Debug|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x86.ActiveCfg = Debug|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x86.Build.0 = Debug|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x64.ActiveCfg = Release|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x64.Build.0 = Release|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x86.ActiveCfg = Release|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSUSB2N_VS2008.sln BonD_FSHybrid-20201009_mod10.1/src/FSUSB2N_VS2008.sln
--- BonD_FSHybrid-20201009_org/src/FSUSB2N_VS2008.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/FSUSB2N_VS2008.sln	2019-12-15 10:44:10.000000000 +0900
@@ -0,0 +1,26 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2N", "BonDriver_FSUSB2N\BonDriver_FSUSB2N.vcproj", "{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|Win32.ActiveCfg = Debug|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|Win32.Build.0 = Debug|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x64.ActiveCfg = Debug|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x64.Build.0 = Debug|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|Win32.ActiveCfg = Release|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|Win32.Build.0 = Release|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x64.ActiveCfg = Release|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSUSB2N_isoch.sln BonD_FSHybrid-20201009_mod10.1/src/FSUSB2N_isoch.sln
--- BonD_FSHybrid-20201009_org/src/FSUSB2N_isoch.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/FSUSB2N_isoch.sln	2020-10-06 07:00:56.000000000 +0900
@@ -0,0 +1,28 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.25420.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2N_isoch", "BonDriver_FSUSB2N\BonDriver_FSUSB2N_isoch.vcxproj", "{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Debug|x64.ActiveCfg = Debug|x64
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Debug|x64.Build.0 = Debug|x64
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Debug|x86.ActiveCfg = Debug|Win32
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Debug|x86.Build.0 = Debug|Win32
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Release|x64.ActiveCfg = Release|x64
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Release|x64.Build.0 = Release|x64
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Release|x86.ActiveCfg = Release|Win32
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSUSB2i.sln BonD_FSHybrid-20201009_mod10.1/src/FSUSB2i.sln
--- BonD_FSHybrid-20201009_org/src/FSUSB2i.sln	2015-12-20 04:16:10.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/FSUSB2i.sln	2019-12-16 05:10:14.000000000 +0900
@@ -1,24 +1,26 @@
 ﻿
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual C++ Express 2010
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2i", "BonDriver\BonDriver_FSUSB2i.vcxproj", "{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.24720.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2i", "BonDriver_FSUSB2i\BonDriver_FSUSB2i.vcxproj", "{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Win32 = Debug|Win32
 		Debug|x64 = Debug|x64
-		Release|Win32 = Release|Win32
+		Debug|x86 = Debug|x86
 		Release|x64 = Release|x64
+		Release|x86 = Release|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|Win32.ActiveCfg = Debug|Win32
-		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|Win32.Build.0 = Debug|Win32
 		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x64.ActiveCfg = Debug|x64
 		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x64.Build.0 = Debug|x64
-		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|Win32.ActiveCfg = Release|Win32
-		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|Win32.Build.0 = Release|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x86.ActiveCfg = Debug|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x86.Build.0 = Debug|Win32
 		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x64.ActiveCfg = Release|x64
 		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x64.Build.0 = Release|x64
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x86.ActiveCfg = Release|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x86.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff -uPr BonD_FSHybrid-20201009_org/src/FSUSB2i_VS2008.sln BonD_FSHybrid-20201009_mod10.1/src/FSUSB2i_VS2008.sln
--- BonD_FSHybrid-20201009_org/src/FSUSB2i_VS2008.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/FSUSB2i_VS2008.sln	2019-12-20 14:08:42.000000000 +0900
@@ -0,0 +1,26 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2i", "BonDriver_FSUSB2i\BonDriver_FSUSB2i.vcproj", "{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|Win32.ActiveCfg = Debug|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|Win32.Build.0 = Debug|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x64.ActiveCfg = Debug|x64
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x64.Build.0 = Debug|x64
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|Win32.ActiveCfg = Release|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|Win32.Build.0 = Release|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x64.ActiveCfg = Release|x64
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/HRTimer.cpp BonD_FSHybrid-20201009_mod10.1/src/HRTimer.cpp
--- BonD_FSHybrid-20201009_org/src/HRTimer.cpp	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/HRTimer.cpp	2022-05-02 22:25:25.000000000 +0900
@@ -0,0 +1,167 @@
+//===========================================================================
+#include "stdafx.h"
+#include <algorithm>
+
+#include "HRTimer.h"
+//---------------------------------------------------------------------------
+
+//===========================================================================
+namespace PRY8EAlByw {
+//---------------------------------------------------------------------------
+
+static BOOL s_bHighResolutionTimerMode = FALSE;
+
+static void doSleep(DWORD msec, DWORD usec)
+{
+  msec += usec/1000;
+  Sleep(msec>0?msec:1);
+}
+
+static DWORD doTimerSleep(HANDLE hTimer, const LARGE_INTEGER &time, HANDLE hObj=NULL)
+{
+	if(!SetWaitableTimer(hTimer, &time, 0, NULL, NULL, 0))
+		return hObj ? WAIT_FAILED : FALSE ;
+	if(hObj!=NULL) {
+		HANDLE handles[2] ;
+		handles[0] = hObj ;
+		handles[1] = hTimer ;
+		DWORD r = WaitForMultipleObjects(2,handles,FALSE,INFINITE);
+		return (r==WAIT_OBJECT_0+1) ? WAIT_TIMEOUT : r ;
+	}
+	return WaitForSingleObject(hTimer,INFINITE)==WAIT_OBJECT_0 ? TRUE : FALSE ;
+}
+
+static HANDLE makeTimer()
+{
+#if _WIN32_WINNT >= 0x0600
+#ifndef CREATE_WAITABLE_TIMER_HIGH_RESOLUTION
+#define CREATE_WAITABLE_TIMER_HIGH_RESOLUTION 0x00000002
+#endif
+	if(s_bHighResolutionTimerMode)  {
+		HANDLE hTimer = CreateWaitableTimerEx(NULL, NULL,
+					CREATE_WAITABLE_TIMER_HIGH_RESOLUTION, TIMER_ALL_ACCESS);
+		if(hTimer!=NULL) return hTimer ;
+	}
+#endif
+	return CreateWaitableTimer(NULL, FALSE, NULL);
+}
+
+//---------------------------------------------------------------------------
+
+void SetHRTimerMode(BOOL useHighResolution)
+{ s_bHighResolutionTimerMode = useHighResolution ; }
+
+//---------------------------------------------------------------------------
+
+void HRSleep(DWORD msec, DWORD usec)
+{
+	if(!s_bHighResolutionTimerMode&&!usec)
+	{ doSleep(msec,usec); return; }
+
+	HANDLE hTimer = makeTimer();
+
+	if(hTimer == NULL)
+	{ doSleep(msec,usec); return; }
+
+	LARGE_INTEGER time;
+	time.QuadPart = - (msec*1000LL + usec) * 10LL ;
+
+	if(!doTimerSleep(hTimer, time))
+		doSleep(msec,usec);
+
+	CloseHandle(hTimer);
+}
+
+//---------------------------------------------------------------------------
+
+DWORD HRWaitForSingleObject(HANDLE hObj, DWORD msec, DWORD usec)
+{
+	if(hObj == NULL) {
+		HRSleep(msec,usec);
+		return WAIT_TIMEOUT;
+	}
+
+	if(msec==INFINITE||(!msec&&!usec)||(!s_bHighResolutionTimerMode&&!usec))
+		return WaitForSingleObject(hObj,msec);
+
+	HANDLE hTimer = makeTimer();
+
+	if(hTimer == NULL)
+		return WaitForSingleObject(hObj, msec + usec/1000);
+
+	LARGE_INTEGER time;
+	time.QuadPart = - (msec*1000LL + usec) * 10LL ;
+
+	DWORD r = doTimerSleep(hTimer, time, hObj) ;
+
+	CloseHandle(hTimer);
+
+	return r ;
+}
+
+//---------------------------------------------------------------------------
+
+DWORD HRWaitForMultipleObjects(DWORD numObjs, const HANDLE *hObjs, BOOL waitAll,
+  DWORD msec, DWORD usec)
+{
+	if(waitAll||msec==INFINITE||(!msec&&!usec)||numObjs>=MAXIMUM_WAIT_OBJECTS) {
+		if(msec==INFINITE) usec=0;
+		return WaitForMultipleObjects(numObjs,hObjs,waitAll,msec+usec/1000);
+	}
+
+	HANDLE hTimer = makeTimer();
+
+	if(hTimer == NULL)
+		return WaitForMultipleObjects(numObjs,hObjs,FALSE,msec+usec/1000);
+
+	LARGE_INTEGER time;
+	time.QuadPart = - (msec*1000LL + usec) * 10LL ;
+
+	HANDLE *hHRObjs = new HANDLE[numObjs+1] ;
+	std::copy(&hObjs[0],&hObjs[numObjs],&hHRObjs[0]);
+	hHRObjs[numObjs]=hTimer;
+
+	DWORD r = WAIT_FAILED;
+
+	do {
+
+		if(!SetWaitableTimer(hTimer, &time, 0, NULL, NULL, 0))
+			break ;
+
+		r = WaitForMultipleObjects(numObjs+1,hHRObjs,FALSE,INFINITE);
+		if(r==WAIT_OBJECT_0+numObjs) r = WAIT_TIMEOUT;
+
+	}while(0);
+
+	CloseHandle(hTimer);
+	delete [] hHRObjs;
+
+	return r ;
+}
+
+//---------------------------------------------------------------------------
+} // End of namespace PRY8EAlByw
+//===========================================================================
+// C
+//---------------------------------------------------------------------------
+extern "C" void SetHRTimerMode_C(BOOL useHighResolution)
+{
+  SetHRTimerMode(useHighResolution);
+}
+//---------------------------------------------------------------------------
+extern "C" void HRSleep_C(DWORD msec, DWORD usec)
+{
+  HRSleep(msec, usec);
+}
+//---------------------------------------------------------------------------
+extern "C" DWORD HRWaitForSingleObject_C(HANDLE hObj, DWORD msec, DWORD usec)
+{
+  return HRWaitForSingleObject(hObj, msec, usec);
+}
+//---------------------------------------------------------------------------
+extern "C" DWORD HRWaitForMultipleObjects_C(DWORD numObjs, const HANDLE *hObjs,
+  BOOL waitAll, DWORD msec, DWORD usec)
+{
+  return HRWaitForMultipleObjects(numObjs, hObjs, waitAll, msec, usec);
+}
+//===========================================================================
diff -uPr BonD_FSHybrid-20201009_org/src/HRTimer.h BonD_FSHybrid-20201009_mod10.1/src/HRTimer.h
--- BonD_FSHybrid-20201009_org/src/HRTimer.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/HRTimer.h	2022-05-02 22:41:58.000000000 +0900
@@ -0,0 +1,53 @@
+//===========================================================================
+#pragma once
+
+#ifndef _HRTIMER_187BE8C9_0DB1_4F50_B02E_B271FCB3B274_H_INCLUDED_
+#define _HRTIMER_187BE8C9_0DB1_4F50_B02E_B271FCB3B274_H_INCLUDED_
+//---------------------------------------------------------------------------
+
+#define PRY8EAlByw_HRTIMER
+
+#ifdef __cplusplus
+//===========================================================================
+namespace PRY8EAlByw {
+//---------------------------------------------------------------------------
+
+  // High Resolution Timer functions
+
+void SetHRTimerMode(BOOL useHighResolution) ;
+void HRSleep(DWORD msec, DWORD usec=0) ;
+DWORD HRWaitForSingleObject(HANDLE hObj, DWORD msec, DWORD usec=0);
+DWORD HRWaitForMultipleObjects(DWORD numObjs, const HANDLE *hObjs, BOOL waitAll,
+  DWORD msec, DWORD usec=0);
+
+//---------------------------------------------------------------------------
+} // End of namespace PRY8EAlByw
+//===========================================================================
+using namespace PRY8EAlByw ;
+//===========================================================================
+#endif
+//===========================================================================
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void SetHRTimerMode_C(BOOL useHighResolution) ;
+void HRSleep_C(DWORD msec, DWORD usec);
+DWORD HRWaitForSingleObject_C(HANDLE hObj, DWORD msec, DWORD usec);
+DWORD HRWaitForMultipleObjects_C(DWORD numObjs, const HANDLE *hObjs, BOOL waitAll,
+  DWORD msec, DWORD usec);
+
+#ifndef __cplusplus
+
+#define SetHRTimerMode				SetHRTimerMode_C
+#define HRSleep						HRSleep_C
+#define HRWaitForSingleObject		HRWaitForSingleObject_C
+#define HRWaitForMultipleObjects	HRWaitForMultipleObjects_C
+
+#endif
+
+#ifdef __cplusplus
+} // End of extern "C"
+#endif
+//===========================================================================
+#endif // _HRTIMER_187BE8C9_0DB1_4F50_B02E_B271FCB3B274_H_INCLUDED_
diff -uPr BonD_FSHybrid-20201009_org/src/bonhybrid.cpp BonD_FSHybrid-20201009_mod10.1/src/bonhybrid.cpp
--- BonD_FSHybrid-20201009_org/src/bonhybrid.cpp	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/bonhybrid.cpp	2022-05-03 02:42:21.000000000 +0900
@@ -0,0 +1,1045 @@
+//===========================================================================
+#include "stdafx.h"
+//---------------------------------------------------------------------------
+
+#include <string>
+#include <iterator>
+#include <climits>
+#include "bonhybrid.h"
+#include "usbdevfile.h"
+
+//---------------------------------------------------------------------------
+
+using namespace std;
+
+//===========================================================================
+namespace BonHybrid {
+//---------------------------------------------------------------------------
+
+#define UNITEDINIFILENAME "BonDriver_FSHybrid.ini"
+#define INIVALUELOADER_SECTION "BonTuner"
+#define INICHANNELS_SECTION "Channels"
+
+extern "C" {
+
+// Lɂtrinity19683񒼓`̃LbVɕύX
+BOOL TSCACHING_LEGACY = FALSE ;
+// LbV𐮍邩ǂi肷邪ׂj
+BOOL TSCACHING_DEFRAGMENT = FALSE ;
+// LbV𐮍ꍇ̃pPbgTCY
+DWORD TSCACHING_DEFRAGSIZE = 128*1024 ; // 128K(SpinelɍœK)
+// oN][h̃I[o[ChpPbgTCY
+int TSCACHING_BULKPACKETSIZE = 0 ; // 1ȏŗL
+// NULLpPbgVbgAEg邩ǂ[1: / 0:Ȃ]
+int TSCACHING_DROPNULLPACKETS = 1;
+
+// 񓯊LbV̐ݒ
+DWORD ASYNCTS_QUEUENUM     = 66  ; // Default 3M (47K*66) bytes
+DWORD ASYNCTS_QUEUEMAX     = 660 ; // Maximum growth 30M (47K*660) bytes
+DWORD ASYNCTS_EMPTYBORDER  = 22  ; // Empty border at least 1M (47K*22) bytes
+DWORD ASYNCTS_EMPTYLIMIT   = 11  ; // Empty limit at least 0.5M (47K*11) bytes
+DWORD TSALLOC_TIMEOUT      = 100 ;
+BOOL  TSALLOC_WAITING      = FALSE ;
+BOOL  TSALLOC_MODERATE     = TRUE ;
+int   TSALLOC_PRIORITY     = THREAD_PRIORITY_HIGHEST ;
+
+// ̃`lVHF܂߂邩ǂ
+BOOL DEFSPACE_VHF = FALSE ;
+// ̃`lUHF܂߂邩ǂ
+BOOL DEFSPACE_UHF = TRUE ;
+// ̃`lCATV܂߂邩ǂ
+BOOL DEFSPACE_CATV = FALSE ;
+// ̃`lɃWXg̃`l܂߂邩ǂ
+BOOL DEFSPACE_AUX = TRUE ;
+// ̎Og`[i[`lBS܂߂邩ǂ
+BOOL DEFSPACE_BS = TRUE ;
+// ̎Og`[i[BS`l̊eXg[(0-8)
+DWORD DEFSPACE_BS_STREAMS = 8 ;
+// ̎Og`[i[BS`lXg[ɔzu邩ǂ
+BOOL DEFSPACE_BS_STREAM_STRIDE = FALSE ;
+// ̎Og`[i[`lCS110܂߂邩ǂ
+BOOL DEFSPACE_CS110 = TRUE ;
+// ̎Og`[i[CS110`l̊eXg[(0-8)
+DWORD DEFSPACE_CS110_STREAMS = 8 ;
+// ̎Og`[i[CS110`lXg[ɔzu邩ǂ
+BOOL DEFSPACE_CS110_STREAM_STRIDE = FALSE ;
+// IBonDriverSetChannelɃ[U[`lgp邩ǂ
+BOOL BYTETUNING_USER = FALSE ;
+
+// Ɏsꍇ̍Ďsݒ
+DWORD DEVICE_RETRY_TIMES = 3 ;       // foCXĎső
+DWORD TUNER_RETRY_DURATION = 3000 ;  // `[i[̃I[vőĎs
+
+// `[i[QƎɋ@̎QIDz悤ɂ邩ǂ
+BOOL DEVICE_ID_ROTATION = FALSE ;          // IDzQƂ邩ǂ
+BOOL DEVICE_ID_ROTATION_VOLATILE = FALSE ; // WXgɏǂ
+
+// x݃^C}[gp邩ǂ
+BOOL HIGH_PRECISE_INTERRUPT = FALSE;
+
+}
+
+// Instance
+CBonFSHybrid* CBonFSHybrid::m_pThis = NULL;
+HINSTANCE CBonFSHybrid::m_hModule = NULL;
+
+
+//#define ES_PREVIEW
+
+// GWjAOTvp̎ݒR[h
+#ifdef ES_PREVIEW
+#define ES_LIMIT (60*60*1000) // 1Ԍo߂Xg[~
+static DWORD ES_Past = 0 ;
+static bool ES_Elapsed() {
+	if(!ES_Past) ES_Past = Elapsed() ;
+	return Elapsed(ES_Past)>ES_LIMIT ;
+}
+#endif
+
+
+//===========================================================================
+// Value Loaders
+//---------------------------------------------------------------------------
+class CRegValueLoader : public IValueLoader
+{
+	HKEY HKey ;
+public:
+	CRegValueLoader(HKEY hKey): HKey(hKey) {}
+	virtual DWORD ReadDWORD(const wstring name,DWORD defVal=0) const {
+		BYTE buf[sizeof DWORD] ;
+		DWORD rdSize = sizeof DWORD ;
+		DWORD type = 0 ;
+		if(ERROR_SUCCESS==RegQueryValueEx(
+		  HKey, name.c_str(), 0, &type, buf, &rdSize )) {
+			if(type==REG_DWORD) {
+				DWORD result = *(DWORD*)(&buf[0]) ;
+				DBGOUT("Mode: %s=%d\n",wcs2mbcs(name).c_str(),result);
+				return result ;
+			}
+		}
+		return defVal ;
+	}
+	virtual wstring ReadString(const wstring name,const wstring defStr) const {
+		const size_t MAX_BYTES = 1024 ;
+		BYTE buf[MAX_BYTES] ;
+		DWORD rdSize = sizeof buf ;
+		DWORD type = 0 ;
+		if(ERROR_SUCCESS==RegQueryValueEx(
+		  HKey, name.c_str(), 0, &type, buf, &rdSize )) {
+			if(type==REG_SZ) {
+				wstring result((LPCTSTR)(&buf[0])) ;
+				DBGOUT("Mode: %s=%s\n",wcs2mbcs(name).c_str(),wcs2mbcs(result).c_str());
+				return result ;
+			}
+		}
+		return defStr ;
+	}
+};
+//---------------------------------------------------------------------------
+class CIniValueLoader : public IValueLoader
+{
+	string Section, Filename ;
+	string ReadStringA(const string name,const string defStr) const {
+		const size_t MAX_CHARS = 1024 ;
+		char buf[MAX_CHARS] ;
+		DWORD num = GetPrivateProfileStringA(
+			Section.c_str(),name.c_str(),defStr.c_str(),
+			buf,MAX_CHARS,Filename.c_str());
+		return num>0 ? string(buf,num) : defStr ;
+	}
+public:
+	CIniValueLoader(const string section,const string filename)
+	{ Section=section; Filename=filename; }
+	virtual DWORD ReadDWORD(const wstring name,DWORD defVal=0) const {
+	#if 0
+		return (DWORD) GetPrivateProfileIntA(
+			Section.c_str(),wcs2mbcs(name).c_str(),(int)defVal,Filename.c_str()) ;
+	#else
+		return (DWORD) acalci(ReadStringA(wcs2mbcs(name),"").c_str(),(int)(defVal));
+	#endif
+	}
+	virtual wstring ReadString(const wstring name,const wstring defStr) const {
+		return mbcs2wcs(ReadStringA(wcs2mbcs(name),wcs2mbcs(defStr)));
+	}
+};
+//===========================================================================
+// CBonFSHybrid
+//---------------------------------------------------------------------------
+CBonFSHybrid::CBonFSHybrid(bool hasSatellite)
+{
+	m_pThis = this;
+	m_hasSatellite=hasSatellite ;
+	tsthr=NULL ;
+	m_fifo=NULL ;
+	FifoFinalize() ;
+}
+//---------------------------------------------------------------------------
+CBonFSHybrid::~CBonFSHybrid()
+{
+	FifoFinalize() ;
+	m_pThis = NULL;
+}
+//---------------------------------------------------------------------------
+string CBonFSHybrid::ModuleFileName()
+{
+	char path[_MAX_PATH] ;
+	GetModuleFileNameA( m_hModule, path, _MAX_PATH ) ;
+	return path ;
+}
+//---------------------------------------------------------------------------
+bool CBonFSHybrid::FindDevice(const GUID &drvGUID, HANDLE &hDev, HANDLE &hUsbDev)
+{
+	bool result = false ;
+	DWORD counter = 0;
+	hDev=hUsbDev=NULL;
+	int user_idx = UserDecidedDeviceIdx();
+	int rot_idx = -1 ;
+	wstring rot_nam = L"ROTATION_DEVICE_ID("+wstring(GetTunerName())+L")" ;
+	wstring reg_nam = RegName() ;
+	if(DEVICE_ID_ROTATION_VOLATILE) reg_nam += L"\\__volatile__" ;
+	if(DEVICE_ID_ROTATION && user_idx<0) {
+		HKEY hKey ;
+		if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, reg_nam.c_str(), 0, KEY_READ, &hKey)) {
+			rot_idx = (int) CRegValueLoader(hKey).ReadDWORD(rot_nam,0) + 1 ;
+			RegCloseKey(hKey);
+		}else rot_idx=0;
+	}
+	do {
+		int idx = user_idx < 0 ? rot_idx : user_idx ;
+		if(hDev||hUsbDev) {
+			HRSleep(50);
+			FreeDevice(hDev,hUsbDev);
+		}
+		if(counter>0) HRSleep(1000) ; //# take a breath before retrying...
+		if((hDev = usbdevfile_alloc(&idx,&drvGUID) ) == NULL) {
+			if(user_idx<0&&rot_idx>=0) {
+				if(rot_idx!=0) rot_idx^=rot_idx;
+				else rot_idx=-1;
+				counter--;
+			}
+			continue; //# not found
+		}
+		if((hUsbDev = usbdevfile_init(hDev) ) == NULL) {
+			continue; //# failed
+		}
+		result = true ;
+		rot_idx = idx ;
+	}while(!result&&++counter<=DEVICE_RETRY_TIMES);
+	if(result && DEVICE_ID_ROTATION && rot_idx>=0) {
+		HKEY hKey ; DWORD dwDisposition ;
+		if( ERROR_SUCCESS == RegCreateKeyEx(
+				HKEY_CURRENT_USER, reg_nam.c_str(), 0, NULL,
+				DEVICE_ID_ROTATION_VOLATILE?
+					REG_OPTION_VOLATILE: REG_OPTION_NON_VOLATILE,
+				KEY_ALL_ACCESS, NULL, &hKey, &dwDisposition) ) {
+			RegSetValueEx( hKey, rot_nam.c_str(), 0, REG_DWORD,
+				(BYTE*)&rot_idx, sizeof DWORD );
+			RegCloseKey(hKey);
+		}
+	}
+	return result ;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::FreeDevice(HANDLE &hDev, HANDLE &hUsbDev)
+{
+	if(hUsbDev) {
+		usbdevfile_free(hUsbDev);
+		hUsbDev = NULL;
+	}
+	if(hDev) {
+		::CloseHandle( hDev );
+		hDev = NULL;
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::LoadUserChannels()
+{
+	string chFName = file_path_of(ModuleFileName()) + file_prefix_of(ModuleFileName()) + ".ch.txt" ;
+
+	FILE *st = NULL ;
+	fopen_s(&st, chFName.c_str(), "rt") ;
+	if (!st)
+		return ;
+	char s[512] ;
+
+	CHANNELS channels ;
+	SPACEINDICES indices ;
+
+	std::wstring space_name = L"" ;
+	while (!feof(st)) {
+		s[0] = '\0' ;
+		fgets(s, 512, st) ;
+		string strLine = trim(string(s)) ;
+		if (strLine.empty())
+			continue ;
+		wstring wstrLine = mbcs2wcs(strLine) ;
+		int t = 0 ;
+		vector<wstring> params ;
+		split(params, wstrLine, L';') ;
+		wstrLine = params[0] ;
+		params.clear() ;
+		split(params, wstrLine, L',') ;
+		if (params.size() >= 2 && !params[0].empty()) {
+			BAND band = BAND_na ;
+			int channel = 0 ;
+			DWORD freq = 0 ;
+			int stream = 0 ;
+			int tsid = 0 ;
+			wstring &space = params[0] ;
+			wstring name = params.size() >= 3 ? params[2] : wstring(L"") ;
+			wstring subname = params[1] ;
+			vector<wstring> phyChDiv ;
+			split(phyChDiv, params[1], '/') ;
+			for (size_t i = 0;i < phyChDiv.size();i++) {
+				wstring phyCh = phyChDiv[i] ;
+				if ( phyCh.length() > 3 &&
+						phyCh.substr(phyCh.length() - 3) == L"MHz" ) {
+					float megaHz = 0.f ;
+					if (swscanf_s(phyCh.c_str(), L"%fMHz", &megaHz) == 1) {
+						freq = DWORD(megaHz * 1000.f) ;
+						channel = CHANNEL::BandFromFreq(freq) != BAND_na ? -1 : 0 ;
+					}
+				} else {
+					if (m_hasSatellite && swscanf_s(phyCh.c_str(), L"TS%d", &stream) == 1)
+						;
+					else if (m_hasSatellite && swscanf_s(phyCh.c_str(), L"ID%i", &tsid) == 1)
+						;
+					else if (band == BAND_na) {
+						if (m_hasSatellite && swscanf_s(phyCh.c_str(), L"BS%d", &channel) == 1)
+							band = BAND_BS ;
+						else if (m_hasSatellite && swscanf_s(phyCh.c_str(), L"ND%d", &channel) == 1)
+							band = BAND_ND ;
+						else if (swscanf_s(phyCh.c_str(), L"C%d", &channel) == 1)
+							band = BAND_VU, subname = L"C" + itows(channel) + L"ch", channel += 100 ;
+						else if (swscanf_s(phyCh.c_str(), L"%d", &channel) == 1)
+							band = BAND_VU, subname = itows(channel) + L"ch" ;
+					}
+				}
+			}
+			if (name == L"")
+				name = subname ;
+			if (freq > 0 && channel < 0)
+				channels.push_back(
+					CHANNEL(space, freq, name, stream, tsid)) ;
+			else if (band != BAND_na && channel > 0)
+				channels.push_back(
+					CHANNEL(space, band, channel, name, stream, tsid)) ;
+			else
+				continue ;
+			if (space_name != space) {
+				indices.push_back(channels.size() - 1) ;
+				space_name = space ;
+			}
+		}
+	}
+
+	if (!channels.empty() && !indices.empty()) {
+		m_UserChannels.swap(channels) ;
+		m_UserSpaceIndices.swap(indices) ;
+		m_Transponders.swap(CHANNELS());
+	}
+
+	fclose(st) ;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::BuildTChannels()
+{
+	if(DEFSPACE_VHF) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		for(int i=1;i<=12;i++) {
+			m_UserChannels.push_back(CHANNEL(L"VHF",BAND_VU,i,itows(i)+L"ch"));
+		}
+	}
+	if(DEFSPACE_UHF) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		for(int i=13;i<=62;i++) {
+			m_UserChannels.push_back(CHANNEL(L"UHF",BAND_VU,i,itows(i)+L"ch"));
+		}
+	}
+	if(DEFSPACE_CATV) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		for(int i=13;i<=63;i++) {
+			m_UserChannels.push_back(CHANNEL(L"CATV",BAND_VU,i+100,L"C"+itows(i)+L"ch"));
+		}
+	}
+
+	copy(m_UserChannels.begin(), m_UserChannels.end(), back_inserter(m_Transponders)) ;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::BuildSChannels()
+{
+	if(DEFSPACE_BS) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		if(DEFSPACE_BS_STREAMS) {
+			if(DEFSPACE_BS_STREAM_STRIDE) {
+				for(DWORD j=0;j<DEFSPACE_BS_STREAMS;j++)
+				for(int i=1;i<=23;i+=2)
+					m_UserChannels.push_back(CHANNEL(L"BS",BAND_BS,i,L"BS"+itows(i)+L"/TS"+itows(j),j));
+			}else {
+				for(int i=1;i<=23;i+=2)
+				for(DWORD j=0;j<DEFSPACE_BS_STREAMS;j++)
+					m_UserChannels.push_back(CHANNEL(L"BS",BAND_BS,i,L"BS"+itows(i)+L"/TS"+itows(j),j));
+			}
+		}else {
+			for(int i=1;i<=23;i+=2)
+				m_UserChannels.push_back(CHANNEL(L"BS",BAND_BS,i,L"BS"+itows(i),0));
+		}
+		for(int i=1;	i <= 23;	i+=2)
+		for(int j=0;	j<max<int>(DEFSPACE_BS_STREAMS,1);	j++)
+			m_Transponders.push_back(
+				CHANNEL(L"BS",BAND_BS,i,L"BS"+itows(i))) ;
+	}
+	if(DEFSPACE_CS110) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		if(DEFSPACE_CS110_STREAMS) {
+			if(DEFSPACE_CS110_STREAM_STRIDE) {
+				for(DWORD j=0;j<DEFSPACE_CS110_STREAMS;j++)
+				for(int i=2;i<=24;i+=2)
+					m_UserChannels.push_back(CHANNEL(L"CS110",BAND_ND,i,L"ND"+itows(i)+L"/TS"+itows(j),j));
+			}else {
+				for(int i=2;i<=24;i+=2)
+				for(DWORD j=0;j<DEFSPACE_CS110_STREAMS;j++)
+					m_UserChannels.push_back(CHANNEL(L"CS110",BAND_ND,i,L"ND"+itows(i)+L"/TS"+itows(j),j));
+			}
+		}else {
+			for(int i=2;i<=24;i+=2)
+				m_UserChannels.push_back(CHANNEL(L"CS110",BAND_ND,i,L"ND"+itows(i),0));
+		}
+		for(int i=2;	i <= 24;	i+=2)
+		for(int j=0;	j<max<int>(DEFSPACE_CS110_STREAMS,1);	j++)
+			m_Transponders.push_back(
+				CHANNEL(L"CS110",BAND_ND,i,L"ND"+itows(i))) ;
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::BuildAuxChannels()
+{
+	if(!DEFSPACE_AUX) return ;
+	CHANNELS channels ;
+
+	string path = file_path_of(ModuleFileName()) ;
+	string dllIniFileName = path + file_prefix_of(ModuleFileName()) + ".ini" ;
+	ReadIniChannels(dllIniFileName,channels);
+	if(channels.empty()) {
+		string unitedIniFileName = path + UNITEDINIFILENAME ;
+		ReadIniChannels(unitedIniFileName,channels);
+		if(channels.empty()) {
+			HKEY hKey;
+			if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, RegName(), 0, KEY_READ, &hKey)) {
+				ReadRegChannels(hKey,channels);
+				RegCloseKey(hKey);
+			}
+			if(channels.empty()) {
+				if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, RegName(), 0, KEY_READ, &hKey)) {
+					ReadRegChannels(hKey,channels);
+					RegCloseKey(hKey);
+				}
+			}
+		}
+	}
+	if(!channels.empty()) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		copy(channels.begin(),channels.end(),back_inserter(m_UserChannels)) ;
+		copy(channels.begin(),channels.end(),back_inserter(m_Transponders)) ;
+	}
+}
+//---------------------------------------------------------------------------
+
+  bool CBonFSHybrid::ArrangeChannels(CHANNELS &channels) {
+    struct space_finder : public std::unary_function<CHANNEL, bool> {
+      std::wstring space ;
+      space_finder(std::wstring space_) {
+        space = space_ ;
+      }
+      bool operator ()(const CHANNEL &ch) const {
+        return space == ch.Space;
+      }
+    };
+    if (!m_InvisibleSpaces.empty() || !m_SpaceArrangement.empty()) {
+      CHANNELS newChannels ;
+      //CHANNELS oldChannels(channels) ;
+      CHANNELS &oldChannels = channels ;
+      CHANNELS::iterator beg = oldChannels.begin() ;
+      CHANNELS::iterator end = oldChannels.end() ;
+      for (CHANNELS::size_type i = 0; i < m_InvisibleSpaces.size(); i++) {
+        end = remove_if(beg, end, space_finder(m_InvisibleSpaces[i]));
+      }
+      for (CHANNELS::size_type i = 0; i < m_SpaceArrangement.size(); i++) {
+        space_finder finder(m_SpaceArrangement[i]) ;
+        remove_copy_if(beg, end, back_inserter(newChannels), not1(finder)) ;
+        end = remove_if(beg, end, finder) ;
+      }
+      copy(beg, end, back_inserter(newChannels)) ;
+      channels.swap(newChannels) ;
+	  return true ;
+    }
+	return false ;
+  }
+
+void CBonFSHybrid::RebuildChannels()
+{
+	if(ArrangeChannels(m_UserChannels)) {
+		if(!m_Transponders.empty())
+			ArrangeChannels(m_Transponders);
+		SPACEINDICES newSpaceIndices ;
+		wstring space = L"" ;
+		for (CHANNELS::size_type i = 0;i < m_UserChannels.size();i++) {
+			if (m_UserChannels[i].Space != space) {
+				space = m_UserChannels[i].Space ;
+				newSpaceIndices.push_back(size_t(i)) ;
+			}
+		}
+		m_UserSpaceIndices.swap(newSpaceIndices) ;
+	}
+}
+//---------------------------------------------------------------------------
+CBonFSHybrid::CHANNEL *CBonFSHybrid::GetUserChannel(DWORD dwSpace, DWORD dwChannel)
+{
+	if(dwSpace<m_UserSpaceIndices.size()) {
+		DWORD begin = (DWORD)m_UserSpaceIndices[dwSpace] ;
+		DWORD end = DWORD(dwSpace+1 < m_UserSpaceIndices.size()
+			? m_UserSpaceIndices[dwSpace+1] : m_UserChannels.size()) ;
+		if(dwChannel<end-begin) {
+			DWORD index = begin + dwChannel ;
+			return &m_UserChannels[index] ;
+		}
+	}
+	return NULL ;
+}
+//---------------------------------------------------------------------------
+CBonFSHybrid::CHANNEL CBonFSHybrid::GetChannel(DWORD dwSpace, DWORD dwChannel)
+{
+	if(dwSpace == SPACE_CHASFREQ) {  //# dwChannel as freq/kHz
+		return CHANNEL(L"CHASFREQ",dwChannel,itows(dwChannel)+L"kHz") ;
+	}else if(CHANNEL *userChannel = GetUserChannel(dwSpace,dwChannel)) {
+		return *userChannel ;
+	}
+	return CHANNEL() ;
+}
+//---------------------------------------------------------------------------
+bool CBonFSHybrid::FifoInitialize(usb_endpoint_st *usbep)
+{
+	tsfifo_t *ptsfifo = NULL ;
+	tsfifo_t tsfifo={0} ;
+	FifoFinalize();
+	if(!TSCACHING_LEGACY) {
+		if(m_eoCaching.is_valid()) {
+			size_t TSDATASIZE = ROUNDUP(usbep->xfer_size,0x1FFUL) ;
+			if(usbep->endpoint&0x100) {  // Isochronous
+				// AC\NiX]̏ꍇ́AIɐ
+				if(!TSCACHING_DEFRAGMENT) {
+					//t[pPbgɃTCYg
+					TSCACHING_DEFRAGSIZE = TSCACHING_BULKPACKETSIZE>0 ?
+						TSCACHING_BULKPACKETSIZE : TS_PacketSize ;
+					TSCACHING_DEFRAGMENT = TRUE ; //
+				}
+			}
+			if(TSCACHING_DEFRAGMENT)
+				TSDATASIZE = max(TSCACHING_DEFRAGSIZE,TSDATASIZE);
+			DBGOUT("TSDATASIZE=%d\n",TSDATASIZE) ;
+			m_fifo = new CAsyncFifo(
+				ASYNCTS_QUEUENUM,ASYNCTS_QUEUEMAX,ASYNCTS_EMPTYBORDER,
+				TSDATASIZE,TSALLOC_TIMEOUT,TSALLOC_PRIORITY ) ;
+			if(m_fifo) {
+				m_fifo->SetEmptyLimit(ASYNCTS_EMPTYLIMIT) ;
+				m_fifo->SetModerateAllocating(TSALLOC_MODERATE?true:false);
+				if(TSCACHING_DEFRAGMENT) {
+					tsfifo.writeThrough = &OnTSFifoWriteThrough ;
+				}else {
+					tsfifo.writeBackBegin = &OnTSFifoWriteBackBegin ;
+					tsfifo.writeBackFinish = &OnTSFifoWriteBackFinish ;
+				}
+				tsfifo.purge = &OnTSFifoPurge ;
+				tsfifo.arg = this ;
+				ptsfifo = &tsfifo ;
+			}
+		}
+	}
+	//# TS receive thread
+	if( tsthread_create(&tsthr, usbep, ptsfifo) ) {
+		return false;
+	}
+	return true;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::FifoFinalize()
+{
+	if(tsthr) {
+		tsthread_stop(tsthr);
+		tsthread_destroy(tsthr);
+		tsthr = NULL;
+	}
+	if(m_fifo) {
+		delete m_fifo;
+		m_fifo = NULL;
+	}
+	ZeroMemory(m_mapCache,sizeof(m_mapCache)) ;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::FifoStart()
+{
+	if(tsthr) tsthread_start(tsthr);
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::FifoStop()
+{
+	if(tsthr) tsthread_stop(tsthr);
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::ReadRegChannels(HKEY hPKey, CHANNELS &regChannels)
+{
+	HKEY hKey;
+	DWORD NumOfValues;
+	TCHAR szValueName[32];
+	DWORD dwValue, dwLen, dwType, dwByte, dwMaxValueName;
+	if(ERROR_SUCCESS != RegOpenKeyEx( hPKey, TEXT("Channels"), 0, KEY_READ, &hKey)) {
+		return;
+	}
+	if(ERROR_SUCCESS != RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumOfValues, &dwMaxValueName, NULL, NULL, NULL)) {
+		RegCloseKey(hKey);
+		return;
+	}
+	regChannels.resize(NumOfValues) ;
+	for(DWORD dwIdx = 0; dwIdx < NumOfValues; dwIdx++ ) {
+		dwLen = 32;
+		dwByte = sizeof(dwValue);
+		if(ERROR_SUCCESS != RegEnumValue( hKey, dwIdx, szValueName, &dwLen, NULL, &dwType, (BYTE*)&dwValue, &dwByte)
+			|| dwByte != sizeof(DWORD)) {
+			break;
+		}
+		dwByte = dwValue >> 24; //# Index
+		if( dwByte >= NumOfValues ) continue;
+		regChannels[dwByte] = CHANNEL(L"AUX",dwValue & 0x00ffffff,szValueName) ;
+	}
+	RegCloseKey(hKey);
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::ReadIniChannels (const std::string iniFilename, CHANNELS &iniChannels)
+{
+	BUFFER<char> buf(256) ;
+	DWORD n = 0;
+	do {
+		if (n) buf.resize(buf.size()*2) ;
+		n = GetPrivateProfileSectionA(INICHANNELS_SECTION, buf.data(), (DWORD)buf.size(), iniFilename.c_str());
+	} while (n == buf.size() - 2);
+	if (!n)
+		return ;
+	size_t numChannel = 0 ;
+	for (size_t i = 0;i < n;i++) {
+		char *p = buf.data() ;
+		p = &p[i] ;
+		if (!*p)
+			break ;
+		numChannel++ ;
+		i += strlen(p);
+	}
+	if (!numChannel)
+		return ;
+	iniChannels.resize(numChannel) ;
+	for (size_t i = 0;i < n;i++) {
+		char *p = buf.data() ;
+		p = &p[i] ;
+		if (!*p)
+			break ;
+		vector<string> item ;
+		split(item, string(p), '=') ;
+		if (item.size() == 2) {
+			int val = acalci(item[1].c_str(),-1) ;
+			if (val!=-1) {
+				size_t idx = size_t(val) >> 24;
+				if(idx < numChannel)
+					iniChannels[idx] = CHANNEL(L"AUX", val & 0x00ffffff, mbcs2wcs(item[0])) ;
+			}
+		}
+		i += strlen(p);
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::LoadReg()
+{
+	HKEY hKey;
+	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, RegName(), 0, KEY_READ, &hKey)) {
+		CRegValueLoader Loader(hKey) ;
+		LoadValues(&Loader);
+		RegCloseKey(hKey);
+	}
+	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, RegName(), 0, KEY_READ, &hKey)) {
+		CRegValueLoader Loader(hKey) ;
+		LoadValues(&Loader);
+		RegCloseKey(hKey);
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::LoadIni()
+{
+	string path = file_path_of(ModuleFileName()) ;
+	string unitedIniFileName = path + UNITEDINIFILENAME ;
+	CIniValueLoader unitedIniLoader(INIVALUELOADER_SECTION, unitedIniFileName) ;
+	LoadValues(&unitedIniLoader);
+	string dllIniFileName = path + file_prefix_of(ModuleFileName()) + ".ini" ;
+	CIniValueLoader dllIniLoader(INIVALUELOADER_SECTION, dllIniFileName) ;
+	LoadValues(&dllIniLoader);
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::LoadValues(const IValueLoader *Loader)
+{
+	#define LOADDW(val) do { val = Loader->ReadDWORD(L#val,val); } while(0)
+	#define LOADMSTRLIST(name) do { \
+		wstring s = Loader->ReadString(L#name); \
+		if(!s.empty()) { \
+			m_##name.clear(); split(m_##name,s,','); \
+		} }while(0)
+	LOADDW(TSCACHING_LEGACY);
+	LOADDW(TSCACHING_DEFRAGMENT);
+	LOADDW(TSCACHING_DEFRAGSIZE);
+	LOADDW(TSCACHING_BULKPACKETSIZE);
+	LOADDW(TSCACHING_DROPNULLPACKETS);
+	LOADDW(ASYNCTS_QUEUENUM);
+	LOADDW(ASYNCTS_QUEUEMAX);
+	LOADDW(ASYNCTS_EMPTYBORDER);
+	LOADDW(ASYNCTS_EMPTYLIMIT);
+	LOADDW(TSALLOC_TIMEOUT);
+	LOADDW(TSALLOC_WAITING);
+	LOADDW(TSALLOC_MODERATE);
+	LOADDW(TSALLOC_PRIORITY);
+	LOADDW(DEFSPACE_VHF);
+	LOADDW(DEFSPACE_UHF);
+	LOADDW(DEFSPACE_CATV);
+	LOADDW(DEFSPACE_AUX);
+	LOADDW(DEFSPACE_BS);
+	LOADDW(DEFSPACE_BS_STREAMS);
+	LOADDW(DEFSPACE_BS_STREAM_STRIDE);
+	LOADDW(DEFSPACE_CS110);
+	LOADDW(DEFSPACE_CS110_STREAMS);
+	LOADDW(DEFSPACE_CS110_STREAM_STRIDE);
+	LOADDW(BYTETUNING_USER);
+	LOADDW(DEVICE_RETRY_TIMES);
+	LOADDW(TUNER_RETRY_DURATION);
+	LOADDW(DEVICE_ID_ROTATION);
+	LOADDW(DEVICE_ID_ROTATION_VOLATILE);
+	LOADDW(HIGH_PRECISE_INTERRUPT);
+	LOADMSTRLIST(SpaceArrangement);
+	LOADMSTRLIST(InvisibleSpaces);
+	LOADDW(TSTHREAD_DUPLEX);
+	LOADDW(TSTHREAD_PRIORITY);
+	LOADDW(TSTHREAD_POLL_TIMEOUT);
+	LOADDW(TSTHREAD_SUBMIT_TIMEOUT);
+	LOADDW(TSTHREAD_NUMIO);
+	LOADDW(TSTHREAD_SUBMIT_IOLIMIT);
+	LOADDW(TSTHREAD_LOCK_ON_WINUSB);
+	LOADDW(USBPOWERPOLICY_AVOID_SUSPEND);
+	LOADDW(USBPIPEPOLICY_RAW_IO);
+	LOADDW(USBPIPEPOLICY_AUTO_CLEAR_STALL);
+	LOADDW(USBPIPEPOLICY_ALLOW_PARTIAL_READS);
+	LOADDW(USBPIPEPOLICY_AUTO_FLUSH);
+	LOADDW(USBPIPEPOLICY_IGNORE_SHORT_PACKETS);
+	LOADDW(USBPIPEPOLICY_SHORT_PACKET_TERMINATE);
+	LOADDW(USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT);
+	LOADDW(USBPIPEPOLICY_RESET_PIPE_ON_RESUME);
+	#undef LOADMSTRLIST
+	#undef LOADDW
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::Initialize()
+{
+	InitConstants();
+	LoadReg();
+	LoadIni();
+	BuildTChannels();
+	BuildAuxChannels();
+	if(m_hasSatellite)
+		BuildSChannels();
+	LoadUserChannels();
+	RebuildChannels();
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::InitConstants()
+{
+#define ACALCI_ENTRY_CONST(name) do { \
+		acalci_entry_const(#name,(int)name); \
+		acalci64_entry_const(#name,(__int64)name); \
+		}while(0)
+	const int TS_LegacyPacketSize =  188*245 ;
+	ACALCI_ENTRY_CONST(TS_MaxNumIO);
+	//ACALCI_ENTRY_CONST(TS_BufPackets);
+	ACALCI_ENTRY_CONST(TS_PacketSize);
+	ACALCI_ENTRY_CONST(TS_LegacyPacketSize);
+	#ifdef INCLUDE_ISOCH_XFER
+	ACALCI_ENTRY_CONST(ISOCH_FrameSize);
+	ACALCI_ENTRY_CONST(ISOCH_PacketFrames);
+	#endif
+#undef ACALCI_ENTRY_CONST
+}
+//---------------------------------------------------------------------------
+const BOOL CBonFSHybrid::OpenTuner()
+{
+	if(IsTunerOpening()) return FALSE;
+	SetHRTimerMode(HIGH_PRECISE_INTERRUPT);
+	BOOL r; DWORD e=Elapsed();
+	do { r=TryOpenTuner(); } while (!r && Elapsed(e)<TUNER_RETRY_DURATION);
+	return r ;
+}
+//---------------------------------------------------------------------------
+const BOOL CBonFSHybrid::SetChannel(const BYTE bCh)
+{
+	if(BYTETUNING_USER) {
+		if(size_t(bCh)<m_UserChannels.size()) {
+			DWORD space = 0 ;
+			for(;space<m_UserSpaceIndices.size();space++) {
+				if(bCh<m_UserSpaceIndices[space]) {
+					break ;
+				}
+			}
+			if(--space<m_UserSpaceIndices.size()) {
+				DWORD ch = DWORD(bCh)-DWORD(m_UserSpaceIndices[space]) ;
+				return SetChannel(space,ch) ;
+			}
+		}
+	}else {
+		if( (DEFSPACE_VHF&&bCh>=1&&bCh<=12) ||
+			(DEFSPACE_UHF&&bCh>=13&&bCh<=62) ||
+			(DEFSPACE_CATV&&bCh>=113&&bCh<=163) ) {
+			return SetChannel(SPACE_CHASFREQ, CHANNEL::FreqFromBandCh(BAND_VU,bCh));
+		}
+	}
+	return FALSE ;
+}
+//---------------------------------------------------------------------------
+const DWORD CBonFSHybrid::WaitTsStream(const DWORD dwTimeOut)
+{
+	const int remainTime = (dwTimeOut < 0x10000000) ? dwTimeOut : 0x10000000;
+	if(! tsthr) return WAIT_ABANDONED;
+	if(m_fifo) {
+		if(m_fifo->Size()>0) return WAIT_OBJECT_0 ;
+		DWORD res = m_eoCaching.wait(remainTime) ;
+		if(m_fifo->Empty()) return WAIT_TIMEOUT ;
+		return res ;
+	}
+	const int r = tsthread_wait(tsthr, remainTime);
+	if(0 > r)  return WAIT_ABANDONED;
+	else if(0 < r)  return WAIT_OBJECT_0;
+	else  return WAIT_TIMEOUT;
+}
+//---------------------------------------------------------------------------
+const DWORD CBonFSHybrid::GetReadyCount()
+{//# number of call GetTsStream()
+	if(! tsthr) return 0;
+	if(m_fifo) return static_cast<DWORD>(m_fifo->Size());
+	const int ret = tsthread_readable(tsthr);
+	return (ret > 0) ? 1 : 0;
+}
+//---------------------------------------------------------------------------
+const BOOL CBonFSHybrid::GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain)
+{
+#ifdef ES_PREVIEW
+	if(ES_Elapsed()) { if(m_fifo) m_fifo->Purge(false) ; return FALSE ; }
+#endif
+	BYTE *pSrc = NULL;
+	if(GetTsStream(&pSrc, pdwSize, pdwRemain)){
+		if(*pdwSize) ::CopyMemory(pDst, pSrc, *pdwSize);
+		return TRUE;
+	}
+	return FALSE;
+}
+//---------------------------------------------------------------------------
+const BOOL CBonFSHybrid::GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain)
+{
+#ifdef ES_PREVIEW
+	if(ES_Elapsed()) { if(m_fifo) m_fifo->Purge(false) ; return FALSE ; }
+#endif
+	if(! tsthr) return FALSE;
+	if(m_fifo) {
+		m_fifo->Pop(ppDst,pdwSize,pdwRemain);
+		return TRUE ;
+	}
+	const int ret = tsthread_readable(tsthr);
+	if(ret <= 0) {
+		//# no readable data
+		*pdwSize = 0;
+		*pdwRemain = 0;
+		return TRUE;
+	}
+	*pdwSize = tsthread_read(tsthr, (void**)ppDst);
+	*pdwRemain = GetReadyCount();
+	//dmsg("GetTsStream(%p,%u,%u)", ppDst, *pdwSize, *pdwRemain);
+	return TRUE;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::PurgeTsStream()
+{
+	if(! tsthr) return;
+	//# purge available data in TS buffer
+	tsthread_read(tsthr, NULL);
+}
+//---------------------------------------------------------------------------
+LPCTSTR CBonFSHybrid::EnumTuningSpace(const DWORD dwSpace)
+{
+	if(dwSpace<m_UserSpaceIndices.size())
+		return m_UserChannels[m_UserSpaceIndices[dwSpace]].Space.c_str() ;
+	return NULL ;
+}
+//---------------------------------------------------------------------------
+LPCTSTR CBonFSHybrid::EnumChannelName(const DWORD dwSpace, const DWORD dwChannel)
+{
+	static TCHAR buf[8];
+	if(dwSpace<m_UserSpaceIndices.size()) {
+		DWORD begin = (DWORD)m_UserSpaceIndices[dwSpace] ;
+		DWORD end = DWORD(dwSpace+1 < m_UserSpaceIndices.size() ?
+			m_UserSpaceIndices[dwSpace+1] : m_UserChannels.size()) ;
+		if(dwChannel<end-begin)
+			return m_UserChannels[begin+dwChannel].Name.c_str() ;
+	}
+	return NULL ;
+}
+//---------------------------------------------------------------------------
+LPCTSTR CBonFSHybrid::TransponderEnumerate(const DWORD dwSpace, const DWORD dwTransponder)
+{
+	int idx = transponder_index_of(dwSpace, dwTransponder) ;
+	if(idx<0) return NULL ;
+
+	return m_Transponders[idx].Name.c_str();
+}
+//---------------------------------------------------------------------------
+void *CBonFSHybrid::OnTSFifoWriteBackBegin(int id, size_t max_size, void *arg)
+{
+	if(id<0||id>=TS_MaxNumIO) return NULL ;
+	CBonFSHybrid *tuner = static_cast<CBonFSHybrid*>(arg) ;
+	CAsyncFifo::CACHE *cache = tuner->m_fifo->BeginWriteBack(TSALLOC_WAITING?true:false) ;
+	if(!cache) return NULL ;
+	else cache->resize(max_size) ;
+	tuner->m_coPurge.lock() ;
+	tuner->m_mapCache[id] = cache ;
+	tuner->m_coPurge.unlock() ;
+	return cache->data() ;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::OnTSFifoWriteBackFinish(int id, size_t wrote_size, void *arg)
+{
+	CBonFSHybrid *tuner = static_cast<CBonFSHybrid*>(arg) ;
+	exclusive_lock purgeLock(&tuner->m_coPurge);
+	CAsyncFifo::CACHE *cache = tuner->m_mapCache[id] ;
+	if(cache) {
+		tuner->m_mapCache[id]=NULL ;
+		purgeLock.unlock();
+		cache->resize(wrote_size) ;
+		if(tuner->m_fifo->FinishWriteBack(cache))
+			tuner->m_eoCaching.set() ;
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::OnTSFifoWriteThrough(const void *buffer, size_t size, void *arg)
+{
+	CBonFSHybrid *tuner = static_cast<CBonFSHybrid*>(arg) ;
+	exclusive_lock purgeLock(&tuner->m_coPurge);
+	if ( tuner->m_fifo->Push(static_cast<const BYTE*>(buffer),
+		 static_cast<DWORD>(size), false, TSALLOC_WAITING?true:false) > 0)
+			tuner->m_eoCaching.set();
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::OnTSFifoPurge(void *arg)
+{
+	CBonFSHybrid *tuner = static_cast<CBonFSHybrid*>(arg) ;
+	exclusive_lock purgeLock(&tuner->m_coPurge);
+	ZeroMemory(tuner->m_mapCache,sizeof(tuner->m_mapCache));
+	tuner->m_fifo->Purge(true) ;
+}
+//---------------------------------------------------------------------------
+int CBonFSHybrid::transponder_index_of(DWORD dwSpace, DWORD dwTransponder) const
+{
+  if(m_Transponders.empty())
+    return -1 ; // transponder is not entried
+
+  if(m_UserSpaceIndices.size()<=dwSpace)
+    return -1 ; // space is over
+
+  size_t si = m_UserSpaceIndices[dwSpace] ;
+
+  if(m_Transponders[si].Band!=BAND_BS && m_Transponders[si].Band!=BAND_ND)
+    return -1 ; // transponder is not supported
+
+  size_t tp = 0 , i = si ;
+  for(DWORD hz=m_Transponders[si].Freq; tp<dwTransponder&&i<m_Transponders.size(); i++) {
+    if(m_Transponders[i].Space != m_Transponders[si].Space) break ;
+    if(m_Transponders[i].Freq != hz) {
+      hz = m_Transponders[i].Freq ; tp++;
+      if(tp==dwTransponder) break;
+    }
+  }
+
+  if(tp!=dwTransponder)
+    return -1 ; // transponder is not found
+
+  return (int) i ;
+}
+//---------------------------------------------------------------------------
+// CBonFSHybrid::CHANNEL
+//-----
+CBonFSHybrid::CHANNEL::CHANNEL()
+ : Space(L""),Band(BAND_na),Name(L""),Freq(0),Stream(0),TSID(0) {}
+//-----
+CBonFSHybrid::CHANNEL::CHANNEL(wstring space, BAND band, int channel,
+  wstring name, unsigned stream, unsigned tsid) {
+	Space = space ;
+	Band = band ;
+	Name = name ;
+	Freq = FreqFromBandCh(band,channel) ;
+	Stream = stream ;
+	TSID = tsid ;
+}
+//-----
+CBonFSHybrid::CHANNEL::CHANNEL(wstring space, DWORD freq, wstring name,
+  unsigned stream, unsigned tsid){
+	Space = space ;
+	Band = BandFromFreq(freq) ;
+	Name = name ;
+	Freq = freq ;
+	Stream = stream ;
+	TSID = tsid ;
+}
+//-----
+CBonFSHybrid::CHANNEL::CHANNEL(const CHANNEL &src) {
+	Space = src.Space ;
+	Band = src.Band ;
+	Name = src.Name ;
+	Freq = src.Freq ;
+	Stream = src.Stream ;
+	TSID = src.TSID;
+}
+//-----
+DWORD CBonFSHybrid::CHANNEL::FreqFromBandCh(BAND band,int ch) {
+	DWORD freq =0 ;
+	switch(band) {
+		case BAND_VU:
+			if(ch < 4)          freq =  93UL + (ch - 1)   * 6UL ;
+			else if(ch < 8)     freq = 173UL + (ch - 4)   * 6UL ;
+			else if(ch < 13)    freq = 195UL + (ch - 8)   * 6UL ;
+			else if(ch < 63)    freq = 473UL + (ch - 13)  * 6UL ;
+			else if(ch < 122)   freq = 111UL + (ch - 113) * 6UL ;
+			else if(ch ==122)   freq = 167UL ; // C22
+			else if(ch < 136)   freq = 225UL + (ch - 123) * 6UL ;
+			else                freq = 303UL + (ch - 136) * 6UL ;
+			freq *= 1000UL ; // kHz
+			freq +=  143UL ; // + 1000/7 kHz
+			break ;
+		case BAND_BS:
+			freq = ch * 19180UL + 1030300UL ;
+			break ;
+		case BAND_ND:
+			freq = ch * 20000UL + 1573000UL ;
+			break ;
+	}
+	return freq ;
+}
+//-----
+CBonFSHybrid::BAND CBonFSHybrid::CHANNEL::BandFromFreq(DWORD freq) {
+	if(freq < 60000UL || freq > 2456123UL )
+		return BAND_na ;
+	if(freq < 900000UL )
+		return BAND_VU ;
+	if(freq < 1573000UL )
+		return BAND_BS ;
+	return BAND_ND ;
+}
+//---------------------------------------------------------------------------
+} // End of namespace BonHybrid
+//===========================================================================
diff -uPr BonD_FSHybrid-20201009_org/src/bonhybrid.h BonD_FSHybrid-20201009_mod10.1/src/bonhybrid.h
--- BonD_FSHybrid-20201009_org/src/bonhybrid.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/bonhybrid.h	2022-05-03 02:41:35.000000000 +0900
@@ -0,0 +1,156 @@
+//===========================================================================
+#pragma once
+
+#ifndef _BONHYBRID_20191229125131957_H_INCLUDED_
+#define _BONHYBRID_20191229125131957_H_INCLUDED_
+//---------------------------------------------------------------------------
+
+#include <string>
+#include <vector>
+#include "pryutil.h"
+#include "IBonTransponder.h"
+
+extern "C" {
+#include "tsbuff.h"
+#include "tsthread.h"
+}
+
+#define SPACE_CHASFREQ  114514
+
+namespace BonHybrid {
+
+class IValueLoader
+{
+public:
+    virtual DWORD ReadDWORD(const std::wstring name,DWORD defVal=0) const =0 ;
+	virtual std::wstring ReadString(const std::wstring name,const std::wstring defStr=L"") const =0 ;
+};
+
+class CBonFSHybrid : public IBonDriver2Transponder
+{
+public:
+	// BAND
+	enum BAND {
+		BAND_na, // [n/a]
+		BAND_VU, // VHS, UHF or CATV
+		BAND_BS, // BS
+		BAND_ND  // CS110
+	};
+	// CHANNEL/CHANNELS
+	struct CHANNEL {
+		std::wstring	Space ;
+		std::wstring	Name ;
+		BAND			Band ;
+		DWORD			Freq ;
+		unsigned		Stream:3 ;
+		WORD			TSID ;
+		CHANNEL();
+		CHANNEL(std::wstring space, BAND band, int channel, std::wstring name,unsigned stream=0,unsigned tsid=0);
+		CHANNEL(std::wstring space, DWORD freq,std::wstring name,unsigned stream=0,unsigned tsid=0);
+		CHANNEL(const CHANNEL &src) ;
+		static DWORD FreqFromBandCh(BAND band,int ch);
+		static BAND BandFromFreq(DWORD freq);
+	} ;
+	typedef std::vector<CHANNEL> CHANNELS ;
+	typedef std::vector<size_t> SPACEINDICES ;
+	typedef std::vector<std::wstring> SPACENAMES ;
+protected:
+	std::string ModuleFileName() ;
+	// Device
+	virtual int UserDecidedDeviceIdx() { return -1 ; }
+	bool FindDevice(const GUID &drvGUID, HANDLE &hDev, HANDLE &hUsbDev) ;
+	void FreeDevice(HANDLE &hDev, HANDLE &hUsbDev) ;
+	// Channels
+	void LoadUserChannels() ;
+	void BuildTChannels() ;
+	void BuildSChannels() ;
+	void BuildAuxChannels() ;
+	bool ArrangeChannels(CHANNELS &channels) ;
+	void RebuildChannels() ;
+	CHANNEL *GetUserChannel(DWORD dwSpace, DWORD dwChannel);
+	CHANNEL GetChannel(DWORD dwSpace, DWORD dwChannel);
+	// FIFO
+	bool FifoInitialize(usb_endpoint_st *usbep) ;
+	void FifoFinalize() ;
+	void FifoStart() ;
+	void FifoStop() ;
+	static void *OnTSFifoWriteBackBegin(int id, size_t max_size, void *arg) ;
+	static void OnTSFifoWriteBackFinish(int id, size_t wrote_size, void *arg) ;
+	static void OnTSFifoWriteThrough(const void *buffer, size_t size, void *arg) ;
+	static void OnTSFifoPurge(void *arg) ;
+
+protected:
+	// Initializer
+	virtual void InitConstants();
+	virtual const BOOL TryOpenTuner(void) = 0 ;
+	// Registry
+	virtual const TCHAR *RegName() { return NULL ; }
+	// Channels
+	virtual void ReadRegChannels (HKEY hPKey, CHANNELS &regChannels);
+	virtual void ReadIniChannels (const std::string iniFilename, CHANNELS &iniChannels);
+	// Loader
+	virtual void LoadReg();
+	virtual void LoadIni();
+	virtual void LoadValues(const IValueLoader *Loader);
+
+public:
+	// Initializer
+	virtual void Initialize();
+
+public: // inherited
+	// IBonDriver
+	virtual const BOOL OpenTuner(void);
+	virtual const BOOL SetChannel(const BYTE bCh);
+	virtual const DWORD WaitTsStream(const DWORD dwTimeOut = 0);
+	virtual const DWORD GetReadyCount(void);
+	virtual const BOOL GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain);
+	virtual const BOOL GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain);
+	virtual void PurgeTsStream(void);
+	// IBonDriver2
+	virtual LPCTSTR EnumTuningSpace(const DWORD dwSpace);
+	virtual LPCTSTR EnumChannelName(const DWORD dwSpace, const DWORD dwChannel);
+	virtual const BOOL SetChannel(const DWORD dwSpace, const DWORD dwChannel) {return FALSE;}
+	// IBonTransponder
+	virtual LPCTSTR TransponderEnumerate(const DWORD dwSpace, const DWORD dwTransponder) ;
+	virtual const BOOL TransponderSelect(const DWORD dwSpace, const DWORD dwTransponder) {return FALSE;}
+	virtual const BOOL TransponderGetIDList(LPDWORD lpIDList, LPDWORD lpdwNumID) {return FALSE;}
+	virtual const BOOL TransponderSetCurID(const DWORD dwID) {return FALSE;}
+	virtual const BOOL TransponderGetCurID(LPDWORD lpdwID) {return FALSE;}
+protected:
+	CBonFSHybrid(bool hasSatellite=false);
+	virtual ~CBonFSHybrid();
+
+protected:
+	// User Channels
+	CHANNELS m_UserChannels, m_Transponders ;
+	SPACEINDICES m_UserSpaceIndices;
+	SPACENAMES m_SpaceArrangement, m_InvisibleSpaces ;
+	bool m_hasSatellite ;
+	int transponder_index_of(DWORD dwSpace, DWORD dwTransponder) const ;
+	// tsthread
+	tsthread_ptr tsthr;
+	// FIFO
+	CAsyncFifo *m_fifo ;
+	CAsyncFifo::CACHE *m_mapCache[TS_MaxNumIO] ;
+	event_object m_eoCaching ;
+	exclusive_object m_coPurge ;
+
+public:
+	// Instance
+	static CBonFSHybrid *m_pThis;
+	static HINSTANCE m_hModule;
+
+};
+
+template<class T> IBonDriver *BonFSCreate() {
+	if(T::m_pThis) return static_cast<IBonDriver*>(T::m_pThis) ;
+	if(T *bon = new T) { bon->Initialize() ; return static_cast<IBonDriver*>(bon) ; }
+	return 0 ;
+}
+
+} // End of namespace BonHybrid
+
+using namespace BonHybrid ;
+
+//===========================================================================
+#endif // _BONHYBRID_20191229125131957_H_INCLUDED_
diff -uPr BonD_FSHybrid-20201009_org/src/em2874.cpp BonD_FSHybrid-20201009_mod10.1/src/em2874.cpp
--- BonD_FSHybrid-20201009_org/src/em2874.cpp	2012-09-28 01:43:05.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/em2874.cpp	2020-10-11 23:27:12.000000000 +0900
@@ -1,12 +1,9 @@
 #include "stdafx.h"
 #include "em2874.h"
-#include "../twindbg.h"
+#include "message.h"
 #include <setupapi.h>
 #include <strsafe.h>
 
-// hCoCX^XGUID
-DEFINE_GUID( GUID_WINUSB_DRIVER,	0xb35924d6L, 0x3e09, 0x4a9e, 0x97, 0x82, 0x55, 0x24, 0xa4, 0xb7, 0x9b, 0xa4 );
-
 inline uint8_t ICC_checkSum (const uint8_t* data, int len)
 {
 	uint8_t sum = 0;
@@ -16,35 +13,40 @@
 	return sum;
 }
 
-inline void miliWait( int s )
-{
-	::Sleep(s);
-}
-
 unsigned EM2874Device::UserSettings = 0x1;
 
 EM2874Device::EM2874Device ()
-: dev(NULL), usbHandle(NULL), isCardReady(false)
+: dev(NULL), usbHandle(NULL), isCardReady(false), pmutex(NULL)
 #ifdef EM2874_TS
 , hTsEvent(NULL), TsBuffSize(NULL)
 #endif
 {
+#ifdef EM2874_TS
+	ZeroMemory(&IoContext,sizeof(IoContext));
+	ZeroMemory(&TSFifo,sizeof(TSFifo)) ;
+#endif
 }
 
 EM2874Device::EM2874Device(HANDLE hDev)
-: dev(hDev), usbHandle(NULL), isCardReady(false)
+: dev(hDev), usbHandle(NULL), isCardReady(false), pmutex(NULL)
 #ifdef EM2874_TS
 , hTsEvent(NULL), TsBuffSize(NULL)
 #endif
 {
+#ifdef EM2874_TS
+	ZeroMemory(&IoContext,sizeof(IoContext));
+	ZeroMemory(&TSFifo,sizeof(TSFifo)) ;
+#endif
 }
 
 EM2874Device::~EM2874Device ()
 {
+#ifdef EM2874_TS
 	if (hTsEvent) {
 		::CloseHandle(hTsEvent);
 		hTsEvent = NULL;
 	}
+#endif
 	if ( usbHandle ) {
 		writeReg(EM2874_REG_TS_ENABLE, 0);
 		::WinUsb_SetCurrentAlternateSetting( usbHandle, 0 );
@@ -55,75 +57,39 @@
 			writeReg(EM2874_REG_CAS_MODE1, 0x0);
 			writeReg(0x0C, 0x0);
 		}
-		::WinUsb_Free( usbHandle );
 	}
-	if ( this->dev ) {
-		::CloseHandle( this->dev );
+	if(pmutex) {
+		uthread_mutex_destroy(pmutex);
+		pmutex=NULL;
 	}
 }
 
-EM2874Device* EM2874Device::AllocDevice(int &idx)
+EM2874Device* EM2874Device::AllocDevice(HANDLE hDev, HANDLE hUsbDev)
 {
-	DWORD dwRet;
-	ULONG length;
-	
-	HANDLE hDev = INVALID_HANDLE_VALUE;
-
-	// foCXZbg̃nh擾
-	HDEVINFO deviceInfo = SetupDiGetClassDevs((GUID *)&GUID_WINUSB_DRIVER, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
-	if(deviceInfo == INVALID_HANDLE_VALUE) return NULL;
-
-	SP_DEVICE_INTERFACE_DATA interfaceData;
-	interfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
-
-	for(; idx < 20; idx++ ) {
-		// foCXC^tF[X
-		if( FALSE == SetupDiEnumDeviceInterfaces(deviceInfo, NULL, (GUID *)&GUID_WINUSB_DRIVER, idx, &interfaceData) ) {
-			dwRet = ::GetLastError();
-			//if(dwRet == ERROR_NO_MORE_ITEMS) break;
-			break;
-		}
-
-		ULONG requiredLength = 0;
-		SetupDiGetDeviceInterfaceDetail(deviceInfo, &interfaceData, NULL, 0, &requiredLength, NULL);
-		// obt@m
-		requiredLength += sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + sizeof(TCHAR);
-		PSP_DEVICE_INTERFACE_DETAIL_DATA detailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)GlobalAlloc(GMEM_FIXED, requiredLength);
-		detailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
-		// foCX̃pX擾
-		length = requiredLength;
-		if(SetupDiGetDeviceInterfaceDetail(deviceInfo, &interfaceData, detailData, length, &requiredLength, NULL) ) {
-			// path擾
-			hDev = ::CreateFile(detailData->DevicePath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
-			if( hDev == INVALID_HANDLE_VALUE ) {
-				//dwRet = ::GetLastError();
-				//if (dwRet == ERROR_ACCESS_DENIED) gp
-			}else{
-				GlobalFree(detailData);
-				break;
-			}
-		}
-		GlobalFree(detailData);
-	}
-	SetupDiDestroyDeviceInfoList(deviceInfo);
-
-	if (hDev == INVALID_HANDLE_VALUE) return NULL;
+	if (!hDev) return NULL;
 
 	EM2874Device *pDev = new EM2874Device();
 	pDev->dev = hDev;
-	if(! pDev->initDevice()) {
+	if(! pDev->initDevice(hUsbDev)) {
 		delete pDev;
 		return NULL;
 	}
 	return pDev;
 }
 
-bool EM2874Device::initDevice ()
+bool EM2874Device::initDevice (HANDLE hUsbDev)
 {
 	uint8_t val;
 
-	if(FALSE == ::WinUsb_Initialize ( this->dev, &usbHandle ))
+	if (!hUsbDev) return false;
+
+	usbHandle = hUsbDev ;
+
+	if(int ret = uthread_mutex_init(&pmutex)) {
+		warn_info(ret,"failed");
 		return false;
+	}
+
 	if( readReg(EM28XX_REG_GPIO, &val) && writeReg(EM28XX_REG_GPIO, val & ~0x1U)
 	){
 		{
@@ -157,6 +123,7 @@
 		writeReg(0x1f, 0);
 		writeReg(0x1b, 0);
 		writeReg(0x5e, 128);
+
 		writeReg( EM2874_REG_TS_ENABLE, 0 );
 		return true;
 	}
@@ -169,7 +136,7 @@
 	uint8_t val;
 	readReg(EM28XX_REG_GPIO, &val);
 	writeReg( EM28XX_REG_GPIO, ~0xc1U & val );
-	
+
 	miliWait(70);
 	readReg(EM28XX_REG_GPIO, &val);
 	writeReg( EM28XX_REG_GPIO, 0x40U | val );
@@ -178,9 +145,99 @@
 	miliWait(3);
 	::WinUsb_SetCurrentAlternateSetting( usbHandle, 1 );
 
+
 	return true;
 }
 
+BOOL EM2874Device::DoUSBCtrlTransfer(
+  WINUSB_SETUP_PACKET     SetupPacket,
+  PUCHAR                  Buffer,
+  ULONG                   BufferLength,
+  PULONG                  LengthTransferred,
+  LPOVERLAPPED            Overlapped,
+  DWORD                   &LastError
+)
+{
+	if(int r = uthread_mutex_lock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_lock failed");
+		return FALSE;
+	}
+	BOOL res = WinUsb_ControlTransfer(
+		usbHandle,
+		SetupPacket,
+		Buffer,
+		BufferLength,
+		LengthTransferred,
+		Overlapped
+	);
+	LastError = GetLastError() ;
+	if(int r = uthread_mutex_unlock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_unlock failed");
+		return FALSE;
+	}
+	return res ;
+}
+
+#ifdef EM2874_TS
+BOOL EM2874Device::DoUSBReadPipe(
+  PUCHAR                  Buffer,
+  ULONG                   BufferLength,
+  PULONG                  LengthTransferred,
+  LPOVERLAPPED            Overlapped,
+  DWORD                   &LastError
+)
+{
+	if(int r = uthread_mutex_lock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_lock failed");
+		return FALSE;
+	}
+	BOOL res = WinUsb_ReadPipe(
+		usbHandle, EM2874_EP_TS1,
+		Buffer,
+		BufferLength,
+		LengthTransferred,
+		Overlapped
+	);
+	LastError = GetLastError() ;
+	if(int r = uthread_mutex_unlock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_unlock failed");
+		return FALSE;
+	}
+	return res ;
+}
+
+BOOL EM2874Device::DoUSBGetOverlappedResult(
+  LPOVERLAPPED            Overlapped,
+  LPDWORD                 NumberOfBytesTransferred,
+  BOOL                    Wait,
+  DWORD                   &LastError
+)
+{
+	if(int r = uthread_mutex_lock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_lock failed");
+		return FALSE;
+	}
+	BOOL res = WinUsb_GetOverlappedResult(
+		usbHandle,
+		Overlapped,
+		NumberOfBytesTransferred,
+		Wait
+	);
+	LastError = GetLastError() ;
+	if(int r = uthread_mutex_unlock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_unlock failed");
+		return FALSE;
+	}
+	return res ;
+}
+#endif
+
 uint8_t EM2874Device::readReg (const uint8_t idx)
 {
 	uint8_t val;
@@ -196,10 +253,10 @@
 	spkt.Index = idx;
 	spkt.Length = 1;
 
-	ULONG ret;
-	BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)val, 1, &ret, NULL );
+	ULONG ret; DWORD err ;
+	BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)val, 1, &ret, NULL , err );
 	if( !bRet ) {
-		DBG_INFO ( "readReg LastError=%08x\n", GetLastError() );
+		DBG_INFO ( "readReg LastError=%08x\n", err );
 	}
 	return (ret == 1) && bRet;
 }
@@ -212,14 +269,32 @@
 	spkt.Index = idx;
 	spkt.Length = 1;
 
-	ULONG ret;
-	BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)&val, 1, &ret, NULL );
+	ULONG ret; DWORD err ;
+	BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)&val, 1, &ret, NULL , err );
 	if( !bRet ) {
-		DBG_INFO ( "writeReg LastError=%08x\n", GetLastError() );
+		DBG_INFO ( "writeReg LastError=%08x\n", err );
 	}
 	return (ret == 1) && bRet;
 }
 
+int EM2874Device::ctrlReg(const uint16_t reg, const uint16_t size, uint8_t* const data, const unsigned mode)
+{
+	WINUSB_SETUP_PACKET spkt;
+
+	ZeroMemory ( &spkt, sizeof(spkt) );
+	spkt.RequestType = (mode & 0x1) ? 0x40 : 0xc0;
+	spkt.Request = (mode >> 8) & 0xFF;
+	spkt.Index = reg;
+	spkt.Length = size;
+
+	ULONG ret; DWORD err;
+	if(! DoUSBCtrlTransfer ( spkt, (PUCHAR)data, size, (PULONG)&ret, NULL , err ) ) {
+		warn_info(err,"%02X_%02X", (mode >> 8) & 0xFF, reg);
+		return err;
+	}
+	return 0;
+}
+
 bool EM2874Device::readI2C (const uint8_t addr, const uint16_t size, uint8_t *data, const bool isStop)
 {
 	WINUSB_SETUP_PACKET spkt;
@@ -229,10 +304,10 @@
 	spkt.Index = addr;
 	spkt.Length = size;
 
-	ULONG ret;
-	BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)data, spkt.Length, &ret, NULL );
+	ULONG ret; DWORD err ;
+	BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)data, spkt.Length, &ret, NULL , err );
 	if( !bRet ) {
-		DBG_INFO ( "readI2C LastError=%08x\n", GetLastError() );
+		DBG_INFO ( "readI2C LastError=%08x\n", err );
 		return false;
 	}
 	readReg( 0x05, (uint8_t*)&ret );
@@ -252,10 +327,10 @@
 	spkt.Index = addr;
 	spkt.Length = size;
 
-	ULONG ret;
-	BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)data, spkt.Length, &ret, NULL );
+	ULONG ret; DWORD err;
+	BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)data, spkt.Length, &ret, NULL, err );
 	if( !bRet ) {
-		DBG_INFO ( "writeI2C LastError=%08x\n", GetLastError() );
+		DBG_INFO ( "writeI2C LastError=%08x\n", err );
 		return false;
 	}
 	readReg( 0x05, (uint8_t*)&ret );
@@ -293,11 +368,11 @@
 	spkt.Index = 0x200;
 
 	static UCHAR cmd[] = { 0x00, 0xc1, 0x01, 0xfe, 0x3e };
-	ULONG ret;
+	ULONG ret; DWORD err;
 	spkt.Length = sizeof(cmd);
-	BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, cmd, sizeof(cmd), &ret, NULL );
+	BOOL bRet = DoUSBCtrlTransfer ( spkt, cmd, sizeof(cmd), &ret, NULL, err );
 	if( !bRet ) {
-		DBG_INFO ( "writeICC LastError=%08x\n", GetLastError() );
+		DBG_INFO ( "writeICC LastError=%08x\n", err );
 		return false;
 	}
 
@@ -310,7 +385,8 @@
 
 	spkt.RequestType = 0xc0;
 	spkt.Index = 0;
-	bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, rbuff, 4, &ret, NULL );
+	DWORD err;
+	bRet = DoUSBCtrlTransfer ( spkt, rbuff, 4, &ret, NULL, err );
 	if( !bRet || rbuff[1] != 0xe1 || rbuff[3] != 0xfe )
 		return false;
 	cardPCB = 0;
@@ -355,10 +431,11 @@
 		spkt.Index = 0x200 + i;
 		spkt.Length = (val - i) > 64 ? 64 : (val - i);
 
-		BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)(cardBuf+i)
-			, spkt.Length, &ret, NULL );
+		DWORD err;
+		BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)(cardBuf+i)
+			, spkt.Length, &ret, NULL, err );
 		if( !bRet ) {
-			DBG_INFO ( "writeICC LastError=%08x\n", GetLastError() );
+			DBG_INFO ( "writeICC LastError=%08x\n", err );
 			return false;
 		}
 	}
@@ -391,10 +468,11 @@
 		spkt.Index = i;
 		spkt.Length = (val - i) > 64 ? 64 : (val - i);
 
-		BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)(cardBuf+i)
-			, spkt.Length, &ret, NULL );
+		DWORD err;
+		BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)(cardBuf+i)
+			, spkt.Length, &ret, NULL, err );
 		if( !bRet ) {
-			DBG_INFO ( "readICC LastError=%08x\n", GetLastError() );
+			DBG_INFO ( "readICC LastError=%08x\n", err );
 			return false;
 		}
 	}
@@ -413,9 +491,9 @@
 		if( val == 5 ) {
 			return i;
 		}
-		if( val == 0 ) return -1;	// card error
+		if( val == 0 ) return -1;   // card error
 	}
-	return -2;	// timeout
+	return -2;  // timeout
 }
 
 int EM2874Device::getCardStatus()
@@ -434,7 +512,7 @@
 	unsigned val;
 	// ROMŔf
 	writeReg(EM28XX_REG_I2C_CLK, 0x42);
-	buf[0] = 0; buf[1] = 0x6a;	writeI2C(EEPROM_ADDR, 2, buf, false);
+	buf[0] = 0; buf[1] = 0x6a;  writeI2C(EEPROM_ADDR, 2, buf, false);
 	if(!readI2C (EEPROM_ADDR, 2, buf, true))
 		return -1;
 	val = *(uint16_t*)buf;
@@ -444,14 +522,14 @@
 
 	// Tuner RegŔf
 	writeReg(EM28XX_REG_I2C_CLK, 0x44);
-	val = 0x00fe;	writeI2C(DEMOD_ADDR, 2, (uint8_t*)&val, true);
+	val = 0x00fe;   writeI2C(DEMOD_ADDR, 2, (uint8_t*)&val, true);
 	tuner_reg = 0x0;
 	writeI2C(TUNER_ADDR, 1, &tuner_reg, false);
 	readI2C (TUNER_ADDR, 1, &tuner_reg, true);
 	DBG_INFO ("Tuner=%02X ",tuner_reg);
-	val = 0x01fe;	writeI2C(DEMOD_ADDR, 2, (uint8_t*)&val, true);
+	val = 0x01fe;   writeI2C(DEMOD_ADDR, 2, (uint8_t*)&val, true);
 
-	if(tuner_reg == 0x84)	// TDA18271HD
+	if(tuner_reg == 0x84)   // TDA18271HD
 		return 1;
 
 	return 2;
@@ -459,7 +537,12 @@
 
 #ifdef EM2874_TS
 
-void EM2874Device::SetBuffer(void *pBuf)
+bool EM2874Device::WriteBackEnabled()
+{
+	return TSFifo.begin_func && TSFifo.finish_func ;
+}
+
+void EM2874Device::SetBuffer(void *pBuf, const struct tsfifo_t * const pTSFifo)
 {
 	TsBuffSize = (int32_t*)pBuf;
 	if(pBuf) {
@@ -467,13 +550,17 @@
 
 		TsBuffSize[RINGBUFF_SIZE] = -2;
 		TsBuffSize[0x3ff] = -USBBULK_XFERSIZE;
+	}else TsBuff = NULL ;
+	ZeroMemory(&TSFifo,sizeof(TSFifo)) ;
+	if(pTSFifo) {
+	  CopyMemory(&TSFifo,pTSFifo,sizeof(TSFifo)) ;
 	}
 }
 
 bool EM2874Device::TransferStart()
 {
-	if(TsBuffSize == NULL)	return false;
-	if(hTsEvent)	return true;
+	if(TsBuffSize == NULL&&!WriteBackEnabled()) return false;
+	if(hTsEvent)    return true;
 
 	if( readReg(0x0B) & 0x2 ) {
 		// Isochronous]ݒȂ  (Ŏ~߂ȂƁA낢뎀ʁB)
@@ -510,12 +597,14 @@
 {
 	writeReg( EM2874_REG_TS_ENABLE, 0 );
 	if(hTsEvent == NULL) return;
-	::WinUsb_AbortPipe( usbHandle, EM2874_EP_TS1 );
+	if(!(readReg(0x0B)&0x2))
+		::WinUsb_AbortPipe( usbHandle, EM2874_EP_TS1 );
 }
 
 void EM2874Device::TransferResume()
 {
-	writeReg( EM2874_REG_TS_ENABLE, EM2874_TS1_CAPTURE_ENABLE | EM2874_TS1_NULL_DISCARD );
+	writeReg( EM2874_REG_TS_ENABLE,
+		EM2874_TS1_CAPTURE_ENABLE | EM2874_TS1_NULL_DISCARD );
 	if(hTsEvent != NULL) {
 		::SetEvent(hTsEvent);
 	}
@@ -525,16 +614,20 @@
 {
 	int nRet;
 	int cnt;
-	for(cnt = 0; ; cnt++) {
+	for(cnt = 0; cnt<NUM_IOHANDLE ; cnt++) {
 		nRet = GetOverlappedResult();
 		if(nRet == -1) {
 			// TS] ҂
 			break;
 		}else if(nRet >= 0) {
 			// TS] ̓]v
-			BeginAsyncRead();
-			if(OverlappedIoIndex < (NUM_IOHANDLE-1)) OverlappedIoIndex++;
-			else OverlappedIoIndex = 0;
+			if(BeginAsyncRead()) {
+				if(OverlappedIoIndex < (NUM_IOHANDLE-1)) OverlappedIoIndex++;
+				else OverlappedIoIndex = 0;
+			}else {
+				// obt@s
+				break ;
+			}
 		}else{
 			// TS] I
 			return -1;
@@ -544,20 +637,28 @@
 	return cnt;
 }
 
-int EM2874Device::BeginAsyncRead()
+bool EM2874Device::BeginAsyncRead()
 {
-	DWORD dRet = TsBuffIndex;
-	TsBuffIndex = (dRet < (RINGBUFF_SIZE-1)) ? dRet + 1 : 0;
-
-	TsBuffSize[dRet] = -1;
-	IoContext[OverlappedIoIndex].index = dRet;
+	DWORD dRet ;
 
 	::ZeroMemory(&IoContext[OverlappedIoIndex].ol, sizeof(OVERLAPPED));
 	IoContext[OverlappedIoIndex].ol.hEvent = hTsEvent;
 
-	BOOL bRet = ::WinUsb_ReadPipe ( usbHandle, EM2874_EP_TS1, TsBuff + dRet*USBBULK_XFERSIZE, USBBULK_XFERSIZE, NULL, &IoContext[OverlappedIoIndex].ol );
+	BOOL bRet ; DWORD err ;
+	if(WriteBackEnabled()) {
+		IoContext[OverlappedIoIndex].index = OverlappedIoIndex ;
+		void *buffer = TSFifo.begin_func(OverlappedIoIndex, USBBULK_XFERSIZE, TSFifo.arg) ;
+		if(!buffer) return false ;
+		bRet = DoUSBReadPipe ( (BYTE*)buffer, USBBULK_XFERSIZE, NULL, &IoContext[OverlappedIoIndex].ol, err );
+	}else if(TsBuff) {
+		dRet = TsBuffIndex ;
+		TsBuffIndex = (dRet < (RINGBUFF_SIZE-1)) ? dRet + 1 : 0;
+		TsBuffSize[dRet] = -1;
+		IoContext[OverlappedIoIndex].index = dRet;
+		bRet = DoUSBReadPipe ( TsBuff + dRet*USBBULK_XFERSIZE, USBBULK_XFERSIZE, NULL, &IoContext[OverlappedIoIndex].ol, err );
+	}else return false ;
 #if 0
-	dRet = ::GetLastError();
+	dRet = err ;
 	if( bRet == FALSE && dRet != ERROR_IO_PENDING ) DBG_INFO ("ReadP=%u ",dRet);
 	if( bRet ) {
 		DBG_INFO ("ReadPs=%u ",dRet);
@@ -567,16 +668,15 @@
 		// NOWAITŊ
 		::SetEvent(hTsEvent);
 	}
-	return 0;
+	return true;
 }
 
 int EM2874Device::GetOverlappedResult()
 {
 	if(hTsEvent == NULL) return -2;
-	ULONG bytesRead = 0;
-	if(FALSE == ::WinUsb_GetOverlappedResult ( usbHandle, &IoContext[OverlappedIoIndex].ol, &bytesRead, FALSE )) {
-		DWORD dwRet = ::GetLastError();
-		switch(dwRet) {
+	ULONG bytesRead = 0; DWORD err ;
+	if(FALSE == DoUSBGetOverlappedResult ( &IoContext[OverlappedIoIndex].ol, &bytesRead, FALSE, err )) {
+		switch(err) {
 			case ERROR_SEM_TIMEOUT:
 			case ERROR_OPERATION_ABORTED:
 				DBG_INFO ("RdAbort%u ",bytesRead);
@@ -589,13 +689,106 @@
 				break;
 		}
 	}
-	if(TsBuffSize == NULL) return -2;
-	const unsigned idx = IoContext[OverlappedIoIndex].index;
-	TsBuffSize[idx] = bytesRead;
+	if(WriteBackEnabled()) {
+		TSFifo.finish_func(OverlappedIoIndex,bytesRead,TSFifo.arg) ;
+	}else {
+		if(TsBuffSize == NULL) return -2;
+		const unsigned idx = IoContext[OverlappedIoIndex].index;
+		TsBuffSize[idx] = bytesRead;
+	}
+
 	return bytesRead;
 }
 
 HANDLE EM2874Device::GetHandle()
 { return hTsEvent; }
 
+int EM2874Device::GetTsBuffIndex()
+{ return TsBuffIndex; }
+
+#endif
+
+#ifdef EM2874_USBEP
+
+extern "C" int TSCACHING_DROPNULLPACKETS ;
+int EM2874Device::USBEndPointStartStopFunc(void * const  dev, const int start)
+{
+	EM2874Device *this_ = static_cast<EM2874Device*>(dev) ;
+	if(start) {
+		this_->writeReg( EM2874_REG_TS_ENABLE, EM2874_TS1_CAPTURE_ENABLE |
+			( TSCACHING_DROPNULLPACKETS ? EM2874_TS1_NULL_DISCARD : 0 ) );
+	}else {
+		this_->writeReg( EM2874_REG_TS_ENABLE, 0 );
+	}
+	return 0 ;
+}
+
+int EM2874Device::USBEndPointLockUnlockFunc(void * const  dev, const int lock)
+{
+	EM2874Device *this_ = static_cast<EM2874Device*>(dev) ;
+	int r ;
+	if(lock) {
+		r = uthread_mutex_lock(this_->pmutex) ;
+	}else {
+		r = uthread_mutex_unlock(this_->pmutex) ;
+	}
+	if(r) warn_info(r,"failed");
+	return r;
+}
+
+extern "C" int TSCACHING_BULKPACKETSIZE;
+void EM2874Device::SetupUSBEndPoint(usb_endpoint_st *usb_ep)
+{
+	usb_ep->dev=this ;
+	usb_ep->fd=usbHandle ;
+	usb_ep->endpoint = EM2874_EP_TS1 ;
+	if( readReg(0x0B)&0x2 ) usb_ep->endpoint |= 0x100 /*ISOCH*/ ;
+#if 1
+	if( usb_ep->endpoint&0x100 ) { /* Isochronous (ύXK0905) */
+		int n=
+		#ifdef INCLUDE_ISOCH_XFER
+		ISOCH_FrameSize/188
+		#else
+		5
+		#endif
+		;
+		//# set Isochronous transfer size (unit: packet)
+		writeReg(0x5e, (uint8_t)(n) );
+		usb_ep->xfer_size = n * 188UL ;
+	}else { /* BULK (PatchV2Kp) */
+		int packet_size = TSCACHING_BULKPACKETSIZE>0 ?
+			TSCACHING_BULKPACKETSIZE : TS_PacketSize ;
+		int n = packet_size/188 ;
+		if(n>=256) n=256 ; else if(n<=0) n=1 ;
+		//# set BULK transfer size (unit: packet)
+		writeReg(0x5d, (uint8_t)(n - 1) );
+		usb_ep->xfer_size = n>=256 ? packet_size : n * 188UL ;
+	}
+#else
+	#ifdef INCLUDE_ISOCH_XFER
+		usb_ep->xfer_size = usb_ep->endpoint&0x100 ?
+			ISOCH_FrameSize/*ύXK0905*/: TS_PacketSize/*PatchV2Kp*/;
+	#else
+		usb_ep->xfer_size = TS_PacketSize ;
+	#endif
 #endif
+	usb_ep->startstopFunc = USBEndPointStartStopFunc;
+	usb_ep->lockunlockFunc = USBEndPointLockUnlockFunc;
+}
+
+void EM2874Device::CleanupUSBEndPoint(usb_endpoint_st *usb_ep)
+{
+	if (usb_ep&&usb_ep->dev == this) {
+		if(usb_ep->startstopFunc==USBEndPointStartStopFunc)
+			USBEndPointStartStopFunc(this, 0);
+		usb_ep->dev = NULL;
+		usb_ep->fd = NULL;
+		usb_ep->endpoint = 0;
+		usb_ep->xfer_size = 0;
+		usb_ep->startstopFunc = NULL;
+		usb_ep->lockunlockFunc = NULL ;
+	}
+}
+
+#endif
+
diff -uPr BonD_FSHybrid-20201009_org/src/em2874.h BonD_FSHybrid-20201009_mod10.1/src/em2874.h
--- BonD_FSHybrid-20201009_org/src/em2874.h	2012-09-28 01:32:17.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/em2874.h	2020-10-06 04:54:40.000000000 +0900
@@ -1,6 +1,9 @@
 #pragma once
 
 #include <WinUSB.h>
+extern "C" {
+#include "osdepend.h"
+}
 
 typedef unsigned char	uint8_t;
 typedef unsigned short	uint16_t;
@@ -28,34 +31,80 @@
 #define EM2874_TS1_FILTER_ENABLE  0x02
 #define EM2874_TS1_NULL_DISCARD   0x04
 
-#define EM2874_TS
+//#define EM2874_TS
 
 #ifdef EM2874_TS
-#define USBBULK_XFERSIZE	(0xBC00)
-#define RINGBUFF_SIZE	60
-#define NUM_IOHANDLE	16
+	#define USBBULK_XFERSIZE	(0xBC00)
+	#define RINGBUFF_SIZE	48
+	#define NUM_IOHANDLE	36
 #endif
 
+#define EM2874_USBEP
+
+#ifdef EM2874_USBEP
+extern "C" {
+#include "types_u.h"
+#include "tsbuff.h"
+}
+#endif
+
+
 typedef struct _TSIO_CONTEXT {
 
-    OVERLAPPED ol;
+	OVERLAPPED ol;
 	unsigned index;
 
 } TSIO_CONTEXT;
 
 class EM2874Device
 {
+#ifdef EM2874_TS
+public:
+	typedef void *(*write_back_begin_func_t)(int id, size_t max_size, void *arg) ;
+	typedef void (*write_back_finish_func_t)(int id, size_t wrote_size, void *arg) ;
+	struct tsfifo_t {
+		write_back_begin_func_t begin_func;
+		write_back_finish_func_t finish_func;
+		void *arg;
+	};
+#endif
 private:
 	EM2874Device ();
 	bool resetICC_1 ();
 	bool resetICC_2 ();
-	
+
 	HANDLE dev;
 	WINUSB_INTERFACE_HANDLE usbHandle;
 	uint8_t cardPCB;
 
+	PMUTEX pmutex;
+
+	BOOL DoUSBCtrlTransfer(
+	  WINUSB_SETUP_PACKET     SetupPacket,
+	  PUCHAR                  Buffer,
+	  ULONG                   BufferLength,
+	  PULONG                  LengthTransferred,
+	  LPOVERLAPPED            Overlapped,
+	  DWORD                   &LastError
+	);
+
 #ifdef EM2874_TS
-	int BeginAsyncRead();
+	BOOL DoUSBReadPipe(
+	  PUCHAR                  Buffer,
+	  ULONG                   BufferLength,
+	  PULONG                  LengthTransferred,
+	  LPOVERLAPPED            Overlapped,
+	  DWORD                   &LastError
+	);
+
+	BOOL DoUSBGetOverlappedResult(
+	  LPOVERLAPPED            Overlapped,
+	  LPDWORD                 NumberOfBytesTransferred,
+	  BOOL                    Wait,
+	  DWORD                   &LastError
+	);
+
+	bool BeginAsyncRead();
 	int GetOverlappedResult();
 
 	uint8_t *TsBuff;
@@ -64,19 +113,21 @@
 	int OverlappedIoIndex;
 	HANDLE hTsEvent;
 	TSIO_CONTEXT IoContext[NUM_IOHANDLE];
+	tsfifo_t TSFifo ;
 	DWORD dwtLastRead;
 #endif
 
 public:
 	EM2874Device (HANDLE hDev);
 	~EM2874Device ();
-	static EM2874Device* AllocDevice(int &idx);
-	bool initDevice ();
+	static EM2874Device* AllocDevice(HANDLE hDev,HANDLE hUsbDev);
+	bool initDevice (HANDLE hUsbDev);
 	bool initDevice2 ();
 
 	uint8_t readReg (const uint8_t idx);
 	bool readReg (const uint8_t idx, uint8_t *val);
 	bool writeReg (const uint8_t idx, const uint8_t val);
+	int ctrlReg(const uint16_t reg, const uint16_t size, uint8_t* const data, const unsigned mode);
 	bool readI2C (const uint8_t addr, const uint16_t size, uint8_t *data, const bool isStop);
 	bool writeI2C (const uint8_t addr, const uint16_t size, uint8_t *data, const bool isStop);
 
@@ -93,12 +144,21 @@
 	static unsigned UserSettings;
 
 #ifdef EM2874_TS
-	void SetBuffer(void *pBuf);
+	bool WriteBackEnabled() ;
+	void SetBuffer(void *pBuf, const struct tsfifo_t * const pTSFifo=NULL);
 	bool TransferStart();
 	void TransferStop();
 	void TransferPause();
 	void TransferResume();
 	int DispatchTSRead();
 	HANDLE GetHandle();
+	int GetTsBuffIndex();
+#endif
+
+#ifdef EM2874_USBEP
+	static int USBEndPointStartStopFunc(void * const  dev, const int start);
+	static int USBEndPointLockUnlockFunc(void * const  dev, const int lock);
+	void SetupUSBEndPoint(usb_endpoint_st *usb_ep) ;
+	void CleanupUSBEndPoint(usb_endpoint_st *usb_ep) ;
 #endif
 };
diff -uPr BonD_FSHybrid-20201009_org/src/em287x.c BonD_FSHybrid-20201009_mod10.1/src/em287x.c
--- BonD_FSHybrid-20201009_org/src/em287x.c	2016-02-10 04:35:36.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/em287x.c	2020-10-11 23:26:56.000000000 +0900
@@ -14,6 +14,7 @@
 #include "em287x_usb.h"
 #include "em287x_priv.h"
 #include "message.h"
+#include "tsbuff.h"
 
 #define ARRAY_SIZE(x)  (sizeof(x)/(sizeof(x[0])))
 
@@ -240,6 +241,7 @@
 
 /* public function */
 
+extern int TSCACHING_BULKPACKETSIZE;
 int em287x_create(em287x_state* const  state, struct usb_endpoint_st * const pusbep)
 {
 	int ret;
@@ -263,6 +265,7 @@
 	pusbep->endpoint = EP_TS1;
 	pusbep->dev = st;
 	pusbep->startstopFunc = em287x_startstopStream;
+	pusbep->lockunlockFunc = em287x_lockunlockMutex;
 	st->chip_id = 0;
 	st->fd = pusbep->fd;
 	if(( ret = usb_claim(st->fd, 0) )) {
@@ -281,14 +284,25 @@
 	//# TS endpoint
 	if(( ret = readReg(st, 0x0b, &utmp) ))  { warn_info(ret,"failed"); return -8; }
 	if( utmp & 0x02 ) {
+		int n=
+		#ifdef INCLUDE_ISOCH_XFER
+		ISOCH_FrameSize/188
+		#else
+		5
+		#endif
+		;
 		//# set Isochronous transfer size (unit: packet)
-		if(( ret = writeReg(st, 0x5e, 5 ) ))  { warn_info(ret,"failed"); return -8; }
+		if(( ret = writeReg(st, 0x5e, (uint8_t)(n) ) ))  { warn_info(ret,"failed"); return -8; }
 		pusbep->endpoint |= 0x100;
-		pusbep->xfer_size = 188 * 5;
+		pusbep->xfer_size = n * 188UL ;
 	}else{
+		int packet_size = TSCACHING_BULKPACKETSIZE>0 ?
+			TSCACHING_BULKPACKETSIZE : TS_PacketSize ;
+		int n = packet_size/188 ;
+		if(n>=256) n=256 ; else if(n<=0) n=1 ;
 		//# set BULK transfer size (unit: packet)
-		if(( ret = writeReg(st, 0x5d, 245 - 1 ) ))  { warn_info(ret,"failed"); return -8; }
-		pusbep->xfer_size = 188 * 245;
+		if(( ret = writeReg(st, 0x5d, (uint8_t)(n - 1) ) ))  { warn_info(ret,"failed"); return -8; }
+		pusbep->xfer_size = n>=256 ? packet_size : n * 188UL ;
 	}
 
 	dmsg(" em287x init done!");
@@ -328,6 +342,7 @@
 	i2c_dev->i2c_comm = (void*)em287x_I2C;
 }
 
+extern int TSCACHING_DROPNULLPACKETS ;
 int em287x_startstopStream(const em287x_state state, const int start)
 {
 	int r;
@@ -337,7 +352,7 @@
 		r = readReg(s, 0x5f, &utmp);
 		if( r ) { warn_info(r,"failed");  return -5; }
 		if(utmp & 0x08) { warn_msg(0,"TS encrypt detected!"); }
-		utmp = (utmp & 0xF0) | 0x05;
+		utmp = (utmp & 0xF0) | 0x01 | (TSCACHING_DROPNULLPACKETS?0x04:0) ;
 		r = em287x_ctrl(s->fd, 0x785f, 1, &utmp, 0x1401);
 		if( r ) { warn_info(r,"failed");  return -6; }
 	}else{  //# stop
@@ -347,6 +362,21 @@
 	return 0;
 }
 
+int em287x_lockunlockMutex(const em287x_state state, const int lock)
+{
+	int r = 0;
+	struct state_st* const s = state;
+
+	if(lock) {
+		if((r = uthread_mutex_lock(s->pmutex))) goto err1 ;
+	}else {
+		if((r = uthread_mutex_unlock(s->pmutex))) goto err1 ;
+	}
 
+	return 0;
+err1:
+	warn_info(r,"failed");
+	return r;
+}
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/em287x.h BonD_FSHybrid-20201009_mod10.1/src/em287x.h
--- BonD_FSHybrid-20201009_org/src/em287x.h	2016-01-18 20:58:56.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/em287x.h	2020-04-27 00:44:36.000000000 +0900
@@ -4,7 +4,16 @@
   2016-01-18
 */
 #pragma once
+#ifdef LEGACY_STDINT
+
+#include "stdint_.h"
+
+#else
+
 #include <stdint.h>
+
+#endif
+
 #include "types_u.h"
 
 typedef void* em287x_state;
@@ -13,5 +22,6 @@
 int em287x_destroy(const em287x_state);
 void em287x_attach(const em287x_state, struct i2c_device_st* const);
 int em287x_startstopStream(const em287x_state, const int start);
+int em287x_lockunlockMutex(const em287x_state state, const int lock);
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/em287x_usb.h BonD_FSHybrid-20201009_mod10.1/src/em287x_usb.h
--- BonD_FSHybrid-20201009_org/src/em287x_usb.h	2016-01-22 08:51:48.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/em287x_usb.h	2019-12-16 06:15:18.000000000 +0900
@@ -4,8 +4,17 @@
   2016-01-22
 */
 #pragma once
+#ifdef LEGACY_STDINT
+
+#include "stdint_.h"
+
+#else
+
 #include <stdint.h>
 
+#endif
+
+
 #define USB_TIMEOUT 400   //# USB ctrl timeout (msec)
 
 int em287x_ctrl(HANDLE fd, const uint16_t reg, const uint16_t size, uint8_t* const data, const unsigned mode);
diff -uPr BonD_FSHybrid-20201009_org/src/inc/IBonDriver3.h BonD_FSHybrid-20201009_mod10.1/src/inc/IBonDriver3.h
--- BonD_FSHybrid-20201009_org/src/inc/IBonDriver3.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/inc/IBonDriver3.h	2012-03-17 11:06:12.000000000 +0900
@@ -0,0 +1,25 @@
+// IBonDriver3.h: IBonDriver3 NX̃C^[tFCX
+//
+/////////////////////////////////////////////////////////////////////////////
+
+#pragma once
+
+
+#include "IBonDriver2.h"
+
+
+/////////////////////////////////////////////////////////////////////////////
+// BonhCoC^tF[X3
+/////////////////////////////////////////////////////////////////////////////
+
+class IBonDriver3 : public IBonDriver2
+{
+public:
+// IBonDriver3
+	virtual const DWORD GetTotalDeviceNum(void) = 0;
+	virtual const DWORD GetActiveDeviceNum(void) = 0;
+	virtual const BOOL SetLnbPower(const BOOL bEnable) = 0;
+	
+// IBonDriver
+	virtual void Release(void) = 0;
+};
diff -uPr BonD_FSHybrid-20201009_org/src/inc/IBonTransponder.h BonD_FSHybrid-20201009_mod10.1/src/inc/IBonTransponder.h
--- BonD_FSHybrid-20201009_org/src/inc/IBonTransponder.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/inc/IBonTransponder.h	2022-04-26 10:42:46.000000000 +0900
@@ -0,0 +1,75 @@
+// IBonTransponder.h: IBonTransponder NX̃C^[tFCX
+//
+//////////////////////////////////////////////////////////////////////
+
+#if !defined(_IBONTRANSPONDER_H_)
+#define _IBONTRANSPONDER_H_
+
+#if _MSC_VER > 1000
+#pragma once
+#endif // _MSC_VER > 1000
+
+// }gX|_C^[tFCX (TSIDɂ`[jO@\܂Ƃ߂)
+class IBonTransponder
+{
+public:
+
+	// ňĂIDƂ́AgX|[gXg[ID(TSID)̂Ƃ\
+
+	// gX|_񋓂
+	//   Xy[X͈̔͂́AIBonDriver2::EnumTuningSpace Ŏ擾̂łɓ
+	//   dwTranspondeŕA0`w肵NULLԂ܂ł͈̔͂ŗL
+	virtual LPCTSTR TransponderEnumerate(const DWORD dwSpace, const DWORD dwTransponder) = 0;
+
+	// ݂̃Xy[XƌsgX|_I
+	//   Xy[X͈̔͂́AIBonDriver2::EnumTuningSpace Ŏ擾̂łɓ
+	//   dwTranspondeŕA0`w肵FALSEԂ܂ł͈̔͂ŗL
+	//   gX|_fR[_̂LłȂinfWȂǁjꍇ́AFALSEԂ
+	virtual const BOOL TransponderSelect(const DWORD dwSpace, const DWORD dwTransponder) = 0;
+
+	// ݂̃gX|_fR[_ݒłXg[ID̈ꗗ擾
+	//  lpIDList  NULLw:
+	//    *lpdwNumIDɊ蓖ĂɕKvȃXg[(default:8)Ԃ
+	//  ȊO:
+	//    lpIDListzIDXg,*lpdwNumIDɎ擾ZbgĕԂ
+	//   ݕĂȂXg[ɂ́A0xFFFFFFFF 邱ƂƂ
+	//   gX|_fR[_̂LłȂinfWȂǁjꍇ́AFALSEԂ
+	virtual const BOOL TransponderGetIDList(LPDWORD lpIDList, LPDWORD lpdwNumID) = 0;
+
+	// sgX|_̃fR[hΏۃXg[IDݒ肷
+	//   gX|_fR[_̂LłȂinfWȂǁjꍇ́AFALSEԂ
+	virtual const BOOL TransponderSetCurID(const DWORD dwID) = 0;
+
+	// fR[hΏۃXg[IDsgX|_̃fR[_擾
+	//   AXg[ȏꍇɂ́A0xFFFFFFFF  *lpdwID ɑ
+	//   gX|_fR[_̂LłȂinfWȂǁjꍇ́AFALSEԂ
+	virtual const BOOL TransponderGetCurID(LPDWORD lpdwID) = 0;
+
+	//  TransponderSelect Ă΂ă`lύXꂽꍇA
+	//    IBonDriver2::GetCurChannel ́A`lԍł͂ȂA
+	//    Transponder̃CfbNX 0x80000000 }XN̂Ԃ
+	//
+	//    ܂AIBonDriver2::GetCurChannelŌ݂̑IǏԂc\
+	//
+	//    EIBonDriver2::GetCurChannel̕ԋpl31rbgڂĂȂ
+	//       IBonDriver::SetChannel/IBonDriver2::SetChannelŃ`lؑւĂ
+	//
+	//    EIBonDriver2::GetCurChannel̕ԋpl31rbgڂĂ
+	//       TransponderSelectŃ`lؑւĂ
+	//        0`30rbg̓`lԍł͂ȂATransponder̃CfbNXӖ
+
+};
+
+// gX|_̃`l}XN
+// (gX|_Iɂ̒l݂̃`lɃ}XN)
+#define TRANSPONDER_CHMASK 0x80000000
+
+#include "IBonDriver2.h"
+// }(hCo2+gX|_)C^[tFCX
+class IBonDriver2Transponder : public IBonDriver2, public IBonTransponder {};
+
+#include "IBonDriver3.h"
+// }(hCo3+gX|_)C^[tFCX
+class IBonDriver3Transponder : public IBonDriver3, public IBonTransponder {};
+
+#endif // !defined(_IBONTRANSPONDER_H_)
diff -uPr BonD_FSHybrid-20201009_org/src/inc/legacy/stdint_.h BonD_FSHybrid-20201009_mod10.1/src/inc/legacy/stdint_.h
--- BonD_FSHybrid-20201009_org/src/inc/legacy/stdint_.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/inc/legacy/stdint_.h	2016-02-14 14:43:10.000000000 +0900
@@ -0,0 +1,11 @@
+#pragma once
+
+typedef __int8 int8_t ;
+typedef __int16 int16_t ;
+typedef __int32 int32_t ;
+typedef __int64 int64_t ;
+
+typedef unsigned __int8 uint8_t ;
+typedef unsigned __int16 uint16_t ;
+typedef unsigned __int32 uint32_t ;
+typedef unsigned __int64 uint64_t ;
diff -uPr BonD_FSHybrid-20201009_org/src/it9175.c BonD_FSHybrid-20201009_mod10.1/src/it9175.c
--- BonD_FSHybrid-20201009_org/src/it9175.c	2016-02-18 20:13:22.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/it9175.c	2020-10-11 23:37:28.000000000 +0900
@@ -14,8 +14,7 @@
 #include "it9175_usb.h"
 #include "it9175_priv.h"
 #include "message.h"
-
-#define TS_BulkSize  305
+#include "tsbuff.h"
 
 #define ARRAY_SIZE(x)  (sizeof(x)/(sizeof(x[0])))
 
@@ -371,6 +370,8 @@
 }
 
 /* initialize tuner, demod, USB interface */
+extern int TSCACHING_BULKPACKETSIZE;
+extern int TSCACHING_DROPNULLPACKETS;
 static int it9175_tuner_init(struct state_st* const st)
 {
 	int ret;
@@ -501,7 +502,9 @@
 		if((ret = writeRegTable(st, init3_mtab, ARRAY_SIZE(init3_mtab)))) goto err1;
 	}
 	{//# frame size, packet size= 512 /4 = 128
-		const unsigned TS_FrameSize = TS_BulkSize * 188 / 4;
+		unsigned TS_FrameSize = (TSCACHING_BULKPACKETSIZE>0 ?
+			TSCACHING_BULKPACKETSIZE : TS_PacketSize) / 4;
+		if(TS_FrameSize>=65536) TS_FrameSize=65535;
 		rbuf[0] = TS_FrameSize & 0xFF;
 		rbuf[1] = (TS_FrameSize >> 8) & 0xFF;
 		if((ret = writeRegs(st, 0xdd88, rbuf, 2))) goto err1;
@@ -511,8 +514,9 @@
 		const struct reg_val_mask init4_mtab[] = {
 			{0x80f985, 0x00, 0x01},   //# serial mode = F
 			{0x80f986, 0x00, 0x01},   //# parallel mode = F
+			// note: it9175 tuner init disables
 			{0x80f9a3, 0x00, 0x01},   //# stream2 disable
-			{0x80f9cd, 0x00, 0x01},   //# TS disable
+			//{0x80f9cd, 0x00, 0x01},   //# TS disable
 			{0x80f99d, 0x00, 0x01},   //# stream1 reset = F
 			{0x80f9a4, 0x00, 0x01},   //# stream2 reset = F
 			{0xd8fd, 0x01, 0},
@@ -531,7 +535,7 @@
 		};
 		if((ret = writeRegTable(st, init4_mtab, ARRAY_SIZE(init4_mtab)))) goto err1;
 	}
-	{//# PID filter
+	if(TSCACHING_DROPNULLPACKETS){//# PID filter
 		rbuf[0] = 0xFF;  rbuf[1] = 0x1F;
 		if((ret = writeRegs(st, 0x80f996, rbuf, 2))) goto err1;
 		if((ret = writeReg(st, 0x80f995, 0))) goto err1;
@@ -650,7 +654,7 @@
 	iqik_m_cal = (0 == st->clock_d) ? (ret * 9) >> 5 :  ret >> 1;
 
 	if((ret = writeReg(st, 0x800160, lna_band))) goto err1;
-	
+
 	{//# bandwidth
 		const uint8_t reg80ec56[4] = {2, 4, 6, 0};
 		if((ret = writeReg(st, 0x80ec56, reg80ec56[st->bw_mode]))) goto err1;
@@ -710,8 +714,11 @@
 		return -2;
 	}
 	pusbep->endpoint = EP_TS1;
+	pusbep->dev = st ;
 	pusbep->startstopFunc = NULL;
-	pusbep->xfer_size = TS_BulkSize * 188;
+	pusbep->lockunlockFunc = it9175_lockunlockMutex;
+	pusbep->xfer_size = TSCACHING_BULKPACKETSIZE>0 ?
+		TSCACHING_BULKPACKETSIZE: TS_PacketSize;
 	st->chip_id = 0;
 	st->fd = pusbep->fd;
 
@@ -872,11 +879,11 @@
 }
 
 /* Transmission and Multiplexing Configuration and Control (See ARIB STD-B31) */
-int it9175_readTMCC(const it9175_state state, void* const pData)
+int it9175_readTMCC(const it9175_state state, struct TMCC_data* const pData)
 {
 	int ret, j;
 	struct state_st* const s = state;
-	uint8_t rbuf[4], val, *ptr = pData, txmode;
+	uint8_t rbuf[4], val, *ptr = (uint8_t*) pData, txmode;
 	const uint8_t n_txmod[4] = {1,3,2,0};
 
 	if((ret = readRegs(s, 0x80f900, rbuf, 3))) goto err1;
@@ -946,4 +953,35 @@
 	return ret;
 }
 
+int it9175_readSNRatio(const it9175_state state, uint8_t* const dB)
+{
+	int ret = 0;
+	struct state_st* const st = state;
+	uint8_t rbuf[1];
+	//# S/N Ratio (dB)
+	if((ret = readRegs(st, 0x8001c9, rbuf, 1))) goto err1;
+	dB[0] = *rbuf;
+
+	return 0;
+err1:
+	return ret;
+}
+
+int it9175_lockunlockMutex(const it9175_state state, const int lock)
+{
+	int ret = 0;
+	struct state_st* const st = state;
+
+	if(lock) {
+		if((ret = uthread_mutex_lock(st->pmutex))) goto err1 ;
+	}else {
+		if((ret = uthread_mutex_unlock(st->pmutex))) goto err1 ;
+	}
+
+	return 0;
+err1:
+	warn_info(ret,"failed");
+	return ret;
+}
+
 /*EOF*/
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/it9175.h BonD_FSHybrid-20201009_mod10.1/src/it9175.h
--- BonD_FSHybrid-20201009_org/src/it9175.h	2015-12-09 15:31:26.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/it9175.h	2020-04-27 00:44:38.000000000 +0900
@@ -4,7 +4,11 @@
   2015-12-09
 */
 #pragma once
+#ifdef LEGACY_STDINT
+#include "stdint_.h"
+#else
 #include <stdint.h>
+#endif
 #include "types_u.h"
 
 typedef void* it9175_state;
@@ -22,5 +26,8 @@
 int it9175_readTMCC(const it9175_state, struct TMCC_data* const);
 
 int it9175_readStatistic(const it9175_state, uint8_t* const data);
+int it9175_readSNRatio(const it9175_state, uint8_t* const dB);
 
-/*EOF*/
\ ե˲Ԥޤ
+int it9175_lockunlockMutex(const it9175_state, const int lock);
+
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/it9175_usb.h BonD_FSHybrid-20201009_mod10.1/src/it9175_usb.h
--- BonD_FSHybrid-20201009_org/src/it9175_usb.h	2015-12-25 02:54:06.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/it9175_usb.h	2019-12-16 06:15:18.000000000 +0900
@@ -4,9 +4,13 @@
   2015-12-25
 */
 #pragma once
+#ifdef LEGACY_STDINT
+#include "stdint_.h"
+#else
 #include <stdint.h>
+#endif
 
 int it9175_ctrl_msg(void* const, const uint8_t cmd, const uint8_t mbox, const uint8_t wrlen, const uint8_t rdlen);
 int it9175_usbSetTimeout(void* const pst);
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/ktv.cpp BonD_FSHybrid-20201009_mod10.1/src/ktv.cpp
--- BonD_FSHybrid-20201009_org/src/ktv.cpp	2012-09-28 02:12:44.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/ktv.cpp	2022-05-02 23:18:22.000000000 +0900
@@ -1,6 +1,5 @@
 
 #include "stdafx.h"
-#include "../twindbg.h"
 
 #include "ktv.h"
 
@@ -8,7 +7,7 @@
 
 inline void miliWait( int s )
 {
-	Sleep( s );
+	HRSleep( s, 0 );
 }
 
 unsigned KtvDevice::UserSettings = 0x7;
@@ -29,7 +28,7 @@
 bool KtvDevice::DeMod_Write (const uint8_t idx, const uint8_t val)
 {
 	usbDev->writeReg(EM28XX_REG_I2C_CLK, 0x44);
-	uint8_t buf[] = {idx, val};
+    uint8_t buf[] = {idx, val};
 	return usbDev->writeI2C(DEMOD_ADDR, 2, buf, true);
 }
 
@@ -241,7 +240,7 @@
 		0x00, 0x00, 0x96, 0x33, 0xc1, 0x00, 0x8f, 0x00,
 		0x00, 0x8c, 0x00, 0x20, 0xb3, 0x48, 0xb0,
 	// Setup AGC1 gain
-	0x20, 0x01, 0x00, 
+	0x20, 0x01, 0x00,
 	0x20, 0x01, 0x03,
 	0x20, 0x01, 0x43,
 	0x20, 0x01, 0x4c,
@@ -415,7 +414,7 @@
 	};
 
 	tuner_r[0x07] ^= (::binarySearch( ir_measure, TBL_SZ( ir_measure ), freq_khz ) ^ tuner_r[0x07]) & 0x07;
-	
+
 	tuner_r[0x10] &= ~0x03;
 	Tuner_RegWrite(0x10, 1);
 
@@ -632,14 +631,13 @@
 
 Ktv2Device::~Ktv2Device()
 {
-	static uint8_t rData[] = { 0x01,0, 0x0f,0 };
 	if( usbDev != NULL ) {
-		Tuner_I2C_Write(rData, TBL_SZ(rData));	// enter standby mode
+		SleepTuner();
 	}
 }
 
 void Ktv2Device::InitTuner ()
-{	
+{
 	static uint8_t initData[] = {
 		0x02,0x00, 0x03,0x40, 0x05,0x04, 0x06,0x10,
 		0x2e,0x15, 0x30,0x10, 0x45,0x58, 0x48,0x19,
@@ -653,6 +651,13 @@
 	Tuner_InitDone = true;
 }
 
+bool Ktv2Device::SleepTuner ()
+{
+	static uint8_t rData[] = { 0x01,0, 0x0f,0 };
+	Tuner_I2C_Write(rData, TBL_SZ(rData));	// enter standby mode
+    return true ;
+}
+
 void Ktv2Device::SetFrequency (unsigned int freq_khz)
 {
 	static uint8_t tuneData[] = {
diff -uPr BonD_FSHybrid-20201009_org/src/ktv.h BonD_FSHybrid-20201009_mod10.1/src/ktv.h
--- BonD_FSHybrid-20201009_org/src/ktv.h	2012-09-28 01:39:22.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/ktv.h	2020-06-18 09:44:24.000000000 +0900
@@ -10,12 +10,13 @@
 class KtvDevice {
 public:
 	KtvDevice (EM2874Device *pDev);
-	~KtvDevice();
+	virtual ~KtvDevice();
 
 	virtual void InitTuner () = 0;
 	virtual void SetFrequency (unsigned int freq_khz) = 0;
 	virtual void InitDeMod () = 0;
 	virtual void ResetDeMod () = 0;
+    virtual bool SleepTuner () = 0;
 	uint8_t DeMod_GetSequenceState();
 	unsigned int DeMod_GetQuality();
 	unsigned DeMod_GetBER(int *pVal);
@@ -40,12 +41,13 @@
 {
 public:
 	Ktv1Device (EM2874Device *pDev);
-	~Ktv1Device();
+	virtual ~Ktv1Device();
 
 	void InitTuner ();
 	void SetFrequency (unsigned int freq_khz);
 	void InitDeMod ();
 	void ResetDeMod ();
+    bool SleepTuner () { return false ; }
 
 private:
 	void Tuner_RegWrite (const uint8_t offset, const int len);
@@ -61,9 +63,10 @@
 {
 public:
 	Ktv2Device (EM2874Device *pDev);
-	~Ktv2Device();
+	virtual ~Ktv2Device();
 
 	void InitTuner ();
+    bool SleepTuner();
 	void SetFrequency (unsigned int freq_khz);
 	void InitDeMod ();
 	void ResetDeMod ();
diff -uPr BonD_FSHybrid-20201009_org/src/mxl136.c BonD_FSHybrid-20201009_mod10.1/src/mxl136.c
--- BonD_FSHybrid-20201009_org/src/mxl136.c	2016-01-27 14:53:38.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/mxl136.c	2019-12-16 06:15:18.000000000 +0900
@@ -4,7 +4,16 @@
   2016-01-27
 */
 
+#ifdef LEGACY_STDINT
+
+#include "stdint_.h"
+
+#else
+
 #include <stdint.h>
+
+#endif
+
 #include <errno.h>
 #include <string.h>
 #include <malloc.h>
@@ -183,4 +192,4 @@
 }
 
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/osdepend.c BonD_FSHybrid-20201009_mod10.1/src/osdepend.c
--- BonD_FSHybrid-20201009_org/src/osdepend.c	2015-12-12 02:20:38.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/osdepend.c	2022-05-02 23:21:11.000000000 +0900
@@ -7,23 +7,45 @@
 #include "stdafx.h"
 #include "osdepend.h"
 
+#define UTHREAD_MUTEX_AS_CRITICAL_SECTION
+//#define UHEAP_AS_VIRTUAL
+
 void miliWait(unsigned msec)
 {
-	Sleep(msec);
+	HRSleep(msec,0);
 }
 
 void* uHeapAlloc(size_t sz)
 {
+#ifdef UHEAP_AS_VIRTUAL
 	return VirtualAlloc( NULL, sz, MEM_COMMIT, PAGE_READWRITE );
+#else
+	return HeapAlloc( GetProcessHeap(), 0, sz );
+#endif
 }
 
 void uHeapFree(void* const ptr)
 {
+#ifdef UHEAP_AS_VIRTUAL
 	VirtualFree( ptr, 0, MEM_RELEASE );
+#else
+	HeapFree( GetProcessHeap(), 0, ptr );
+#endif
 }
 
 int uthread_mutex_init(PMUTEX *p)
 {
+#ifdef UTHREAD_MUTEX_AS_CRITICAL_SECTION
+	if(NULL == p)
+		return -1;
+	if(NULL == *p) {
+		CRITICAL_SECTION *sec_p = (CRITICAL_SECTION*) uHeapAlloc(sizeof(CRITICAL_SECTION)) ;
+		if(sec_p==NULL) return ERROR_NOT_ENOUGH_MEMORY;
+		InitializeCriticalSection(sec_p);
+		*p=(PMUTEX)sec_p;
+	}
+	return 0;
+#else
 	if(NULL == p)
 		return -1;
 	if(NULL == *p) {
@@ -31,25 +53,45 @@
 		if(NULL == *p) return GetLastError();
 	}
 	return 0;
+#endif
 }
 
 int uthread_mutex_lock(PMUTEX p)
 {
-	const DWORD dRet = WaitForSingleObject(p, 10000);
+#ifdef UTHREAD_MUTEX_AS_CRITICAL_SECTION
+	if(p==NULL) return ERROR_INVALID_HANDLE;
+	EnterCriticalSection((CRITICAL_SECTION*)p) ;
+	return 0;
+#else
+	const DWORD dRet = HRWaitForSingleObject(p, 10000,0 );
 	if(WAIT_FAILED == dRet) return GetLastError();
 	return dRet;
+#endif
 }
 
 int uthread_mutex_unlock(PMUTEX p)
 {
+#ifdef UTHREAD_MUTEX_AS_CRITICAL_SECTION
+	if(p==NULL) return ERROR_INVALID_HANDLE;
+	LeaveCriticalSection((CRITICAL_SECTION*)p) ;
+	return 0;
+#else
 	if(ReleaseMutex(p) == 0) return GetLastError();
 	return 0;
+#endif
 }
 
 int uthread_mutex_destroy(PMUTEX p)
 {
+#ifdef UTHREAD_MUTEX_AS_CRITICAL_SECTION
+	if(p==NULL) return ERROR_INVALID_HANDLE;
+	DeleteCriticalSection((CRITICAL_SECTION*)p);
+	uHeapFree(p);
+	return 0;
+#else
 	if(CloseHandle(p) == 0) return GetLastError();
 	return 0;
+#endif
 }
 
 /*EOF*/
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/pryutil.cpp BonD_FSHybrid-20201009_mod10.1/src/pryutil.cpp
--- BonD_FSHybrid-20201009_org/src/pryutil.cpp	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/pryutil.cpp	2022-04-22 16:43:40.000000000 +0900
@@ -0,0 +1,1253 @@
+//===========================================================================
+#include "stdafx.h"
+#include <cctype>
+#include <cstdarg>
+#include <process.h>
+#include <locale.h>
+#include <Shlwapi.h>
+#pragma comment(lib, "Shlwapi.lib")
+#pragma comment(lib, "Rpcrt4.lib")
+
+#include "pryutil.h"
+//---------------------------------------------------------------------------
+using namespace std ;
+
+//===========================================================================
+namespace PRY8EAlByw {
+//---------------------------------------------------------------------------
+
+#ifdef PRY8EAlByw_HRTIMER
+  #define wait_object HRWaitForSingleObject
+  #define delay HRSleep
+#else
+  #define wait_object WaitForSingleObject
+  #define delay Sleep
+#endif
+
+//===========================================================================
+// Statics
+//---------------------------------------------------------------------------
+static errno_t splitPath(
+   const string &path,
+   string *pDrv=NULL,
+   string *pDir=NULL,
+   string *pFname=NULL,
+   string *pExt=NULL,
+   UINT code_page=CP_ACP
+) {
+
+  wstring wpath = mbcs2wcs(path,code_page) ;
+
+  #define BUFALLOC(Nam) BUFFER<wchar_t> w##Nam(p##Nam?_MAX_FNAME:0)
+  BUFALLOC(Drv);
+  BUFALLOC(Dir);
+  BUFALLOC(Fname);
+  BUFALLOC(Ext);
+  #undef BUFALLOC
+
+  #define SPLPARAM(Nam) \
+     (p##Nam?w##Nam.data():NULL), \
+     (p##Nam?w##Nam.size():0)
+  errno_t r = _wsplitpath_s(
+     wpath.c_str(),
+     SPLPARAM(Drv),
+     SPLPARAM(Dir),
+     SPLPARAM(Fname),
+     SPLPARAM(Ext)
+  );
+  #undef SPLPARAM
+
+  if(!r) {
+    #define STOREVAL(Nam) if(p##Nam) *p##Nam = wcs2mbcs(w##Nam.data(),code_page)
+    STOREVAL(Drv) ;
+    STOREVAL(Dir) ;
+    STOREVAL(Fname) ;
+    STOREVAL(Ext) ;
+    #undef STOREVAL
+  }
+
+  return r ;
+}
+//===========================================================================
+// Functions
+//---------------------------------------------------------------------------
+DWORD Elapsed(DWORD start, DWORD end)
+{
+  DWORD result = (end>=start) ? end-start : MAXDWORD-end+1+start ;
+  return result ;
+}
+//---------------------------------------------------------------------------
+DWORD PastSleep(DWORD wait,DWORD start)
+{
+  if(!wait) return start ;
+  DWORD past = Elapsed(start,GetTickCount()) ;
+  if(wait>past) delay(wait-past);
+  return start+wait ;
+}
+//---------------------------------------------------------------------------
+wstring mbcs2wcs(string src, UINT code_page)
+{
+  int wLen = MultiByteToWideChar(code_page, 0, src.c_str(), (int)src.length(), NULL, 0);
+  if(wLen>0) {
+    BUFFER<wchar_t> wcs(wLen) ;
+    MultiByteToWideChar(code_page, 0, src.c_str(), (int)src.length(), wcs.data(), wLen);
+    return wstring(wcs.data(),wLen);
+  }
+  return wstring(L"");
+}
+//---------------------------------------------------------------------------
+string wcs2mbcs(wstring src, UINT code_page)
+{
+  int mbLen = WideCharToMultiByte(code_page, 0, src.c_str(), (int)src.length(), NULL, 0, NULL, NULL) ;
+  if(mbLen>0) {
+    BUFFER<char> mbcs(mbLen) ;
+    WideCharToMultiByte(code_page, 0, src.c_str(), (int)src.length(), mbcs.data(), mbLen, NULL, NULL);
+    return string(mbcs.data(),mbLen);
+  }
+  return string("");
+}
+//---------------------------------------------------------------------------
+string itos(int val,int radix)
+{
+  BUFFER<char> str(72) ;
+  if(!_itoa_s(val,str.data(),70,radix))
+    return static_cast<string>(str.data()) ;
+  return "NAN" ;
+}
+//---------------------------------------------------------------------------
+wstring itows(int val,int radix)
+{
+  BUFFER<wchar_t> str(72) ;
+  if(!_itow_s(val,str.data(),70,radix))
+    return static_cast<wstring>(str.data()) ;
+  return L"NAN" ;
+}
+//---------------------------------------------------------------------------
+string upper_case(string str)
+{
+  BUFFER<char> temp(str.length()+1) ;
+  CopyMemory(temp.data(),str.c_str(),(str.length()+1)*sizeof(char)) ;
+  _strupr_s(temp.data(),str.length()+1) ;
+  return static_cast<string>(temp.data()) ;
+}
+//---------------------------------------------------------------------------
+string lower_case(string str)
+{
+  BUFFER<char> temp(str.length()+1) ;
+  CopyMemory(temp.data(),str.c_str(),(str.length()+1)*sizeof(char)) ;
+  _strlwr_s(temp.data(),str.length()+1) ;
+  return static_cast<string>(temp.data()) ;
+}
+//---------------------------------------------------------------------------
+string uuid_string()
+{
+  UUID uuid_ ;
+  UuidCreate(&uuid_) ;
+  unsigned char * result ;
+  UuidToStringA(&uuid_,&result) ;
+  string str_result = (char*)result ;
+  RpcStringFreeA(&result);
+  return lower_case(str_result) ;
+}
+//---------------------------------------------------------------------------
+string str_printf(const char *format, ...)
+{
+	va_list marker ;
+	va_start( marker, format ) ;
+	int edit_ln = _vscprintf(format, marker);
+	if(edit_ln++>0) {
+		BUFFER<char> edit_str(edit_ln);
+		vsprintf_s( edit_str.data(), edit_ln, format, marker ) ;
+		va_end( marker ) ;
+		return string(edit_str.data()) ;
+	}
+	va_end( marker ) ;
+	return string() ;
+}
+//---------------------------------------------------------------------------
+string file_drive_of(string filename)
+{
+  string drv ;
+  splitPath(filename,&drv) ;
+  return drv ;
+}
+//---------------------------------------------------------------------------
+string file_path_of(string filename)
+{
+  string drv, dir ;
+  splitPath(filename,&drv,&dir) ;
+  return drv+dir ;
+}
+//---------------------------------------------------------------------------
+string file_name_of(string filename)
+{
+  string name, ext ;
+  splitPath(filename,NULL,NULL,&name,&ext) ;
+  return name+ext ;
+}
+//---------------------------------------------------------------------------
+string file_prefix_of(string filename)
+{
+  string name;
+  splitPath(filename,NULL,NULL,&name) ;
+  return name ;
+}
+//---------------------------------------------------------------------------
+string file_suffix_of(string filename)
+{
+  string ext ;
+  splitPath(filename,NULL,NULL,NULL,&ext) ;
+  return ext ;
+}
+//---------------------------------------------------------------------------
+int file_age_of(string filename)
+{
+  WIN32_FIND_DATAA data ;
+  HANDLE h = FindFirstFileA(filename.c_str(),&data);
+  if(h == INVALID_HANDLE_VALUE) return -1 ;
+  FindClose(h) ;
+  if(data.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY) return -1 ;
+  FILETIME local ;
+  FileTimeToLocalFileTime(&data.ftLastWriteTime, &local);
+  WORD d, t ;
+  if(!FileTimeToDosDateTime(&local, &d, &t)) return -1 ;
+  return int(DWORD(d)<<16|DWORD(t)) ;
+}
+//---------------------------------------------------------------------------
+bool file_is_existed(string filename)
+{
+#if 0
+  return file_age_of(filename.c_str()) != -1 ;
+#else
+  return PathFileExistsA(filename.c_str()) && !folder_is_existed(filename) ;
+#endif
+}
+//---------------------------------------------------------------------------
+bool folder_is_existed(string filename)
+{
+#if 0
+  DWORD attr = GetFileAttributesA(filename.c_str()) ;
+  return attr!=MAXDWORD && (attr&FILE_ATTRIBUTE_DIRECTORY) ? true : false ;
+#else
+  return PathIsDirectoryA(filename.c_str()) ? true : false ;
+#endif
+}
+//===========================================================================
+// acalci
+//---------------------------------------------------------------------------
+
+#define ACALCI_CONST_MATCHCASE  false
+
+    template<typename T>
+    class integer_c_expression_const_table
+    {
+    protected:
+      class str_comp_f : public binary_function<string,string,bool> {
+        bool match_case;
+      public:
+        str_comp_f(bool match_case_) : match_case(match_case_) {}
+        str_comp_f(const str_comp_f &src) : match_case(src.match_case) {}
+        bool operator()(const string lhs, const string rhs) const {
+          return match_case ? lhs < rhs : lower_case(lhs) < lower_case(rhs) ;
+        }
+      };
+      typedef map<string,T,str_comp_f> const_map_t;
+      const_map_t const_map ;
+      exclusive_object excl ;
+    public:
+      integer_c_expression_const_table(bool match_case)
+        : const_map(str_comp_f(match_case)) {}
+      void clear() {
+        exclusive_lock lock(&excl);
+        const_map.clear();
+      }
+      void entry(const string name, const T val) {
+        exclusive_lock lock(&excl);
+        const_map[name]=val;
+      }
+      bool find(const string name, T &val) const {
+        exclusive_lock lock(const_cast<exclusive_object*>(&excl));
+        const_map_t::const_iterator pos = const_map.find(name);
+        if(pos==const_map.end()) return false;
+        val=pos->second ;
+        return true;
+      }
+    };
+
+    template<typename T>
+    class integer_c_expression_string_calculator
+    {
+    protected:
+      enum token_t {
+        tEND    = 0,
+        tSTART  = 1,
+        tVAL    = 10,
+        tPLUS   = 20,  /* prec ADD */
+        tMINUS  = 21,  /* prec SUB */
+        tNOT    = 22,
+        tFACT   = 30,
+        tMUL    = 40,
+        tDIV    = 41,
+        tMOD    = 42,
+        tADD    = 50,
+        tSUB    = 51,
+        tLSHIFT = 60,
+        tRSHIFT = 61,
+        tAND    = 70,
+        tXOR    = 80,
+        tOR     = 90,
+        tLP     = 100,
+        tRP     = 101,
+      };
+      struct node_t {
+        token_t token ;
+        T val ;
+        struct node_t *next ;
+        node_t(): token(tEND),val(0),next(NULL) {}
+      };
+      node_t *top ;
+      T def_val ;
+      integer_c_expression_const_table<T> *const_table ;
+      bool halfway ;
+      const char *es ;
+    protected:
+      static T strimmval(const char *s,char **endptr,int radix) {
+        #if 1
+        T val=0;
+        while(*s) {
+          int c = toupper(*s) ; T v ;
+          if(c>='0'&&c<='9'&&c-'0'<radix)
+            v = c-'0' ;
+          else if(radix>10&&c>='A'&&c<='Z'&&c-'A'<radix-10)
+            v = c-'A'+10 ;
+          else break ;
+          switch(radix) {
+            case 2:  val<<=1; break;
+            case 8:  val<<=3; break;
+            case 16: val<<=4; break;
+            default: val*=radix;
+          }
+          val += v ;
+          s++;
+        }
+        if(endptr) *endptr=const_cast<char*>(s) ;
+        return val ;
+        #else
+        if(sizeof(T)>sizeof(long))
+          return static_cast<T>(strtoull(s,endptr,radix)); // NG: @VS2008
+        return static_cast<T>(strtoul(s,endptr,radix));
+        #endif
+      }
+      static void skip_separator(const char *&s) {
+        while(*s==' '||*s=='\t'||*s=='\r'||*s=='\n') s++;
+      }
+      static void skip_val_literal(const char *&s) {
+        while(*s&&(isalnum(*s)||*s=='_')) s++;
+      }
+      T __fastcall parse(node_t *backTK) {
+        node_t nextTK;
+        backTK->next = &nextTK;
+        skip_separator(es);
+        if(*es>='0'&&*es<='9') {
+          char *e=NULL;
+          nextTK.token=tVAL;
+          if(es[0]=='0') {
+            if(es[1]=='b'||es[1]=='B') // bin
+              nextTK.val=strimmval(es+=2,&e,2);
+            else if(es[1]=='x'||es[1]=='X') // hex
+              nextTK.val=strimmval(es+=2,&e,16);
+            else // oct
+              nextTK.val=strimmval(es++,&e,8);
+          }else // dec
+            nextTK.val=strimmval(es++,&e,10);
+          if(e) es=e;
+          switch(*es) { // binary units
+            case 'K': nextTK.val<<=10, es++; break ; // Ki
+            case 'M': nextTK.val<<=20, es++; break ; // Mi
+            case 'G': nextTK.val<<=30, es++; break ; // Gi
+            case 'T': nextTK.val<<=40, es++; break ; // Ti (over int)
+            case 'P': nextTK.val<<=50, es++; break ; // Pi
+            case 'E':
+            case 'X': nextTK.val<<=60, es++; break ; // Ei
+            case 'Z': nextTK.val<<=70, es++; break ; // Zi (over __int64)
+            case 'Y': nextTK.val<<=80, es++; break ; // Yi
+          }
+          skip_val_literal(es) ;
+        }
+        else if(!strncmp("**",es,2)) nextTK.token=tFACT,   es+=2;
+        else if(!strncmp("<<",es,2)) nextTK.token=tLSHIFT, es+=2;
+        else if(!strncmp(">>",es,2)) nextTK.token=tRSHIFT, es+=2;
+        else {
+          switch(*es) {
+            case '+': nextTK.token=tADD; break;
+            case '-': nextTK.token=tSUB; break;
+            case '~': nextTK.token=tNOT; break;
+            case '*': nextTK.token=tMUL; break;
+            case '/': nextTK.token=tDIV; break;
+            case '%': nextTK.token=tMOD; break;
+            case '&': nextTK.token=tAND; break;
+            case '^': nextTK.token=tXOR; break;
+            case '|': nextTK.token=tOR;  break;
+            case '(': nextTK.token=tLP;  break;
+            case ')': nextTK.token=tRP;  break;
+            case ';': es++;
+            case '\0':
+              return calculate(); // terminal
+            default:
+              if(const_table&&(isalpha(*es)||*es=='_')) { // constant
+                const char *e = es ;
+                skip_val_literal(e) ;
+                if(const_table->find(string(es,e-es),nextTK.val)) {
+                  nextTK.token=tVAL;
+                  es=e-1;
+                  break;
+                }
+              }
+              return calculate(); // outside of c-expression literals
+          }
+          es++;
+        }
+        return parse(&nextTK); // parse the next token
+      }
+      T calculate() {
+        int num=0;
+        node_t *p=top->next;
+        while(p&&p->token!=tEND) {
+          num++;
+          p=p->next;
+        }
+        return do_calculate(num,top->next);
+      }
+      static node_t* nest_node(node_t *p,int num) {
+        while(num>0) p=p->next, num--;
+        return p;
+      }
+      T __fastcall do_calculate(int &num,node_t *pos)
+      {
+      #define D1(a)  (p->token==(a))
+      #define D2(a,b)  (D1(a)&&p->next->token==(b))
+      #define D3(a,b,c) (D2(a,b)&&p->next->next->token==(c))
+        if(!pos) {num=0; return def_val;}
+        //PRIOR100: ( )  <- digest parenthesses at first
+        node_t *p=pos;
+        for(int i=0;i<num-1;i++,p=p->next) {
+          if(D1(tRP)) break ;
+          if(D1(tLP)) {
+            num -= i+1;
+            do_calculate(num,p->next);
+            num += i+1;
+            if(num-i>=3&&D3(tLP,tVAL,tRP)) {
+              p->val= ( p->next->val );
+              p->token=tVAL;
+              p->next=nest_node(p,3);
+              num-=2;
+            }
+          }
+        }
+        //PRIOR(20-90): digest operators ( parenthesses excluded )
+        node_t *q;
+        int n;
+        //PRIOR20: + - ~ (single)
+        do {
+          p=pos, q=NULL, n=0 ;
+          for (int i = 0; i < num - 1; q = p, p = p->next, i++) {
+            if(D1(tRP)) break ;
+            if(q&&q->token==tVAL) // NG: the LHS value is existed
+              continue;
+            if(D2(tADD,tVAL))       p->val= + p->next->val;
+            else if(D2(tSUB,tVAL))  p->val= - p->next->val;
+            else if(D2(tNOT,tVAL))  p->val= ~ p->next->val;
+            else continue ;
+            p->token=tVAL;
+            p->next=nest_node(p,2);
+            num--;
+            if(q&&(q->token==tADD||q->token==tSUB||q->token==tNOT))
+              n++;
+          }
+        }while(n>0);
+        //PRIOR30: **
+        p=pos;
+        for(int i=0;i<num-2;) {
+          if(D1(tRP)) break ;
+          if(D3(tVAL,tFACT,tVAL)) {
+            T val=p->val;
+            q=p->next->next;
+            if(q->val==0)
+              p->val=1;
+            else if(q->val<0)
+              p->val=0;
+            else while(q->val-1) {
+              p->val*=val;
+              q->val--;
+            }
+            p->next=q->next;
+            num-=2;
+          }
+          else i++, p=p->next;
+        }
+        //PRIOR40: * / %
+        p=pos;
+        for(int i=0;i<num-2;) {
+          if(D1(tRP)) break ;
+          if(D3(tVAL,tMUL,tVAL))        p->val=p->val * p->next->next->val;
+          else if(D3(tVAL,tDIV,tVAL))   p->val=p->val / p->next->next->val;
+          else if(D3(tVAL,tMOD,tVAL))   p->val=p->val % p->next->next->val;
+          else { i++;p=p->next; continue; }
+          p->next=nest_node(p,3);
+          num-=2;
+        }
+        //PRIOR50: + -
+        p=pos;
+        for(int i=0;i<num-2;) {
+          if(D1(tRP)) break ;
+          if(D3(tVAL,tADD,tVAL))        p->val=p->val + p->next->next->val;
+          else if(D3(tVAL,tSUB,tVAL))   p->val=p->val - p->next->next->val;
+          else { i++;p=p->next; continue; }
+          p->next=nest_node(p,3);
+          num-=2;
+        }
+        //PRIOR60: << >>
+        p=pos;
+        for(int i=0;i<num-2;) {
+          if(D1(tRP)) break ;
+          if(D3(tVAL,tLSHIFT,tVAL))      p->val=p->val << p->next->next->val;
+          else if(D3(tVAL,tRSHIFT,tVAL)) p->val=p->val >> p->next->next->val;
+          else { i++;p=p->next; continue; }
+          p->next=nest_node(p,3);
+          num-=2;
+        }
+        //PRIOR70: &
+        p=pos;
+        for(int i=0;i<num-2;) {
+          if(D1(tRP)) break ;
+          if(D3(tVAL,tAND,tVAL)) {
+            p->val=p->val & p->next->next->val;
+            p->next=nest_node(p,3);
+            num-=2;
+          }
+          else i++, p=p->next;
+        }
+        //PRIOR80: ^
+        p=pos;
+        for(int i=0;i<num-2;) {
+          if(D1(tRP)) break ;
+          if(D3(tVAL,tXOR,tVAL)) {
+            p->val=p->val ^ p->next->next->val;
+            p->next=nest_node(p,3);
+            num-=2;
+          }
+          else i++, p=p->next;
+        }
+        //PRIOR90: |
+        p=pos;
+        for(int i=0;i<num-2;) {
+          if(D1(tRP)) break ;
+          if(D3(tVAL,tOR,tVAL)) {
+            p->val=p->val | p->next->next->val;
+            p->next=nest_node(p,3);
+            num-=2;
+          }
+          else i++, p=p->next;
+        }
+        //PRIOR10: a VAL token is finally existed at the head or not
+        return pos&&pos->token==tVAL&&(halfway||num==1)? pos->val: def_val;
+      #undef D1
+      #undef D2
+      #undef D3
+      }
+    public:
+      T execute(
+            const char *expression_string, T default_value,
+            const char **out_end_pointer=NULL,
+            integer_c_expression_const_table<T> *constant_var_table=NULL,
+            bool allow_indigestion=false ) {
+        node_t sTK ;
+        sTK.token = tSTART ;
+        top = &sTK ;
+        es = expression_string ;
+        def_val = default_value ;
+        halfway = allow_indigestion ;
+        const_table = constant_var_table ;
+        T ret = es ? parse(top) : def_val ;
+        if(out_end_pointer) *out_end_pointer = es ;
+        return ret ;
+      }
+    };
+
+
+//----- acalci entity -----------------------------------------------
+/* Calculate the c-expression string and convert it to an integer. */
+/********************************************************************
+
+  int acalci(const char *s, int defVal, const char **endPtr, bool allowIndigest)
+
+    s: A c-expression string consisted of operators and terms.
+    defVal: A returned value as default on being failed to calculate.
+    endPtr: An output value wherence end of c-expression literals on s.
+    allowIndigest: Allow the indigestion of operators or not.
+    [result]: A value as converted result of calculating s.
+
+    Operators and Associativity::
+    (The order of priority is from top to bottom.)
+    ==============================================
+        ( )                    -> left to right
+        + - ~ (single)         <- right to left
+        ** (factorial)         -> left to right
+        * / %                  -> left to right
+        + -                    -> left to right
+        << >>                  -> left to right
+        &                      -> left to right
+        ^                      -> left to right
+        |                      -> left to right
+    ==============================================
+    Operator-meanings are almost same as C-Lang.
+
+    Only integers can be terms as the imm value.
+    Integer formats:: (described below as regexp.)
+    ==============================================
+      0[bB][01]+                  Binary digits
+      [1-9][0-9].                 Decimal digits
+      0[0-7].                     Octal digits
+      0[xX][0-9a-fA-F]+           Hexical digits
+    ==============================================
+
+    Separators:: [SPACE][TAB(\t)][CR(\r)][LF(\n)]
+
+********************************************************************/
+
+  static integer_c_expression_const_table<int> acalci_const_table(ACALCI_CONST_MATCHCASE) ;
+  static integer_c_expression_const_table<__int64> acalci64_const_table(ACALCI_CONST_MATCHCASE) ;
+
+//-----
+int acalci(const char *s, int defVal, const char **endPtr, bool allowIndigest)
+{
+  integer_c_expression_string_calculator<int> calculator ;
+  return calculator.execute(s, defVal, endPtr, &acalci_const_table, allowIndigest) ;
+}
+//-----
+__int64 acalci64(const char *s, __int64 defVal, const char **endPtr, bool allowIndigest)
+{
+  integer_c_expression_string_calculator<__int64> calculator ;
+  return calculator.execute(s, defVal, endPtr, &acalci64_const_table, allowIndigest) ;
+}
+//-----
+void acalci_entry_const(const char *name, int val)
+{
+  if(!name) acalci_const_table.clear();
+  else acalci_const_table.entry(name, val);
+}
+//-----
+void acalci64_entry_const(const char *name, __int64 val)
+{
+  if(!name) acalci64_const_table.clear();
+  else acalci64_const_table.entry(name, val);
+}
+//===========================================================================
+// event_object
+//---------------------------------------------------------------------------
+static int event_create_count = 0 ;
+//---------------------------------------------------------------------------
+event_object::event_object(BOOL initialState_,wstring name_,BOOL security_)
+{
+#ifdef _DEBUG
+  id = event_create_count;
+#endif
+  if(name_.empty()) name_ = L"Local\\event"+itows(event_create_count)+L"_"+mbcs2wcs(uuid_string()) ;
+
+  name = name_ ;
+  event_create_count++;
+
+  SECURITY_ATTRIBUTES sa,*psa=NULL;
+  SECURITY_DESCRIPTOR sd;
+  if(security_) {
+    ZeroMemory(&sd,sizeof sd);
+    if(InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
+      if(SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE)) {
+        ZeroMemory(&sa,sizeof sa);
+        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
+        sa.bInheritHandle = FALSE;
+        sa.lpSecurityDescriptor = &sd;
+        psa = &sa;
+      }
+    }
+  }
+
+  event = CreateEvent(psa,FALSE,initialState_,name.empty()?NULL:name.c_str()) ;
+#ifdef _DEBUG
+  if(is_valid()) {
+    TRACE(L"event_object(%d) created. [name=%s]\r\n",id,name.empty()?L"<EMPTY>":name.c_str()) ;
+  }else {
+    TRACE(L"event_object(%d) failed to create. [name=%s]\r\n",id,name.empty()?L"<EMPTY>":name.c_str()) ;
+  }
+#endif
+}
+//---------------------------------------------------------------------------
+event_object::event_object(const event_object &clone_source)
+{
+#ifdef _DEBUG
+  id = event_create_count++;
+#endif
+  name = clone_source.name ;
+  event = clone_source.open() ;
+#ifdef _DEBUG
+  if(is_valid()) {
+    TRACE(L"event_object(%d) cloned. [name=%s]\r\n",id,name.empty()?L"<EMPTY>":name.c_str()) ;
+  }else {
+    TRACE(L"event_object(%d) failed to clone. [name=%s]\r\n",id,name.empty()?L"<EMPTY>":name.c_str()) ;
+  }
+#endif
+}
+//---------------------------------------------------------------------------
+event_object::~event_object()
+{
+#ifdef _DEBUG
+  if(is_valid()) {
+    TRACE(L"event_object(%d) disposed. [name=%s]\r\n",id,name.c_str()) ;
+  }else {
+    TRACE(L"event_object(%d) disposed. (failure) [name=%s]\r\n",id,name.c_str()) ;
+  }
+#endif
+  if(is_valid()) CloseHandle(event) ;
+}
+//---------------------------------------------------------------------------
+HANDLE event_object::open() const
+{
+  if(!is_valid()) return NULL ;
+  HANDLE open_event = OpenEvent(EVENT_ALL_ACCESS, FALSE, name.c_str());
+  return open_event ;
+}
+//---------------------------------------------------------------------------
+DWORD event_object::wait(DWORD timeout)
+{
+  return is_valid() ? wait_object(event,timeout) : WAIT_FAILED ;
+}
+//---------------------------------------------------------------------------
+BOOL event_object::set()
+{
+  return is_valid() ? SetEvent(event) : FALSE ;
+}
+//---------------------------------------------------------------------------
+BOOL event_object::reset()
+{
+  return is_valid() ? ResetEvent(event) : FALSE ;
+}
+//---------------------------------------------------------------------------
+BOOL event_object::pulse()
+{
+  return is_valid() ? PulseEvent(event) : FALSE ;
+}
+//===========================================================================
+// critical_object
+//---------------------------------------------------------------------------
+critical_object::critical_object()
+{
+  ref = new critical_ref_t ;
+  InitializeCriticalSection(&ref->critical) ;
+}
+//---------------------------------------------------------------------------
+critical_object::critical_object(const critical_object &clone_source)
+{
+  ref = clone_source.ref ;
+  assert(ref!=NULL);
+  enter();
+  ref->ref_count++ ;
+  leave();
+}
+//---------------------------------------------------------------------------
+critical_object::~critical_object()
+{
+  enter();
+  bool empty = !--ref->ref_count ;
+  leave();
+  if(empty) {
+    DeleteCriticalSection(&ref->critical) ;
+    delete ref ;
+  }
+}
+//---------------------------------------------------------------------------
+void critical_object::enter()
+{
+  EnterCriticalSection(&ref->critical) ;
+}
+//---------------------------------------------------------------------------
+BOOL critical_object::try_enter()
+{
+  return TryEnterCriticalSection(&ref->critical) ;
+}
+//---------------------------------------------------------------------------
+void critical_object::leave()
+{
+  LeaveCriticalSection(&ref->critical) ;
+}
+//===========================================================================
+// CAsyncFifo
+//---------------------------------------------------------------------------
+CAsyncFifo::CAsyncFifo(
+  size_t initialPool, size_t maximumPool, size_t emptyBorder,
+  size_t packetSize, DWORD threadWait,int threadPriority)
+  : MaximumPool(max(1,max(initialPool,maximumPool))),
+    TotalPool(min(max(1,initialPool),MaximumPool)),
+    Writing(WRITING_NONE),
+    Indices(MaximumPool),
+    EmptyIndices(MaximumPool),
+    EmptyBorder(emptyBorder),
+    EmptyLimit(0),
+    PacketSize(packetSize),
+    THREADWAIT(threadWait),
+    AllocThread(INVALID_HANDLE_VALUE),
+    AllocOrderEvent(FALSE),
+    AllocatedEvent(FALSE),
+    ModerateAllocating(true),
+    Terminated(false)
+{
+    DWORD flag = HEAP_NO_SERIALIZE ;
+    // obt@
+    PacketSize = packetSize ;
+    BufferPool.resize(MaximumPool);
+#ifdef ASYNCFIFO_HEAPBUFFERPOOL
+    // q[v쐬
+    Heap = HeapCreate(flag, PacketSize*TotalPool, PacketSize*MaximumPool);
+    BufferPool.set_heap(Heap) ;
+    BufferPool.set_heap_flag(flag) ;
+#endif
+    for(size_t i = 0UL ; i < TotalPool ; i++){
+        BufferPool[i].resize(PacketSize);
+        EmptyIndices.push(i) ;
+    }
+#ifdef ASYNCFIFO_HEAPBUFFERPOOL
+    //HeapCompact(Heap, flag) ;
+#endif
+    // AP[VXbh쐬
+    if(MaximumPool>TotalPool) {
+      AllocThread = (HANDLE)_beginthreadex(NULL, 0, AllocThreadProc, this, CREATE_SUSPENDED, NULL) ;
+      if(AllocThread != INVALID_HANDLE_VALUE) {
+          SetThreadPriority(AllocThread,threadPriority);
+          ::ResumeThread(AllocThread) ;
+      }
+    }
+}
+//---------------------------------------------------------------------------
+CAsyncFifo::~CAsyncFifo()
+{
+    // AP[VXbhj
+    Terminated=true ;
+    bool abnormal=false ;
+    if(AllocThread!=INVALID_HANDLE_VALUE) {
+      AllocOrderEvent.set() ;
+      if(wait_object(AllocThread,30000) != WAIT_OBJECT_0) {
+        ::TerminateThread(AllocThread, 0);
+        abnormal=true ;
+      }
+      ::CloseHandle(AllocThread) ;
+    }
+
+#ifdef ASYNCFIFO_HEAPBUFFERPOOL
+    // obt@iɃq[v̂ĵŃ[N͔Ȃj
+    BufferPool.abandon_erase(Heap) ;
+    // q[vj
+    if(!abnormal) HeapDestroy(Heap) ;
+#endif
+}
+//---------------------------------------------------------------------------
+CAsyncFifo::CACHE *CAsyncFifo::BeginWriteBack(bool allocWaiting)
+{
+  exclusive_lock plock(&PurgeExclusive,false) ;
+  exclusive_lock elock(&Exclusive,false) ;
+
+  if(!allocWaiting&&EmptyIndices.size()<=EmptyLimit) {
+    AllocOrderEvent.set() ;
+    return NULL ;
+  }
+
+  plock.lock();
+
+  if(EmptyIndices.size()<=EmptyBorder) {
+    if(allocWaiting) {
+      if(!WaitForAllocation()&&EmptyIndices.empty())
+        return NULL ;
+    }else {
+      // Allocation ordering...
+      AllocOrderEvent.set() ;
+    }
+  }
+
+  elock.lock();
+
+  if(EmptyIndices.empty()) return NULL ;
+  size_t index = EmptyIndices.front() ;
+  EmptyIndices.pop() ;
+  CACHE *cache = &BufferPool[index] ;
+  WriteBackMap[cache] = index ;
+  return cache;
+}
+//---------------------------------------------------------------------------
+bool CAsyncFifo::FinishWriteBack(CAsyncFifo::CACHE *cache,bool fragment)
+{
+  exclusive_lock lock(&Exclusive) ;
+
+  WRITEBACKMAP::iterator pos = WriteBackMap.find(cache) ;
+  if(pos==WriteBackMap.end()) return false ;
+
+  bool result = true ;
+
+  size_t index = pos->second ;
+  if(cache->size()>0) {
+    if(fragment) {
+      exclusive_lock plock(&Exclusive) ;
+      if(Writing==WRITING_FRAGMENT) {
+        Indices.push(WritingIndex) ;
+        Writing=WRITING_NONE ;
+      }
+    }
+    Indices.push(index) ;
+  }else {
+    EmptyIndices.push_front(index) ;
+    result = false ;
+  }
+  WriteBackMap.erase(pos) ;
+
+  return result ;
+}
+//---------------------------------------------------------------------------
+size_t CAsyncFifo::Push(const BYTE *data, DWORD len, bool ignoreFragment,bool allocWaiting)
+{
+  if(!data||!len)
+    return 0 ;
+
+  exclusive_lock plock(&PurgeExclusive,false) ;
+  exclusive_lock elock(&Exclusive,false) ;
+
+
+  if(!allocWaiting&&EmptyIndices.size()<=EmptyLimit) {
+    AllocOrderEvent.set() ;
+    return 0 ;
+  }
+
+  plock.lock();
+
+  size_t sz, n=0 ;
+  for(BYTE *p = const_cast<BYTE*>(data) ; len ; len-=(DWORD)sz, p+=sz) {
+
+    sz=min(len,PacketSize) ;
+
+    if(Writing!=WRITING_FRAGMENT) {
+
+      if(EmptyIndices.size()<=EmptyBorder) {
+        if(allocWaiting) {
+          if(!WaitForAllocation()&&EmptyIndices.empty())
+            return n ;
+        }else {
+          // allocation ordering...
+          AllocOrderEvent.set() ;
+          if(EmptyIndices.size()<=EmptyLimit)
+            return n ;
+        }
+      }
+
+      elock.lock();
+
+      if(EmptyIndices.empty()) return n ;
+      // get the empty index
+      WritingIndex = EmptyIndices.front() ;
+      EmptyIndices.pop() ;
+      Writing = WRITING_PACKET ;
+
+      elock.unlock();
+    }
+
+    // resize and data writing (no lock)
+    switch(Writing) {
+      case WRITING_FRAGMENT: { // fragmentation occurred
+        size_t buf_sz = BufferPool[WritingIndex].size();
+        sz = min(sz, PacketSize - buf_sz);
+        BufferPool[WritingIndex].resize(buf_sz + sz);
+        CopyMemory(BufferPool[WritingIndex].data() + buf_sz, p, sz);
+        break;
+      }
+      case WRITING_PACKET:
+        BufferPool[WritingIndex].resize(sz) ;
+        CopyMemory(BufferPool[WritingIndex].data(), p, sz );
+        break;
+    }
+
+        if (ignoreFragment || BufferPool[WritingIndex].size() == PacketSize) {
+            // push to FIFO buffer
+            elock.lock();
+            Writing = WRITING_NONE;
+            Indices.push(WritingIndex);
+            elock.unlock();
+            n++;
+        }
+        else
+            Writing = WRITING_FRAGMENT;
+
+  }
+  return n ;
+}
+//---------------------------------------------------------------------------
+bool CAsyncFifo::Pop(BYTE **data, DWORD *len,DWORD *remain)
+{
+    exclusive_lock lock(&Exclusive);
+    if(Empty()) {
+        if(len) *len = 0 ;
+        if(data) *data = 0 ;
+        if(remain) *remain = 0 ;
+        return false ;
+    }
+    size_t index = Indices.front() ;
+    if(len) *len = (DWORD)BufferPool[index].size() ;
+    if(data) *data = (BYTE*)BufferPool[index].data() ;
+    EmptyIndices.push(index) ;
+    Indices.pop();
+    if(remain) *remain = (DWORD)Size() ;
+    return true;
+}
+//---------------------------------------------------------------------------
+void CAsyncFifo::Purge(bool purgeWriteBack)
+{
+    // obt@o\f[^p[W
+    exclusive_lock plock(&PurgeExclusive) ;
+    exclusive_lock lock(&Exclusive);
+
+    // ̃f[^p[W
+    while(!Indices.empty()) {
+        EmptyIndices.push(Indices.front()) ;
+        Indices.pop() ;
+    }
+    if(Writing!=WRITING_NONE) {
+        EmptyIndices.push(WritingIndex) ;
+        Writing = WRITING_NONE ;
+    }
+
+    if(purgeWriteBack) {
+        for(WRITEBACKMAP::iterator pos = WriteBackMap.begin() ;
+         pos!= WriteBackMap.end() ; ++pos) {
+            EmptyIndices.push(pos->second) ;
+        }
+        WriteBackMap.clear() ;
+    }
+}
+//---------------------------------------------------------------------------
+unsigned int CAsyncFifo::AllocThreadProcMain ()
+{
+    exclusive_lock elock(&Exclusive,false) ;
+    for(;;) {
+        DWORD dwRet = AllocOrderEvent.wait(THREADWAIT);
+        if (Terminated) break;
+        bool doAllocate = false;
+        switch(dwRet) {
+            case WAIT_OBJECT_0: // Allocation ordered
+                elock.lock() ;
+                doAllocate = Growable() ;
+                if(EmptyIndices.size() > EmptyBorder)
+                  AllocatedEvent.set() ;
+                elock.unlock() ;
+                break ;
+            case WAIT_TIMEOUT:
+                if(!ModerateAllocating) {
+                  elock.lock() ;
+                  doAllocate = Growable() && EmptyIndices.size() <= EmptyBorder ;
+                  elock.unlock() ;
+                }
+                break ;
+            case WAIT_FAILED:
+                return 1;
+        }
+        if(doAllocate) {
+            bool failed=false ;
+            do {
+                elock.unlock() ;
+                BufferPool[TotalPool].resize(PacketSize); // Allocating...
+                if(BufferPool[TotalPool].size()!=PacketSize) {
+                  failed = true ; break ;
+                }
+                elock.lock() ;
+                EmptyIndices.push_front(TotalPool++) ;
+                elock.unlock() ;
+                AllocatedEvent.set();
+                if (Terminated) break;
+                if (ModerateAllocating) break;
+                elock.lock() ;
+            } while (Growable() && EmptyIndices.size() <= EmptyBorder );
+            elock.unlock() ;
+            if(failed)
+              DBGOUT("Async FIFO allocation: allocation failed!\r\n") ;
+            else
+              DBGOUT("Async FIFO allocation: total %d bytes grown.\r\n",
+                  int((TotalPool)*PacketSize)) ;
+        }
+        if (Terminated) break;
+    }
+    return 0 ;
+}
+//---------------------------------------------------------------------------
+unsigned int __stdcall CAsyncFifo::AllocThreadProc (PVOID pv)
+{
+    register CAsyncFifo *this_ = static_cast<CAsyncFifo*>(pv) ;
+    unsigned int result = this_->AllocThreadProcMain() ;
+    _endthreadex(result) ;
+    return result;
+}
+//---------------------------------------------------------------------------
+bool CAsyncFifo::WaitForAllocation()
+{
+    exclusive_lock elock(&Exclusive) ;
+
+    size_t n=EmptyIndices.size() ;
+    if(n>EmptyBorder) {
+      return true ;
+    }
+
+    DBGOUT("Async FIFO allocation: allocation waiting...\r\n") ;
+
+    bool result = false ;
+
+      do {
+        if (!Growable()) break ;
+        elock.unlock() ;
+        AllocOrderEvent.set();
+        DWORD res = AllocatedEvent.wait(THREADWAIT) ;
+        if(res==WAIT_FAILED) break ;
+        elock.lock() ;
+        size_t m = EmptyIndices.size();
+        if (n < m) {
+            if (ModerateAllocating&&m>EmptyLimit)
+                result = true;
+            n = m;
+        }
+        if (n > EmptyBorder) result = true ;
+        if(result) break ;
+      }while(!Terminated) ;
+
+    DBGOUT("Async FIFO allocation: allocation waiting %s.\r\n",result?"completed":"failed") ;
+
+    return result ;
+}
+//===========================================================================
+// CSharedMemory
+//---------------------------------------------------------------------------
+CSharedMemory::CSharedMemory(wstring name, DWORD size)
+  : BaseName(name), HMutex(NULL), HMapping(NULL), PMapView(NULL)
+{
+    wstring mutex_name = BaseName + L"_SharedMemory_Mutex";
+    wstring mapping_name = BaseName + L"_SharedMemory_Mapping";
+
+    HMutex = CreateMutex(NULL, FALSE, mutex_name.c_str());
+    if(Lock()) {
+        HMapping = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
+            PAGE_READWRITE, 0, size, mapping_name.c_str());
+        BOOL map_existed = (GetLastError() == ERROR_ALREADY_EXISTS);
+        SzMapView=0;
+        if (HMapping) {
+            PMapView = MapViewOfFile(HMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);
+            if (PMapView) {
+                SzMapView = size;
+                if (!map_existed) {
+                    //L̈揉
+                    ZeroMemory(PMapView, SzMapView);
+                }
+            }
+        }
+        Unlock();
+    }
+}
+//---------------------------------------------------------------------------
+CSharedMemory::~CSharedMemory()
+{
+    if(PMapView) UnmapViewOfFile(PMapView);
+    if(HMapping) CloseHandle(HMapping);
+    if(HMutex)   CloseHandle(HMutex);
+}
+//---------------------------------------------------------------------------
+bool CSharedMemory::IsValid() const
+{
+    return HMutex && HMapping && PMapView ;
+}
+//---------------------------------------------------------------------------
+bool CSharedMemory::Lock(DWORD timeout) const
+{
+    if(!HMutex) return false ;
+    return wait_object(HMutex, timeout) == WAIT_OBJECT_0 ;
+}
+//---------------------------------------------------------------------------
+bool CSharedMemory::Unlock() const
+{
+    if(!HMutex) return false ;
+    return ReleaseMutex(HMutex) ? true : false ;
+}
+//---------------------------------------------------------------------------
+DWORD CSharedMemory::Read(LPVOID *dst, DWORD sz, DWORD pos
+    , DWORD timeout) const
+{
+    if(!IsValid()||Size()<=pos) return 0;
+    if(sz+pos>Size()) sz = Size()-pos ;
+    if(Lock(timeout)) {
+        CopyMemory(dst,&static_cast<BYTE*>(Memory())[pos],sz);
+        Unlock();
+    }
+    return sz;
+}
+//---------------------------------------------------------------------------
+DWORD CSharedMemory::Write(const LPVOID *src, DWORD sz, DWORD pos
+    , DWORD timeout)
+{
+    if(!IsValid()||Size()<=pos) return 0;
+    if(sz+pos>Size()) sz = Size()-pos ;
+    if(Lock(timeout)) {
+        CopyMemory(&static_cast<BYTE*>(Memory())[pos],src,sz);
+        Unlock();
+    }
+    return sz;
+}
+//===========================================================================
+// Initializer
+//---------------------------------------------------------------------------
+
+  class pryutil_initializer
+  {
+  protected:
+    void init_acalci_constants(bool first) {
+    #define ACALCI_ENTRY_CONST(name) do { \
+        acalci_entry_const(#name,(int)name); \
+        acalci64_entry_const(#name,(__int64)name); \
+        }while(0)
+      if(first) {
+        acalci_entry_const();
+        acalci64_entry_const();
+      }
+      const int n=FALSE,y=TRUE;
+      ACALCI_ENTRY_CONST(NULL);
+      ACALCI_ENTRY_CONST(n);
+      ACALCI_ENTRY_CONST(y);
+      ACALCI_ENTRY_CONST(INT_MIN);
+      ACALCI_ENTRY_CONST(INT_MAX);
+      ACALCI_ENTRY_CONST(INFINITE);
+      ACALCI_ENTRY_CONST(IDLE_PRIORITY_CLASS);
+      ACALCI_ENTRY_CONST(BELOW_NORMAL_PRIORITY_CLASS);
+      ACALCI_ENTRY_CONST(NORMAL_PRIORITY_CLASS);
+      ACALCI_ENTRY_CONST(ABOVE_NORMAL_PRIORITY_CLASS);
+      ACALCI_ENTRY_CONST(HIGH_PRIORITY_CLASS);
+      ACALCI_ENTRY_CONST(REALTIME_PRIORITY_CLASS);
+      ACALCI_ENTRY_CONST(THREAD_PRIORITY_IDLE);
+      ACALCI_ENTRY_CONST(THREAD_PRIORITY_LOWEST);
+      ACALCI_ENTRY_CONST(THREAD_PRIORITY_BELOW_NORMAL);
+      ACALCI_ENTRY_CONST(THREAD_PRIORITY_NORMAL);
+      ACALCI_ENTRY_CONST(THREAD_PRIORITY_ABOVE_NORMAL);
+      ACALCI_ENTRY_CONST(THREAD_PRIORITY_HIGHEST);
+      ACALCI_ENTRY_CONST(THREAD_PRIORITY_TIME_CRITICAL);
+    #undef ACALCI_ENTRY_CONST
+    }
+  public:
+    pryutil_initializer(bool first) {
+      // initialize locale to japanese for the string converters
+      if(first) setlocale(LC_ALL, "japanese") ;
+      // initialize constants
+      init_acalci_constants(first) ;
+    }
+  };
+
+  static pryutil_initializer static_initializer(true);
+
+//---------------------------------------------------------------------------
+} // End of namespace PRY8EAlByw
+//===========================================================================
diff -uPr BonD_FSHybrid-20201009_org/src/pryutil.h BonD_FSHybrid-20201009_mod10.1/src/pryutil.h
--- BonD_FSHybrid-20201009_org/src/pryutil.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/pryutil.h	2021-07-05 17:23:31.000000000 +0900
@@ -0,0 +1,645 @@
+//===========================================================================
+#pragma once
+#ifndef _PRYUTIL_20141218222525309_H_INCLUDED_
+#define _PRYUTIL_20141218222525309_H_INCLUDED_
+//---------------------------------------------------------------------------
+
+#include <Windows.h>
+#include <assert.h>
+#include <string>
+#include <vector>
+#include <map>
+#include <cstdlib>
+#include <algorithm>
+#include <functional>
+#include <stdexcept>
+
+//===========================================================================
+namespace PRY8EAlByw {
+//===========================================================================
+// Functions
+//---------------------------------------------------------------------------
+DWORD Elapsed(DWORD start=0,DWORD end=GetTickCount()) ;
+DWORD PastSleep(DWORD wait=0,DWORD start=GetTickCount()) ;
+
+std::wstring mbcs2wcs(std::string src, UINT code_page=CP_ACP);
+std::string wcs2mbcs(std::wstring src, UINT code_page=CP_ACP);
+
+std::string itos(int val,int radix=10);
+std::wstring itows(int val,int radix=10);
+
+std::string upper_case(std::string str) ;
+std::string lower_case(std::string str) ;
+
+std::string uuid_string();
+
+std::string str_printf(const char *format, ...);
+
+std::string file_drive_of(std::string filename);
+std::string file_path_of(std::string filename);
+std::string file_name_of(std::string filename);
+std::string file_prefix_of(std::string filename);
+std::string file_suffix_of(std::string filename);
+int file_age_of(std::string filename);
+bool file_is_existed(std::string filename);
+bool folder_is_existed(std::string filename);
+
+int acalci(const char *s, int defVal=0, const char **endPtr=NULL, bool allowIndigest=false);
+__int64 acalci64(const char *s, __int64 defVal=0, const char **endPtr=NULL, bool allowIndigest=false);
+
+void acalci_entry_const(const char *name=NULL, int val=0);
+void acalci64_entry_const(const char *name=NULL, __int64 val=0);
+
+//===========================================================================
+// Inline Functions
+//---------------------------------------------------------------------------
+template<class String> String inline trim(const String &str)
+{
+  String str2 ; str2.clear() ;
+  for(typename String::size_type i=0;i<str.size();i++) {
+    if(unsigned(str[i])>0x20UL) {
+      str2 = str.substr(i,str.size()-i) ;
+      break ;
+    }
+  }
+  if(str2.empty()) return str2 ;
+  for(typename String::size_type i=str2.size();i>0;i--) {
+    if(unsigned(str2[i-1])>0x20UL) {
+      return str2.substr(0,i) ;
+    }
+  }
+  str2.clear() ;
+  return str2 ;
+}
+//---------------------------------------------------------------------------
+#if 0
+template<class Container> void inline split(
+	Container &DivStrings, const typename Container::value_type &Text,
+	typename Container::value_type::value_type Delimiter)
+#else
+template<class Container,class String> void inline split(
+	Container &DivStrings/*string container*/, const String &Text,
+	typename String::value_type Delimiter)
+#endif
+{
+  #ifdef _DEBUG
+  assert(typeid(typename Container::value_type)==typeid(Text));
+  #endif
+  typename Container::value_type temp; temp.clear() ;
+  for(typename Container::value_type::size_type i=0;i<Text.size();i++) {
+    if(Text[i]==Delimiter) {
+      DivStrings.push_back(trim(temp));
+      temp.clear();
+      continue;
+    }
+    temp+=Text[i];
+  }
+  if(!trim(temp).empty()) {
+     DivStrings.push_back(trim(temp));
+  }
+}
+//---------------------------------------------------------------------------
+//===========================================================================
+// Classes
+//---------------------------------------------------------------------------
+
+  // ȈՃCxgIuWFNg
+
+class event_object
+{
+private:
+#ifdef _DEBUG
+  int id;
+#endif
+  HANDLE event ;
+  std::wstring name ;
+public:
+  event_object(BOOL initialState_=TRUE/*default:signalized*/,std::wstring name_=L"",BOOL security_=FALSE) ;
+  event_object(const event_object &clone_source) ; // XbhŃCxg𕡐
+  ~event_object() ;
+  std::wstring event_name() const { return name ; }
+  HANDLE handle() const { return event ; }
+  BOOL is_valid() const { return (event&&event!=INVALID_HANDLE_VALUE)?TRUE:FALSE; }
+  // Xbh̉ŕ̃CxgnhJ
+  HANDLE open() const ;
+  // XbhŃVOi܂ŃubNAꂽAIɍĂєVOi
+  DWORD wait(DWORD timeout=INFINITE) ;
+  // VOiiubNĂXbĥ͕̂̈j
+  BOOL set() ;
+  // }jAIȔVOi
+  BOOL reset() ;
+  // VOiiubNĂSXbḧꊇj
+  BOOL pulse() ;
+  // lock(wait) / unlock(set)
+  DWORD lock(DWORD timeout=INFINITE) { return wait(timeout) ; }
+  BOOL unlock() { return set() ; }
+
+};
+
+
+  // ȈՃNeBJIuWFNg
+
+class critical_object
+{
+private:
+  struct critical_ref_t {
+    CRITICAL_SECTION critical ;
+    int ref_count ;
+    critical_ref_t(): ref_count(1) {}
+  };
+  critical_ref_t *ref ;
+public:
+  critical_object() ;
+  critical_object(const critical_object &clone_source) ;
+  ~critical_object() ;
+  CRITICAL_SECTION *handle() const { return &ref->critical ; }
+  // wrapper
+  void enter() ;
+  BOOL try_enter() ;
+  void leave() ;
+  // lock / unlock
+  void lock() { enter() ; }
+  void unlock() { leave() ; }
+};
+
+
+  // XR[vx̎bN^AbN(IuWFNgQƃx)
+
+template <typename locker_t>
+class basic_lock
+{
+private:
+  bool unlocked ;
+  locker_t *locker_ref ;
+public:
+  basic_lock(locker_t *source_ref,bool initial_locking=true)
+    : locker_ref(source_ref) {
+	unlocked = !initial_locking;
+    // VOiԂ܂ŌXbhubN
+    if(initial_locking) locker_ref->lock() ;
+  }
+  ~basic_lock() {
+    // XR[vI_ŃVOiԂ
+    unlock() ;
+  }
+  void unlock() {
+    // XR[v̓rł̃\bhĂяoƂ̎_ŔVOiԂ
+    if(!unlocked) {
+      // VOiԂɃZbg
+      locker_ref->unlock() ;
+      unlocked = true ;
+    }
+  }
+  void lock() {
+    // XR[v̓rł̃\bhĂяoƂ̎_ŔVOiԂɂ
+    if(unlocked) {
+      locker_ref->lock() ;
+      unlocked = false ;
+	}
+  }
+};
+typedef basic_lock<event_object> event_lock ;
+typedef basic_lock<critical_object> critical_lock ;
+
+
+  // XR[vx̎bN^AbN(IuWFNgx)
+
+template <typename locker_t>
+class basic_lock_object
+{
+private:
+  locker_t locker ;
+  bool unlocked ;
+public:
+  basic_lock_object(const locker_t &source_object, bool initial_locking = true)
+    : locker(source_object) {
+    // VOiԂ܂ŌXbhubN
+    unlocked = !initial_locking;
+    // VOiԂ܂ŌXbhubN
+    if (initial_locking) locker.lock();
+  }
+  ~basic_lock_object() {
+    // XR[vI_ŔVOiԂ
+    unlock() ;
+  }
+  void unlock() {
+    // XR[v̓rł̃\bhĂяoƂ̎_ŔVOiԂ
+    if(!unlocked) {
+      // VOiԂɃZbg
+      locker.unlock() ;
+      unlocked = true ;
+    }
+  }
+  void lock() {
+    // XR[v̓rł̃\bhĂяoƂ̎_ŔVOiԂɂ
+    if (unlocked) {
+      locker.lock();
+      unlocked = false;
+    }
+  }
+};
+typedef basic_lock_object<event_object> event_lock_object ;
+typedef basic_lock_object<critical_object> critical_lock_object ;
+
+
+  // exclusive
+
+  #if 0  // 
+  typedef event_object exclusive_object ;
+  #else  // è 
+  typedef critical_object exclusive_object ;
+  #endif
+  typedef basic_lock<exclusive_object> exclusive_lock ;
+  typedef basic_lock_object<exclusive_object> exclusive_lock_object ;
+
+
+  //BUFFER/BUFFERPOOL
+
+template<typename T>
+struct BUFFER {
+    typedef size_t size_type ;
+    typedef T  value_type ;
+    typedef T& reference_type ;
+    typedef T* pointer_type ;
+    BUFFER(size_type size=0) : buff_(NULL), size_(0UL), grow_(0UL) {
+      if(size>0) resize(size) ;
+    }
+    BUFFER(const BUFFER<T> &src)
+     : buff_(NULL), size_(0UL), grow_(0UL) {
+      *this = src ;
+    }
+    BUFFER(const void *buffer, size_type size)
+     : buff_(NULL), size_(0UL), grow_(0UL) {
+      if(size>0) resize(size) ;
+      if(buff_&&size_==size)
+        CopyMemory(buff_,buffer,size*sizeof(value_type)) ;
+    }
+    ~BUFFER() {
+      clear() ;
+    }
+    BUFFER &operator =(const BUFFER<T> &src) {
+      resize(src.size_) ;
+      if(buff_&&size_==src.size_)
+        CopyMemory(buff_,src.buff_,src.size_*sizeof(value_type)) ;
+      return *this ;
+    }
+    void clear() {
+      if(buff_) {
+        std::free(buff_) ;
+        buff_=NULL ; grow_=0UL ; size_=0UL ;
+      }
+    }
+    void resize(size_type size) {
+      if(size_!=size) {
+        if(buff_) {
+          if(size>grow_) {
+            buff_ = (pointer_type)std::realloc(buff_,size*sizeof(value_type)) ;
+            if(buff_) grow_ = size ;
+            else grow_ = 0UL ;
+          }
+        }else {
+          buff_ = (pointer_type)std::malloc(size*sizeof(value_type)) ;
+          if(buff_) grow_ = size ;
+          else grow_ = 0UL ;
+        }
+        if(buff_) size_ = size ;
+        else size_ = 0UL ;
+      }
+    }
+    reference_type operator[](size_type index) { return buff_[index] ; }
+    pointer_type data() { return buff_ ; }
+    size_type size() const { return size_ ; }
+private:
+    pointer_type buff_ ;
+    size_type size_ ;
+    size_type grow_ ;
+};
+
+template<typename T,class Container=std::vector< BUFFER<T> > >
+struct BUFFERPOOL {
+  typedef BUFFER<T> value_type ;
+  typedef BUFFER<T>* pointer_type ;
+  typedef BUFFER<T>& reference_type ;
+  typedef size_t size_type ;
+  void resize(size_type size) {
+    cont_.resize(size) ;
+  }
+  void clear() {
+    cont_.clear() ;
+  }
+  size_type size() {
+    return cont_.size() ;
+  }
+  reference_type operator[](size_t index) {
+    return cont_[index] ;
+  }
+  Container &container() { return cont_ ; }
+private:
+  Container cont_ ;
+};
+
+
+  // HEAPBUFFER/HEAPBUFFERPOOL
+
+template<typename T>
+struct HEAPBUFFER {
+    typedef size_t size_type ;
+    typedef T  value_type ;
+    typedef T& reference_type ;
+    typedef T* pointer_type ;
+    HEAPBUFFER(size_type size=0,HANDLE heap=NULL,DWORD heap_flag=0) : buff_(NULL), size_(0UL), grow_(0UL) {
+      heap_ = heap ? heap : GetProcessHeap() ;
+      heap_flag_ = heap_flag ;
+      if(size>0) resize(size) ;
+    }
+    HEAPBUFFER(const HEAPBUFFER<T> &src)
+     : buff_(NULL), size_(0UL), grow_(0UL), heap_(src.heap_), heap_flag_(src.heap_flag_) {
+      *this = src ;
+    }
+    HEAPBUFFER(const void *buffer, size_type size,HANDLE heap=NULL)
+     : buff_(NULL), size_(0UL), grow_(0UL) {
+      heap_ = heap ? heap : GetProcessHeap() ;
+      if(size>0) resize(size) ;
+      if(buff_&&size_==size)
+        CopyMemory(buff_,buffer,size*sizeof(value_type)) ;
+    }
+    ~HEAPBUFFER() {
+      clear() ;
+    }
+    HEAPBUFFER &operator =(const HEAPBUFFER<T> &src) {
+      if(heap_!=src.heap_) {
+        clear() ;
+        heap_ = src.heap_ ;
+      }
+      heap_flag_ = src.heap_flag_ ;
+      resize(src.size_) ;
+      if(buff_&&size_==src.size_)
+        CopyMemory(buff_,src.buff_,src.size_*sizeof(value_type)) ;
+      return *this ;
+    }
+    void clear() {
+      if(buff_) {
+        HeapFree(heap_,heap_flag_&HEAP_NO_SERIALIZE,buff_) ;
+        buff_=NULL ; grow_=0UL ; size_=0UL ;
+      }
+    }
+    bool abandon(HANDLE heap) {
+      if(heap_==heap) {
+        if(buff_) { buff_=NULL ; grow_=0UL ; size_=0UL ; }
+        return true ;
+      }
+      return false ;
+    }
+    void resize(size_type size) {
+      if(size_!=size) {
+        if(buff_) {
+          if(size>grow_) {
+            buff_ = (pointer_type)HeapReAlloc(heap_,
+              heap_flag_&(HEAP_NO_SERIALIZE|HEAP_ZERO_MEMORY|HEAP_REALLOC_IN_PLACE_ONLY),
+              buff_,size*sizeof(value_type)) ;
+            if(buff_) grow_ = size ;
+            else grow_ = 0UL ;
+          }
+        }else {
+          buff_ = (pointer_type)HeapAlloc(heap_,
+            heap_flag_&(HEAP_NO_SERIALIZE|HEAP_ZERO_MEMORY),size*sizeof(value_type)) ;
+          if(buff_) grow_ = size ;
+          else grow_ = 0UL ;
+        }
+        if(buff_) size_ = size ;
+        else size_ = 0UL ;
+      }
+    }
+    reference_type operator[](size_type index) { return buff_[index] ; }
+    pointer_type data() { return buff_ ; }
+    size_type size() const { return size_ ; }
+    void set_heap_flag(DWORD flag) { heap_flag_ = flag ; }
+    void set_heap(HANDLE heap) {
+      if(!heap) heap=GetProcessHeap() ;
+      if(heap_!=heap) {
+        size_type sz = size() ;
+        if(sz) {
+          pointer_type buffer = (pointer_type)HeapAlloc(heap,
+            heap_flag_&(HEAP_NO_SERIALIZE|HEAP_ZERO_MEMORY),sz*sizeof(value_type)) ;
+          if(buffer) {
+            CopyMemory(buffer,buff_,sz*sizeof(value_type)) ;
+            clear() ;
+            buff_ = buffer ;
+            size_ = sz ; grow_ = sz ;
+          }else {
+            clear() ;
+          }
+        }
+        heap_ = heap ;
+      }
+    }
+private:
+    HANDLE heap_ ;
+    DWORD heap_flag_ ;
+    pointer_type buff_ ;
+    size_type size_ ;
+    size_type grow_ ;
+};
+
+template<typename T,class Container=std::vector< HEAPBUFFER<T> > >
+struct HEAPBUFFERPOOL {
+  typedef HEAPBUFFER<T> value_type ;
+  typedef HEAPBUFFER<T>* pointer_type ;
+  typedef HEAPBUFFER<T>& reference_type ;
+  typedef size_t size_type ;
+  void set_heap(HANDLE heap) {
+    std::for_each(cont_.begin(),cont_.end(),
+      std::bind2nd(std::mem_fun_ref(&value_type::set_heap),heap));
+  }
+  void set_heap_flag(DWORD flag) {
+    std::for_each(cont_.begin(),cont_.end(),
+      std::bind2nd(std::mem_fun_ref(&value_type::set_heap_flag),flag));
+  }
+  void abandon_erase(HANDLE heap) {
+    cont_.erase(std::remove_if(cont_.begin(),cont_.end(),
+      std::bind2nd(std::mem_fun_ref(&value_type::abandon),heap)),cont_.end());
+  }
+  void resize(size_type size) {
+    cont_.resize(size) ;
+  }
+  void clear() {
+    cont_.clear() ;
+  }
+  size_type size() {
+    return cont_.size() ;
+  }
+  reference_type operator[](size_t index) {
+    return cont_[index] ;
+  }
+  Container &container() { return cont_ ; }
+private:
+  Container cont_ ;
+};
+
+  // fixed_queue (AP[VȂ)
+
+template<typename T>
+class fixed_queue
+{
+public:
+  typedef T value_type ;
+  typedef T& reference_type ;
+  typedef T* pointer_type ;
+  typedef size_t size_type ;
+protected:
+  pointer_type buff_ ;
+  size_type cue_ ;
+  size_type size_ ;
+  size_type grew_ ;
+public:
+  fixed_queue(size_type fixed_size)
+    : grew_(fixed_size), cue_(0), size_(0) {
+    buff_ = new value_type[grew_] ;
+  }
+  ~fixed_queue() {
+    delete [] buff_ ;
+  }
+  size_type capacity() const { return grew_ ; }
+  size_type size() const { return size_ ; }
+  bool empty() const { return size_==0 ; }
+  bool full() const { return size_>=grew_ ; }
+  bool push(const value_type &val) {
+    if(full()) return false ;
+    buff_[cue_+size_-(cue_+size_<grew_?0:grew_)] = val ;
+    size_++ ;
+    return true ;
+  }
+  bool push_front(const value_type &val) {
+    if(full()) return false ;
+	buff_[cue_?--cue_:cue_=grew_-1] = val ;
+	size_++ ;
+	return true ;
+  }
+  bool pop() {
+    if(empty()) return false ;
+    if(++cue_>=grew_) cue_=0 ;
+    size_-- ;
+    return true ;
+  }
+  bool pop_back() {
+    if(empty()) return false ;
+    size_-- ;
+    return true ;
+  }
+  void clear() { cue_ = 0 ; size_ = 0 ; }
+  reference_type front() {
+  #ifdef _DEBUG
+    if(empty()) throw std::range_error("fixed_queue: front() range error.") ;
+  #endif
+    return buff_[cue_] ;
+  }
+  reference_type back() {
+  #ifdef _DEBUG
+    if(empty()) throw std::range_error("fixed_queue: back() range error.") ;
+  #endif
+    return buff_[cue_+size_-1-(cue_+size_-1<grew_?0:grew_)] ;
+  }
+  reference_type operator[](size_type index) {
+  #ifdef _DEBUG
+    if(index>=size()) throw std::range_error("fixed_queue: operator[] range error.") ;
+  #endif
+    return buff_[cue_+index-(cue_+index<grew_?0:grew_)] ;
+  }
+};
+
+  // CAsyncFifo
+
+    #define ASYNCFIFO_HEAPBUFFERPOOL
+
+class CAsyncFifo
+{
+public:
+  #ifdef ASYNCFIFO_HEAPBUFFERPOOL
+  typedef HEAPBUFFER<BYTE> CACHE ;
+  #else
+  typedef BUFFER<BYTE> CACHE ;
+  #endif
+  typedef std::map<CACHE*,size_t/*index*/> WRITEBACKMAP ;
+  enum WRITING {
+	  WRITING_NONE,
+	  WRITING_PACKET,
+	  WRITING_FRAGMENT
+  };
+private:
+  size_t MaximumPool ;
+  size_t TotalPool ;
+  size_t EmptyBorder ;
+  size_t EmptyLimit ;
+  size_t PacketSize ;
+  DWORD THREADWAIT ;
+  exclusive_object Exclusive, PurgeExclusive ;
+  WRITING Writing ;
+  size_t WritingIndex ;
+  #ifdef ASYNCFIFO_HEAPBUFFERPOOL
+  HANDLE Heap ;
+  HEAPBUFFERPOOL<BYTE> BufferPool ;
+  #else
+  BUFFERPOOL<BYTE> BufferPool ;
+  #endif
+  fixed_queue<size_t> Indices;
+  fixed_queue<size_t> EmptyIndices;
+  WRITEBACKMAP WriteBackMap ;
+  HANDLE AllocThread ;
+  event_object AllocOrderEvent, AllocatedEvent ;
+  unsigned int AllocThreadProcMain () ;
+  static unsigned int __stdcall AllocThreadProc (PVOID pv) ;
+  bool ModerateAllocating ;
+  bool Terminated ;
+public:
+  CAsyncFifo(
+    size_t initialPool, size_t maximumPool, size_t emptyBorder,
+    size_t packetSize, DWORD threadWait=1000,
+	int threadPriority=THREAD_PRIORITY_HIGHEST ) ;
+  virtual ~CAsyncFifo() ;
+  size_t Size() const { return Indices.size() ; }
+  bool Empty() const { return Indices.empty() ; }
+  bool Full() const { return EmptyIndices.empty() ; }
+  bool Pushable() const { return EmptyIndices.size()>EmptyLimit ; }
+  bool Growable() const { return TotalPool<MaximumPool ; }
+  CACHE *BeginWriteBack(bool allocWaiting=false) ;
+  bool FinishWriteBack(CACHE *cache,bool fragment=false);
+  size_t Push(const BYTE *data, DWORD len, bool ignoreFragment=false, bool allocWaiting=false) ;
+  bool Pop(BYTE **data, DWORD *len, DWORD *remain) ;
+  void Purge(bool purgeWriteBack=false) ;
+  void SetModerateAllocating(bool Moderate) { ModerateAllocating=Moderate ; }
+  void SetEmptyLimit(size_t emptyLimit) { EmptyLimit = min(emptyLimit,EmptyBorder) ; }
+  bool WaitForAllocation() ;
+};
+
+
+  // CSharedMemory (vZXԃL)
+
+class CSharedMemory
+{
+private:
+	std::wstring BaseName;
+	HANDLE HMutex;
+	HANDLE HMapping;
+	LPVOID PMapView;
+	DWORD SzMapView;
+protected:
+    LPVOID Memory() const { return PMapView; }
+	bool Lock(DWORD timeout = INFINITE) const ;
+    bool Unlock() const ;
+protected:
+	CSharedMemory(std::wstring name, DWORD size);
+	virtual ~CSharedMemory();
+public:
+	std::wstring Name() const { return BaseName; }
+	virtual bool IsValid() const ;
+	virtual DWORD Read(LPVOID *dst, DWORD sz, DWORD pos, DWORD timeout=INFINITE) const ;
+	virtual DWORD Write(const LPVOID *src, DWORD sz, DWORD pos, DWORD timeout=INFINITE);
+	DWORD Size() const { return SzMapView; }
+};
+
+//---------------------------------------------------------------------------
+} // End of namespace PRY8EAlByw
+//===========================================================================
+using namespace PRY8EAlByw ;
+//===========================================================================
+#endif // _PRYUTIL_20141218222525309_H_INCLUDED_
diff -uPr BonD_FSHybrid-20201009_org/src/targetver.h BonD_FSHybrid-20201009_mod10.1/src/targetver.h
--- BonD_FSHybrid-20201009_org/src/targetver.h	2015-12-09 05:01:10.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/targetver.h	2022-05-02 23:27:53.000000000 +0900
@@ -1,4 +1,4 @@
 #pragma once
 
-#define _WIN32_WINNT 0x0502
+#define _WIN32_WINNT 0x0600
 #include <SDKDDKVer.h>
diff -uPr BonD_FSHybrid-20201009_org/src/tc90522.c BonD_FSHybrid-20201009_mod10.1/src/tc90522.c
--- BonD_FSHybrid-20201009_org/src/tc90522.c	2016-02-12 01:20:50.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/tc90522.c	2022-05-02 01:17:26.000000000 +0900
@@ -4,7 +4,16 @@
   2016-02-12
 */
 
+#ifdef LEGACY_STDINT
+
+#include "stdint_.h"
+
+#else
+
 #include <stdint.h>
+
+#endif
+
 #include <errno.h>
 #include <string.h>
 #include <malloc.h>
@@ -340,39 +349,72 @@
 static unsigned  get_ts_id(struct i2c_device_st* const  dev, const unsigned num)
 {
 	int r;
-	uint8_t utmp;
-	unsigned uval;
+	uint8_t utmp, high, low;
 	//if(num >= 8)  return 0;
 	if(( r = readReg(dev, 0xc3, &utmp ) ))  goto err1;
 	if(utmp & 0x10) {  //# TMCC error
 		goto err0;
 	}
-	if(( r = readReg(dev, 0xce + (num * 2), &utmp ) ))  goto err1;
-	uval = utmp << 8;
-	if(( r = readReg(dev, 0xcf + (num * 2), &utmp ) ))  goto err1;
-	uval |= utmp & 0xFF;
-	return uval;
+	low=high=0xFF;
+	if(( r = readReg(dev, 0xce + (num << 1), &high ) ))  goto err1;
+	if(( r = readReg(dev, 0xcf + (num << 1), &low ) ))  goto err1;
+	if(high==0xFF&&low!=0xFF) //# retry
+		if(( r = readReg(dev, 0xce + (num << 1), &high ) ))  goto err1;
+	return (unsigned) high<<8 | (unsigned) low;
 err1:
 	warn_info(r,"failed");
 err0:
 	return 0;
 }
 
+static unsigned  select_ts_id(struct i2c_device_st* const  dev, const unsigned tsSel)
+{
+	//# direct indexed
+	unsigned num,tsid = get_ts_id(dev,tsSel) ;
+	if(tsid!=0&&tsid!=0xFFFF&&(tsid&7)==tsSel) return tsid ;
+	//# binary search
+	for(num=0;num<=7;num++) {
+		if(num==tsSel) continue ;
+		tsid = get_ts_id(dev,num) ;
+		if(tsid!=0&&tsid!=0xFFFF&&(tsid&7)==tsSel) return tsid ;
+	}
+	return 0 ;
+}
+
+int tc90522_setTSID(void * const state, const unsigned devnum, const unsigned ts_id)
+{
+	int ret;
+	struct state_st* const s = state;
+	struct i2c_device_st* const  dev = &(s->i2c_dev[devnum]);
+
+	if(devnum & 1) { // sate
+		if(( ret = writeReg(dev, 0x8f, (ts_id >> 8) & 0xFF, 0) ))  goto err1;
+		if(( ret = writeReg(dev, 0x90, ts_id & 0xFF, 0) ))  goto err1;
+	}else {  // terra
+		//# select ignore layer (4:A, 2:B, 1:C)  e.g.(A+B= OneSeg + FullSeg  or  A= FullSeg)
+		if(( ret = writeReg(dev, 0x71, ts_id & 0x07, 0x07) ))  goto err1;
+	}
+	return 0;
+err1:
+	warn_info(ret,"failed");
+	return ret;
+}
+
 int tc90522_selectStream(void * const state, const unsigned devnum, const unsigned tsSel)
 {
 	int ret;
 	struct state_st* const s = state;
 	struct i2c_device_st* const  dev = &(s->i2c_dev[devnum]);
+	unsigned ts_id;
 
 	if(! dev->addr) {
 		warn_info(0,"invalid device %u", devnum);
 		return -2;
 	}
 	if(devnum & 1) {  //# sate
-		unsigned ts_id;
 		//# select TS ID
 		if(8 > tsSel) {
-			ts_id = get_ts_id(dev, tsSel);
+			ts_id = select_ts_id(dev, tsSel);
 			if(0 == ts_id || 0xFFFF == ts_id) {  //# empty
 				//warn_msg(0,"TS_ID(%u)= %04X invalid!", tsSel, ts_id);
 				ret = 1;
@@ -381,14 +423,10 @@
 		}else{
 			ts_id = tsSel;
 		}
-		if(( ret = writeReg(dev, 0x8f, (ts_id >> 8) & 0xFF, 0) ))  goto err1;
-		if(( ret = writeReg(dev, 0x90, ts_id & 0xFF, 0) ))  goto err1;
-
 	}else{  //# terra
-		//# select ignore layer (4:A, 2:B, 1:C)  e.g.(A+B= OneSeg + FullSeg  or  A= FullSeg)
-		if(( ret = writeReg(dev, 0x71, tsSel & 0x07, 0x07) ))  goto err1;
-	}
-
+		ts_id = tsSel ;
+ 	}
+	if(( ret = tc90522_setTSID(state, devnum, ts_id) )) goto err1;
 	return 0;
 err1:
 	warn_info(ret,"failed");
@@ -411,8 +449,8 @@
 	}
 	if(devnum & 1) {  //# sate
 		ptr[0] = 0;
-		if(( ret = readReg(dev, 0xe6, &ptr[2] ) ))  goto err1;
-		if(( ret = readReg(dev, 0xe7, &ptr[3] ) ))  goto err1;
+		if(( ret = readReg(dev, 0xe6, &ptr[2] ) ))  goto err1; //# tsido - hi
+		if(( ret = readReg(dev, 0xe7, &ptr[3] ) ))  goto err1; //# tsido - lo
 		if(( ret = readReg(dev, 0xe8, &utmp ) ))  goto err1;
 		lval[0] = (utmp >> 4) & 0x7;
 		lval[1] = utmp & 0x7;
@@ -449,6 +487,12 @@
 				ptr[2] = 5;
 			}
 		}
+		ptr+=4 ; //# offset:28
+		//# tsid0 - tsid7
+		for( j=0; j<8; j++ ) {
+			if(( ret = readReg(dev, 0xce + (j << 1), ptr++ ) ))  goto err1; //# tsid# hi
+			if(( ret = readReg(dev, 0xcf + (j << 1), ptr++ ) ))  goto err1; //# tsid# lo
+		}
 	}else{  //# terra
 		uint8_t txmode;
 		if(( ret = readReg(dev, 0xb0, &utmp ) ))  goto err1;
@@ -576,7 +620,7 @@
 
 int tc90522_readStatistic(void * const state, const unsigned devnum, unsigned* const data)
 {
-	int ret;
+	int ret=0;
 	struct state_st* const s = state;
 	struct i2c_device_st* const  dev = &(s->i2c_dev[devnum]);
 	unsigned uval;
@@ -586,6 +630,7 @@
 		warn_info(0,"invalid device %u", devnum);
 		return -2;
 	}
+
 	if(devnum & 1) {  //# sate
 		//# status
 		if(( ret = readReg(dev, 0xc3, &utmp ) ))  goto err1;
@@ -633,9 +678,9 @@
 		}
 	}
 
-	return 0;
 err1:
-	warn_info(ret,"failed");
+
+	if(ret) warn_info(ret,"failed");
 	return ret;
 }
 
diff -uPr BonD_FSHybrid-20201009_org/src/tc90522.h BonD_FSHybrid-20201009_mod10.1/src/tc90522.h
--- BonD_FSHybrid-20201009_org/src/tc90522.h	2016-02-11 03:40:42.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/tc90522.h	2019-12-07 23:35:12.000000000 +0900
@@ -13,6 +13,7 @@
 int tc90522_selectDevice(void * const, const unsigned devnum);
 int tc90522_powerControl(void * const, const unsigned devnum, const int isWake);
 int tc90522_resetDemod(void * const, const unsigned devnum);
+int tc90522_setTSID(void * const, const unsigned devnum, const unsigned ts_id);
 int tc90522_selectStream(void * const, const unsigned devnum, const unsigned tsSel);
 int tc90522_readTMCC(void * const, const unsigned devnum, void* const pData);
 int tc90522_readStatistic(void * const, const unsigned devnum, unsigned* const data);
diff -uPr BonD_FSHybrid-20201009_org/src/tda20142.c BonD_FSHybrid-20201009_mod10.1/src/tda20142.c
--- BonD_FSHybrid-20201009_org/src/tda20142.c	2016-01-28 22:00:38.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/tda20142.c	2019-12-16 06:15:18.000000000 +0900
@@ -4,7 +4,16 @@
   2016-01-28
 */
 
+#ifdef LEGACY_STDINT
+
+#include "stdint_.h"
+
+#else
+
 #include <stdint.h>
+
+#endif
+
 #include <errno.h>
 #include <string.h>
 #include <malloc.h>
@@ -240,7 +249,7 @@
 	freq_val += uval * denomi;
 	denomi *= mval;
 	dmsgn("freqVal= %u +%u/%u, ", u2val, freq_val, denomi);
-	
+
 	//# remainder * 65536 / denominator
 	mval = (u3val >> 16) & 0xFF;
 	freq_val <<= 8;
@@ -408,4 +417,4 @@
 }
 
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/tsbuff.h BonD_FSHybrid-20201009_mod10.1/src/tsbuff.h
--- BonD_FSHybrid-20201009_org/src/tsbuff.h	2016-01-23 16:17:38.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/tsbuff.h	2020-11-22 23:22:28.000000000 +0900
@@ -1,16 +1,60 @@
-/* SunPTV-USB   (c) 2016 trinity19683
+/* fsusb2i   (c) 2015-2016 trinity19683
   TS buffer, transfer parameters (MS-Windows)
   tsbuff.h
-  2016-01-23
+  2016-01-22
 */
 #pragma once
 
-//# TS Buffer size = 3584 KiB
-#define TS_BufSize  3670016
+#define ROUNDUP(n,w) (((n) + (w)) & ~(unsigned)(w))
+
+#ifdef INCLUDE_ISOCH_XFER // Isochronous & Bulk hybrid
+
+//# Isochronous Frames per a Packet
+#define ISOCH_PacketFrames	48
+
+//# Isochronous Frame size (real packet size)
+#define ISOCH_FrameSize		(5*188)
+
+//# TS Packet size (faked packet size)
+#define TS_PacketSize	(ISOCH_FrameSize*ISOCH_PacketFrames)
+
+#else // Bulk only
+
+//# TS Packet size (real packet size)
+#define TS_PacketSize	47752 // org : 46060
+
+#endif
+
+//# TS Buffer size
+#define TS_CalcBufSize(PacketSize,Packets)	(ROUNDUP(PacketSize,0x1FF)*Packets)
+#define TS_BufSize		TS_CalcBufSize(TS_PacketSize)
+
+//# number of keeping read only bytes before the buffer busy memory area
+#define TS_CalcDeadZone(BufSize)	(BufSize/4)
+#define TS_DeadZone		TS_CalcDeadZone(TS_BufSize)
 
 //# max number of submitted IO requests
-#define TS_MaxNumIO  24
-//# IO polling timeout (msec)
-#define TS_PollTimeout  100
+#define TS_MaxNumIO		256
+
+//# 2020-11-22
+//#   Removed the definition "TS_BufPackets".
+//#     It's auto calculated on tsthread_create() function of "tsthread.c".
+//# 2020-11-3
+//#   Moved the definition "ROUNDUP" from the source file "tsthread.c".
+//#   Removed the definition "TS_PollTimeout"
+//#     that is moved to "TSTHREAD_POLL_TIMEOUT" as variable on "tsthread.c".
+//#   Removed the definition "TS_SubmitTimeout"
+//#     that is moved to "TSTHREAD_SUBMIT_TIMEOUT" as variable on "tsthread.c".
+//#   Removed the definition "TS_DeltaSize".
+//# 2020-10-31
+//#   Added the definition "TS_SubmitTimeout".
+//# 2020-10-5
+//#   Added the definition "ISOCH_PacketFrames".
+//#   Added the definition "ISOCH_FrameSize" for the isochronous transfer.
+//# 2018-3-1
+//#   Added the definition "TS_DeadZone".
+//#   Moved the definition "TS_BulkSize" from the source file "it9175.c".
+//#   Rename the definition "TS_BulkSize" to "TS_PacketSize".
+//# Fixed by 2018-2020 LVhJPic0JSk5LiQ1ITskKVk9UGBg
 
 /*EOF*/
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/tsthread.c BonD_FSHybrid-20201009_mod10.1/src/tsthread.c
--- BonD_FSHybrid-20201009_org/src/tsthread.c	2016-02-18 20:21:28.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/tsthread.c	2022-08-11 13:39:37.000000000 +0900
@@ -1,329 +1,1165 @@
-/* fsusb2i   (c) 2015-2016 trinity19683
-  TS USB I/O thread (MS-Windows)
-  tsthread.c
-  2016-02-18
-*/
-#include "stdafx.h"
-#include <errno.h>
-#include <string.h>
-#include <process.h>
-#include <WinUSB.h>
-
-#include "usbops.h"
-#include "osdepend.h"
-#include "tsbuff.h"
-#include "tsthread.h"
-
-#define ROUNDUP(n,w) (((n) + (w)) & ~(unsigned)(w))
-
-struct TSIO_CONTEXT {
-	OVERLAPPED ol;
-	int index;
-
-};
-
-struct tsthread_param {
-	HANDLE hThread;    //# handle to thread data
-	unsigned char volatile  flags;
-	/* if 0x01 flagged, issue a new request.
-	   if 0x02 flagged, cancel requests and stop thread.
-	*/
-	const struct usb_endpoint_st*  pUSB;
-	char* buffer;    //# data buffer (in heap memory)
-	int*  actual_length;    //# actual length of each buffer block
-	unsigned buff_unitSize;
-	int buff_num;
-	int buff_push;
-	int buff_pop;
-	struct TSIO_CONTEXT ioContext[TS_MaxNumIO];
-	HANDLE hTsEvent;
-
-};
-
-
-static int submitURB(const tsthread_ptr tptr)
-{
-	//# isochronous URB request
-	struct tsthread_param* const ps = tptr;
-	DWORD i, dRet = 0;
-
-	for(i = 0; i < TS_MaxNumIO; i++) {
-		struct TSIO_CONTEXT* const pContext = &ps->ioContext[i];
-		BOOL bRet;
-		if(0 <= pContext->index) continue;
-
-		ZeroMemory( &pContext->ol, sizeof(OVERLAPPED));
-		pContext->ol.hEvent = ps->hTsEvent;
-		pContext->index = ps->buff_push;
-		if(ps->pUSB->endpoint & 0x100) { //# Isochronous
-
-			bRet = FALSE;
-			dRet = ERROR_INVALID_FUNCTION;
-			tsthread_stop(ps);
-
-		}
-		else {
-			ps->actual_length[ps->buff_push] = -2;
-			bRet = WinUsb_ReadPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF, ps->buffer + (ps->buff_push * ps->buff_unitSize), ps->buff_unitSize, NULL, &(pContext->ol));
-			dRet = GetLastError();
-		}
-		if (FALSE == bRet && ERROR_IO_PENDING != dRet) {
-			warn_info(dRet, "submitURB failed");
-			pContext->index = -1;
-		}
-		else {
-			int next_index = ps->buff_push;
-			next_index++;
-			ps->buff_push = (next_index < ps->buff_num) ? next_index : 0;
-			dRet = 0;
-		}
-
-		if (bRet) {
-			//# completed (nowait)
-			SetEvent(ps->hTsEvent);
-		}
-		if(dRet) break;
-	}
-
-	return dRet;
-}
-
-static int reapURB(const tsthread_ptr tptr)
-{
-	struct tsthread_param* const ps = tptr;
-	DWORD i, countURB = 0;
-
-	for(i = 0; i < TS_MaxNumIO; i++) {
-		struct TSIO_CONTEXT* const pContext = &ps->ioContext[i];
-		BOOL bRet;
-		DWORD dRet, bytesRead = 0;
-		if(0 > pContext->index) continue;
-
-		bRet = WinUsb_GetOverlappedResult( ps->pUSB->fd, &(pContext->ol), &bytesRead, FALSE );
-		dRet = GetLastError();
-		if(FALSE == bRet && ERROR_IO_INCOMPLETE == dRet) {
-			//# incomplete
-			countURB++;
-		}else{
-			int* const   pLen = &(ps->actual_length[pContext->index]);
-			if(ps->pUSB->endpoint & 0x100) { //# Isochronous
-
-			}
-			else {
-				if (bRet) {
-					//# success
-					if (ps->buff_unitSize < bytesRead) {
-						warn_info(bytesRead, "reapURB overflow");
-						bytesRead = ps->buff_unitSize;
-					}
-					pLen[0] = bytesRead;
-					//dmsgn("reapURB%u=%d, ",i,bytesRead);
-				}
-				else {
-					//# failed
-					pLen[0] = 0;
-					warn_msg(dRet, "reapURB%u", i);
-				}
-			}
-			pContext->index = -1;
-		}
-	}
-
-	return countURB;
-}
-
-/* TS thread function issues URB requests. */
-static unsigned int __stdcall tsthread(void* const param)
-{
-	struct tsthread_param* const ps = param;
-	ps->buff_push = 0;
-
-	for(;;) {
-		DWORD dRet;
-		if(ps->flags & 0x01) {
-			//# continue to issue a new URB request
-			submitURB(ps);
-		}
-		if(ps->flags & 0x02) {
-			//# canceled
-			reapURB(ps);
-			break; 
-		}
-
-		dRet = WaitForSingleObject( ps->hTsEvent , TS_PollTimeout );
-		if(WAIT_OBJECT_0 == dRet || WAIT_TIMEOUT == dRet) {
-			if(reapURB(ps) < 0) break;
-			//# timeout
-			if(WAIT_TIMEOUT == dRet && ps->flags & 0x01) {
-				dmsg("poll timeout");
-			}
-		}else{
-			dRet = GetLastError();
-			warn_info(dRet,"poll failed");
-			break;
-		}
-	}
-	_endthreadex( 0 );
-	return 0;
-}
-
-/* public function */
-
-int tsthread_create(tsthread_ptr* const tptr, const struct usb_endpoint_st* const pusbep)
-{
-	struct tsthread_param* ps;
-	DWORD dwRet, i;
-
-	{//#
-		const unsigned param_size  = ROUNDUP(sizeof(struct tsthread_param), 0xF);
-		const unsigned buffer_size = ROUNDUP(TS_BufSize ,0xF);
-		const unsigned unitSize = ROUNDUP(pusbep->xfer_size ,0x1FF);
-		const unsigned unitNum = TS_BufSize / unitSize;
-		const unsigned actlen_size = sizeof(int) * unitNum;
-		char *ptr, *buffer_ptr;
-		unsigned totalSize = param_size + actlen_size + buffer_size;
-		ptr = uHeapAlloc( totalSize );
-		if(NULL == ptr) {
-			dwRet = GetLastError();
-			warn_msg(dwRet,"failed to allocate TS buffer");
-			return -1;
-		}
-		buffer_ptr = ptr;
-		ptr += buffer_size;
-		ps = (struct tsthread_param*) ptr;
-		ps->buffer = buffer_ptr;
-		ptr += param_size;
-		ps->actual_length = (int*)ptr;
-		//ptr += actlen_size;
-		ps->buff_unitSize = unitSize;
-		ps->buff_num = unitNum;
-		ps->actual_length[0] = -1;   //# the first block is not-used
-
-	}
-	ps->pUSB = pusbep;
-	ps->flags = 0;
-	ps->buff_pop = 0;
-	
-	for(i = 0; i < TS_MaxNumIO; i++) {
-		ps->ioContext[i].index = -1;    //# mark it unused
-	}
-	ps->hTsEvent = CreateEvent ( NULL, FALSE, TRUE, NULL );
-	//# USB endpoint
-	WinUsb_ResetPipe(pusbep->fd, pusbep->endpoint & 0xFF);
-	i = 0x01;
-	WinUsb_SetPipePolicy(pusbep->fd, pusbep->endpoint & 0xFF, RAW_IO, sizeof(UCHAR), &i);
-	WinUsb_SetPipePolicy(pusbep->fd, pusbep->endpoint & 0xFF, AUTO_CLEAR_STALL, sizeof(UCHAR), &i);
-
-#ifdef _DEBUG
-	dwRet = sizeof(i);
-	WinUsb_GetPipePolicy(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF, MAXIMUM_TRANSFER_SIZE, &dwRet, &i);
-	dmsg("MAX_TRANSFER_SIZE=%u", i);
-#endif
-
-	ps->hThread = (HANDLE)_beginthreadex( NULL, 0, tsthread, ps, 0, NULL );
-	if(INVALID_HANDLE_VALUE == ps->hThread) {
-		warn_info(errno,"tsthread_create failed");
-		uHeapFree(ps->buffer);
-		return -1;
-	}else{
-		SetThreadPriority( ps->hThread, THREAD_PRIORITY_TIME_CRITICAL );
-	}
-	*tptr = ps;
-	return 0;
-}
-
-void tsthread_destroy(const tsthread_ptr ptr)
-{
-	struct tsthread_param* const p = ptr;
-
-	tsthread_stop(ptr);
-	p->flags |= 0x02;    //# canceled = T
-	SetEvent(p->hTsEvent);
-	if(WaitForSingleObject(p->hThread, 1000) != WAIT_OBJECT_0) {
-		warn_msg(GetLastError(),"tsthread_destroy timeout");
-		TerminateThread(p->hThread, 0);
-	}
-	CloseHandle(p->hTsEvent);
-	CloseHandle(p->hThread);
-
-	uHeapFree(p->buffer);
-}
-
-void tsthread_start(const tsthread_ptr ptr)
-{
-	struct tsthread_param* const p = ptr;
-	WinUsb_FlushPipe(p->pUSB->fd, p->pUSB->endpoint & 0xFF);
-	p->flags |= 0x01;    //# continue = T
-	if(p->pUSB->startstopFunc)
-		p->pUSB->startstopFunc(p->pUSB->dev, 1);
-
-	SetEvent(p->hTsEvent);
-}
-
-void tsthread_stop(const tsthread_ptr ptr)
-{
-	struct tsthread_param* const p = ptr;
-
-	p->flags &= ~0x01U;    //# continue = F
-	if(p->pUSB->startstopFunc)
-		p->pUSB->startstopFunc(p->pUSB->dev, 0);
-
-	if(!(p->pUSB->endpoint & 0x100) ) { //# Bulk
-		WinUsb_AbortPipe(p->pUSB->fd, p->pUSB->endpoint & 0xFF);
-	}
-}
-
-int tsthread_read(const tsthread_ptr tptr, void ** const ptr)
-{
-	struct tsthread_param* const ps = tptr;
-	int i, j;
-	i = tsthread_readable(tptr);
-	if(0 >= i) return 0;
-
-	j = ps->buff_pop;
-	ps->actual_length[ps->buff_pop] = -1;
-	if(ptr) {
-		*ptr = ps->buffer + (j * ps->buff_unitSize);
-		ps->buff_pop = (ps->buff_num - 1 > j) ? j + 1 : 0;
-	}else{
-		ps->actual_length[ps->buff_push] = -1;
-		ps->buff_pop = ps->buff_push;
-	}
-	return i;
-}
-
-int tsthread_readable(const tsthread_ptr tptr)
-{
-	struct tsthread_param* const ps = tptr;
-	int j = ps->buff_pop;
-
-	if(0 > j || ps->buff_num <= j) {  //# bug check
-		warn_info(j,"ts.buff_pop Out of range");
-		ps->buff_pop = 0;
-		return 0;
-	}
-	do {  //# skip empty blocks
-		if(0 != ps->actual_length[j] ) break;
-		if(ps->buff_num -1 > j) {
-			j++;
-		}else{
-			j = 0;
-		}
-	} while(j != ps->buff_pop);
-	ps->buff_pop = j;
-	return ps->actual_length[j];
-}
-
-int tsthread_wait(const tsthread_ptr tptr, const int timeout)
-{
-	struct tsthread_param* const ps = tptr;
-	DWORD dRet = WaitForSingleObject( ps->hTsEvent , timeout );
-	if(WAIT_OBJECT_0 == dRet)  return 1;
-	else if(WAIT_TIMEOUT == dRet)  return 0;
-
-	warn_info(dRet,"poll failed");
-	return -1;
-}
-
-
+/* fsusb2i   (c) 2015-2016 trinity19683
+  TS USB I/O thread (MS-Windows)
+  tsthread.c
+  2016-02-18
+*/
+
+#include "stdafx.h"
+#include <errno.h>
+#include <string.h>
+#include <process.h>
+#include <WinUSB.h>
+#include <assert.h>
+
+#include "usbops.h"
+#include "osdepend.h"
+#include "tsbuff.h"
+#include "tsthread.h"
+
+
+#define STRICTLY_CHECK_EVENT_SIGNALS
+//#<OFF>#define STRICTLY_CHECK_EMPTY_FRAMES
+//#<OFF>#define STRICTLY_CHECK_EMPTY_FRAMES_ALL
+
+#define HasSignal(e) (WaitForSingleObject(e,0)==WAIT_OBJECT_0)
+
+
+//# URB thread settings
+BOOL TSTHREAD_DUPLEX = FALSE ;
+int TSTHREAD_PRIORITY = THREAD_PRIORITY_HIGHEST ;
+DWORD TSTHREAD_POLL_TIMEOUT = 25 ;
+DWORD TSTHREAD_SUBMIT_TIMEOUT = 50 ;
+int TSTHREAD_NUMIO = 24 ; //# number of I/O buffering
+#define MIN_IOLIMIT 4
+int TSTHREAD_SUBMIT_IOLIMIT = MIN_IOLIMIT ; //# keeping number of I/O buffering at least
+BOOL TSTHREAD_LOCK_ON_WINUSB = TRUE ;
+
+//# power policy disable suspending
+BOOL USBPOWERPOLICY_AVOID_SUSPEND = FALSE ;
+
+//# pipe policy settings
+BOOL USBPIPEPOLICY_RAW_IO = TRUE ;
+BOOL USBPIPEPOLICY_AUTO_CLEAR_STALL = TRUE ;
+BOOL USBPIPEPOLICY_ALLOW_PARTIAL_READS = TRUE ;
+BOOL USBPIPEPOLICY_AUTO_FLUSH = FALSE ;
+BOOL USBPIPEPOLICY_IGNORE_SHORT_PACKETS = FALSE ;
+BOOL USBPIPEPOLICY_SHORT_PACKET_TERMINATE = FALSE ;
+DWORD USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT = 5000UL ;
+BOOL USBPIPEPOLICY_RESET_PIPE_ON_RESUME = FALSE ;
+
+#define ISOCH_IO_INDEX_DROP_MASK 0x40000000
+
+struct TSIO_CONTEXT {
+#ifdef INCLUDE_ISOCH_XFER
+	USBD_ISO_PACKET_DESCRIPTOR isochFrameDesc[ISOCH_PacketFrames];
+#endif
+	OVERLAPPED ol;
+	int index;
+	DWORD bytesRead;
+};
+
+struct tsthread_param {
+	HANDLE hThreads[2];    //# handles to thread data
+	unsigned char loop_flags ; //# ( 1: reap, 2: submit, 3: both ) <<2: init
+	unsigned char volatile  flags;
+	/* if 0x01U flagged, issue a new request.
+	   if 0x02U flagged, cancel requests and stop thread.
+	*/
+	const struct usb_endpoint_st*  pUSB;
+	char* buffer;    //# data buffer (in heap memory)
+	int*  actual_length;    //# actual length of each buffer block
+	unsigned xfer_size;
+	unsigned buff_size;
+	unsigned buff_unitSize;
+	int buff_num;
+	int buff_push;
+	int buff_pop;
+	int io_num;
+	int io_limit;
+	int total_submit ;
+	struct TSIO_CONTEXT *ioContext ;
+	HANDLE *hTsEvents ;
+	HANDLE hTsAvailable,hTsRead,hTsRestart,hTsStopped ;
+
+	HANDLE hTsLoopIn, hTsReap, hTsSubmit ;
+
+	struct tsfifo_t* tsfifo ; //# ts-fifo caching object
+
+	int ri; //# the circular index based ioContext cursor for reaping
+	int si; //# the circular index based ioContext cursor for submitting
+
+	//# critical object
+	CRITICAL_SECTION csTsExclusive;
+
+#ifdef INCLUDE_ISOCH_XFER
+	WINUSB_ISOCH_BUFFER_HANDLE hIsochBuffer;
+#endif
+};
+
+  static int __inline isCritical(struct tsthread_param* const ps) {
+	return !(ps->flags & 0x01U)||HasSignal(ps->hTsRestart) ;
+  }
+
+  static void __inline lockWinUsb(struct tsthread_param* const ps,int lock) {
+	if(TSTHREAD_LOCK_ON_WINUSB&&ps->pUSB->lockunlockFunc)
+		 ps->pUSB->lockunlockFunc(ps->pUSB->dev,lock) ;
+  }
+
+
+
+static void tsthread_purgeURB(const tsthread_ptr ptr)
+{
+	struct tsthread_param* const ps = ptr;
+	int i;
+
+	EnterCriticalSection(&ps->csTsExclusive);
+	lockWinUsb(ps,1);
+
+	if( !(ps->pUSB->endpoint & 0x100) ) { //# Bulk
+
+		WinUsb_AbortPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF);
+
+		if(ps->total_submit>0) {
+
+			for (i = 0;i < ps->io_num;i++) {
+				struct TSIO_CONTEXT* pContext = &ps->ioContext[i];
+				if(pContext->index>=0) {
+					if(ps->tsfifo&&ps->tsfifo->writeBackFinish)
+						ps->tsfifo->writeBackFinish(pContext->index,0,ps->tsfifo->arg);
+					/*
+					else
+						ps->actual_length[pContext->index]=0;*/
+					ResetEvent(pContext->ol.hEvent);
+					pContext->index=-1 ;
+				}
+			}
+
+
+			ps->total_submit = 0;
+			ps->ri = ps->si ;
+
+		}
+
+	}else { //# Isochronous
+
+		if(ps->total_submit>0) {
+			for (i = 0;i < ps->io_num;i++) {
+				struct TSIO_CONTEXT* pContext = &ps->ioContext[i];
+				if(pContext->index>=0) {
+					pContext->index |= ISOCH_IO_INDEX_DROP_MASK ;
+				}
+			}
+		}
+
+	}
+
+	#if 1
+	if(ps->tsfifo) {
+		if(ps->tsfifo->purge)
+			ps->tsfifo->purge(ps->tsfifo->arg);
+	}
+	if(ps->actual_length) {
+		if(!(ps->pUSB->endpoint & 0x100)) { //# Bulk
+			memset(&ps->actual_length[0],0xFF,
+				ps->buff_num*sizeof(ps->actual_length[0]));
+			ps->buff_pop = ps->buff_push ;
+		}
+		else { //# Isochronous
+			void* ptr; while(tsthread_read( ps, &ptr )>0);
+		}
+	}
+	#endif
+
+	WinUsb_FlushPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF);
+	ps->flags &= ~0x10U; //# reset isochronous continuous status
+
+	lockWinUsb(ps,0);
+	LeaveCriticalSection(&ps->csTsExclusive);
+}
+
+//# 2020-11-21
+//#   Supported the multi-tasking feature for the reaping and the submitting.
+//# 2020-10-5
+//#   Added the URB feature for the isochronous transfer mode.
+//# 2018-3-1
+//#   Removed the tsthread_submitURB static function.
+//#   Removed the tsthread_reapURB static function.
+//#   Added the tsthread_bulkURB static function instead of submitURB/reapURB.
+//# Fixed by 2018-2020 LVhJPic0JSk5LiQ1ITskKVk9UGBg
+static unsigned int tsthread_bulkURB(struct tsthread_param* const ps)
+{
+	BOOL bRet ;
+	DWORD dRet=0 ;
+
+	//# the pointer of a ts-fifo caching object
+	struct tsfifo_t *pTSFifo = ps->tsfifo ;
+
+	//# identify the loop model which is reaping, submitting or both.
+	const int loop_model = (ps->loop_flags >> 2) & 3 ;
+
+	//# whether the current task mode is duplex or not.
+	const BOOL duplex = (loop_model&3)==3 ? FALSE : TRUE ;
+
+	//# whether the write-through ts-fifo caching feature is existed or not
+	const BOOL hasWThrough = pTSFifo && pTSFifo->writeThrough ? TRUE : FALSE ;
+
+	//# whether the write-back ts-fifo caching feature is enabled or not
+	const BOOL isWBack =
+#ifdef INCLUDE_ISOCH_XFER
+			(ps->pUSB->endpoint & 0x100) ? FALSE:
+#endif
+			(pTSFifo && pTSFifo->writeBackBegin && pTSFifo->writeBackFinish ? TRUE: FALSE);
+
+	//# number of the prefetching buffer busy area that shouldn't be submitted
+	const int POPDELTA = hasWThrough ? 0 :
+		(TS_CalcDeadZone(ps->buff_size)+ps->buff_unitSize-1)/ps->buff_unitSize;
+
+	//# prefetching frames per a packet
+	const int frames =
+#ifdef INCLUDE_ISOCH_XFER
+		(ps->pUSB->endpoint & 0x100) ? ISOCH_PacketFrames :
+#endif
+		1 ;
+
+	EnterCriticalSection(&ps->csTsExclusive);
+	ps->loop_flags &= ~(loop_model<<2) ;
+	LeaveCriticalSection(&ps->csTsExclusive);
+
+	//# tell the loop is started
+	SetEvent(ps->hTsLoopIn);
+
+	//# check the contradiction of caching methods
+	assert( !isWBack != (ps->actual_length==NULL) ) ;
+	assert( !isWBack || (isWBack && !hasWThrough) ) ;
+
+	//# bulk loop
+	while(!(ps->flags&0x02U)) {
+
+#ifndef INCLUDE_ISOCH_XFER
+		//# shutdown ( isoch is not supported )
+		if (ps->pUSB->endpoint & 0x100) { //# Isochronous
+			if(ps->flags & 0x01U) {
+				tsthread_stop(ps);
+				continue ;
+			}
+		}
+#endif
+		//# stop
+		if (!(ps->flags & 0x01U)) {
+			EnterCriticalSection(&ps->csTsExclusive);
+			ps->loop_flags |= loop_model ;  //# loop deactivate 0 -> 1
+			if((ps->loop_flags&3)==3) {
+				SetEvent(ps->hTsStopped);
+				SetEvent(ps->hTsRestart); //# restart to reactivate loops
+			}
+			LeaveCriticalSection(&ps->csTsExclusive);
+			HRWaitForSingleObject(ps->hTsAvailable, TSTHREAD_POLL_TIMEOUT,0) ;
+			continue ;
+		}
+
+		//# restart
+		if(HasSignal(ps->hTsRestart)) {
+			BOOL wait = FALSE ;
+			EnterCriticalSection(&ps->csTsExclusive);
+			if(ps->flags & 0x01U) {
+				ps->loop_flags |= loop_model ;  //# loop deactivate 0 -> 1
+				if((loop_model&2)&&(ps->loop_flags&3)==3) {
+					tsthread_purgeURB(ps) ;
+					ResetEvent(ps->hTsRestart) ;
+					SetEvent(ps->hTsAvailable) ;
+				}else
+					wait = TRUE ;
+			}
+			LeaveCriticalSection(&ps->csTsExclusive);
+			if(wait) HRWaitForSingleObject(ps->hTsAvailable, TSTHREAD_POLL_TIMEOUT,0) ;
+			continue;
+		}else if(ps->loop_flags&loop_model) {
+			BOOL sig = TRUE ;
+			EnterCriticalSection(&ps->csTsExclusive);
+			if(ps->flags & 0x01U) {
+				sig = HasSignal(ps->hTsRestart) ;
+				if(!sig) ps->loop_flags &= ~loop_model ; //# loop activate 1 -> 0
+			}
+			LeaveCriticalSection(&ps->csTsExclusive);
+			if(sig) continue;
+		}
+
+		//# reaping loop model
+		if( loop_model&1 ) {
+
+			if(duplex && ps->total_submit<(ps->flags&0x10U?ps->io_limit:MIN_IOLIMIT)) {
+				HANDLE events[2];
+				events[0]=ps->hTsSubmit;
+				events[1]=ps->hTsRestart ;
+				//# wait for submitting buffer...
+				HRWaitForMultipleObjects(2, events , FALSE, TSTHREAD_SUBMIT_TIMEOUT,0);
+				if(ps->total_submit<ps->io_limit)
+					continue ; //# less than io_limit, redo...
+			}
+
+			if(HasSignal(ps->hTsRestart)) continue ;
+
+			if(ps->total_submit>0) {
+
+				//# poll
+				int next_wait_index=-1 ;
+				{
+					int total_submit = ps->total_submit ;
+					int max_wait_count = total_submit<MAXIMUM_WAIT_OBJECTS-1 ? total_submit : MAXIMUM_WAIT_OBJECTS-1 ;
+					DWORD usec1 = TSTHREAD_POLL_TIMEOUT*1000 / max_wait_count ;
+					dRet = HRWaitForSingleObject(ps->hTsEvents[ps->ri] ,0,usec1 );
+					if(dRet != WAIT_OBJECT_0)
+						dRet = HRWaitForMultipleObjects(max_wait_count, &ps->hTsEvents[ps->ri] , FALSE, TSTHREAD_POLL_TIMEOUT,0 );
+					if (isCritical(ps)) continue;
+					if(WAIT_OBJECT_0 <= dRet&&dRet < WAIT_OBJECT_0+max_wait_count) {
+						next_wait_index = ((dRet - WAIT_OBJECT_0)+1 + ps->ri)%ps->io_num ;
+#ifdef STRICTLY_CHECK_EVENT_SIGNALS
+						if(!duplex) {
+							int end_index=(ps->ri+ps->total_submit)%ps->io_num ;
+							while( next_wait_index != end_index ) {
+								if(!HasSignal(ps->hTsEvents[next_wait_index]))
+									break ;
+								if (++next_wait_index >= ps->io_num)
+									next_wait_index ^= next_wait_index ;
+							}
+						}
+#endif
+					}else if(WAIT_TIMEOUT!=dRet) {
+						dRet = GetLastError();
+						warn_info(dRet,"poll failed");
+						break;
+					}
+				}
+
+				//# reap
+				if(next_wait_index>=0) do {
+
+					struct TSIO_CONTEXT* pContext = &ps->ioContext[ps->ri];
+					if(pContext->index>=0) {
+
+						DWORD bytesRead=pContext->bytesRead ;
+
+#ifdef STRICTLY_CHECK_EVENT_SIGNALS
+						if (duplex && !HasSignal(ps->hTsEvents[ps->ri])) break ;
+#endif
+
+						if (isCritical(ps)) break;
+						//if(!HasSignal(ps->hTsEvents[ps->ri])) break ;
+						if(bytesRead>0) {
+							bRet = TRUE;
+							dRet = 0;
+						}else {
+							lockWinUsb(ps,1) ;
+							if (isCritical(ps)) {
+								bRet=FALSE ;
+								dRet=ERROR_OPERATION_ABORTED ;
+							}else {
+								bRet = WinUsb_GetOverlappedResult(
+									ps->pUSB->fd, &(pContext->ol), &bytesRead, FALSE);
+								dRet = GetLastError();
+							}
+							lockWinUsb(ps,0) ;
+						}
+						if (ps->buff_unitSize < bytesRead) {
+							DBGOUT("reap: size over (size=%d)\n",bytesRead) ;
+							warn_info(bytesRead, "reapURB overflow");
+							bytesRead = ps->buff_unitSize;
+						}
+#ifndef INCLUDE_ISOCH_XFER
+						if (ps->pUSB->endpoint & 0x100)
+							bytesRead = 0;
+#endif
+						if(bRet) {
+#ifdef TS_IgnoreShortPacket
+							if (ps->xfer_size>bytesRead) {
+								//if(bytesRead>0)
+									DBGOUT("reap: short packet (size=%d)\n",bytesRead) ;
+								bytesRead=0;
+							}
+#endif
+						}else {
+							DBGOUT("reap: error (code=%d, size=%d)\n",dRet,bytesRead) ;
+							if(ERROR_IO_INCOMPLETE == dRet) { //# ERR#996 io incomplete
+								break;  //# looking forward to the next time...
+							}
+							#if 1
+							if(ERROR_SEM_TIMEOUT == dRet) { //# ERR#121 sem timeout
+								//# the data transfer process was reached timed out.
+								//# the throghput of the data transfer may be too low.
+								//# the getting data size will be less than packet size.
+								//# this error may be occurred on having huge packet size
+								//# and proceeding to transfer them on the poor USB device.
+								bRet=TRUE; //# the data is available and incompleted.
+							}else
+							#endif
+							{
+								//# failed
+								bytesRead = 0;
+								ps->flags &= ~0x10U;
+								warn_msg(dRet, "reapURB%u failed", ps->ri);
+							}
+						}
+						if(pContext->index>=0) {
+							if (ps->pUSB->endpoint & 0x100) {
+								BOOL drop = (pContext->index & ISOCH_IO_INDEX_DROP_MASK) ? TRUE : FALSE ;
+								if(drop) pContext->index &= ~ISOCH_IO_INDEX_DROP_MASK ;
+#ifdef INCLUDE_ISOCH_XFER
+								EnterCriticalSection(&ps->csTsExclusive) ;
+								if(hasWThrough && pContext->index==ps->buff_pop) {
+
+									//# write-through caching ( context & buff_pop indices sync )
+									char *p = &ps->buffer[pContext->index*ps->buff_unitSize] ;
+									const USBD_ISO_PACKET_DESCRIPTOR *pDesc=&pContext->isochFrameDesc[0];
+									int n, sz, amount = 0 ;
+									if(!bRet)
+										warn_msg(dRet, "reapURB%u(%u)",ps->ri, frames);
+									else for(n=frames ; n-- ; pDesc++) {
+										if(pDesc->Status) {
+											sz = 0;
+											warn_msg(dRet, "reapURB%u.%u", ps->ri, frames-1-n);
+										}else
+											sz = pDesc->Length ;
+										if(n&&sz==ps->buff_unitSize)
+											amount+=sz ;
+										else {
+											if(amount+sz>0 && !drop)
+												pTSFifo->writeThrough(p, amount+sz, pTSFifo->arg) ;
+											p+=amount+ps->buff_unitSize, amount=0 ;
+										}
+									}
+									if(ps->buff_pop + frames >= ps->buff_num)
+										ps->buff_pop = 0;
+									else
+										ps->buff_pop += frames ;
+									ps->actual_length[pContext->index]=-1 ;
+
+#ifdef STRICTLY_CHECK_EMPTY_FRAMES
+									if(frames>1) {
+#ifdef STRICTLY_CHECK_EMPTY_FRAMES_ALL
+										//# reset all frames
+										__stosd(&ps->actual_length[pContext->index+1],-1,frames-1);
+#else
+										//# erase a gatekeeper frame
+										ps->actual_length[pContext->index+frames-1]=-1 ;
+#endif
+									}
+#endif
+									LeaveCriticalSection(&ps->csTsExclusive) ;
+								}else {
+									LeaveCriticalSection(&ps->csTsExclusive) ;
+#if defined(_WIN32) && !defined(_WIN64)
+									if(drop) {
+										register int *pLen = &ps->actual_length[pContext->index];
+										__stosd(pLen,0,frames);
+									}else {
+										int stride = (char*) &pContext->isochFrameDesc[1]
+											- (char*) &pContext->isochFrameDesc[0] ;
+										void* sp_ = &pContext->isochFrameDesc[0].Length ;
+										void* dp_ = &ps->actual_length[pContext->index] ;
+										int dx_ = (char*) &pContext->isochFrameDesc[0].Status
+											- (char*) &pContext->isochFrameDesc[0].Length ;
+										int errors = 0 ;
+										_asm {
+											mov ecx, frames
+											mov edi, dp_
+											cld
+											cmp bRet, 0
+											je lb3
+											xor ebx, ebx
+											mov esi, sp_
+											mov eax, stride
+											mov edx, dx_
+										lb1:
+											cmp dword ptr [esi+edx], 0
+											jne lb2
+											movsd
+											lea esi, [esi+eax-4]
+											dec ecx
+											jnz lb1
+											jmp lb4
+										lb2:
+											mov dword ptr [edi], 0
+											lea edi, [edi+4]
+											lea esi, [esi+eax]
+											inc ebx
+											dec ecx
+											jnz lb1
+											jmp lb4
+										lb3:
+											mov ebx, ecx
+											xor eax, eax
+											rep stosd
+										lb4:
+											mov errors, ebx
+										}
+										if(errors>0)
+											warn_msg(dRet, "reapURB%u(%u)",ps->ri, errors);
+									}
+#else
+									register int n,*pLen = &ps->actual_length[pContext->index];
+									register const USBD_ISO_PACKET_DESCRIPTOR *pDesc=&pContext->isochFrameDesc[frames-1];
+									if(!bRet||drop) {
+										__stosd(pLen,0,frames);
+										if(!drop) warn_msg(dRet, "reapURB%u(%u)",ps->ri, frames);
+									}
+									else for (n = frames ; n ; n--, pDesc--) {
+										if (pDesc->Status) {
+											pLen[n-1] =  0;
+											warn_msg(dRet, "reapURB%u.%u", ps->ri, n-1);
+											continue;
+										}
+										pLen[n-1] = pDesc->Length ;
+									}
+#endif
+								}
+								if(bRet&&!drop) SetEvent(ps->hTsAvailable) ;
+#endif
+							}else {
+								if (isWBack)
+									pTSFifo->writeBackFinish(ps->ri, bytesRead, pTSFifo->arg);
+								else
+									ps->actual_length[pContext->index] = bytesRead;
+								if(bytesRead) SetEvent(ps->hTsAvailable) ;
+							}
+							ResetEvent(ps->hTsEvents[ps->ri]);
+							pContext->index=-1 ;
+							if(duplex) EnterCriticalSection(&ps->csTsExclusive) ;
+							ps->total_submit-- ;
+							if(duplex) LeaveCriticalSection(&ps->csTsExclusive) ;
+							SetEvent(ps->hTsReap);
+						}
+					}
+					if(++ps->ri>=ps->io_num) ps->ri^=ps->ri ;
+					if(ps->total_submit<=0) break;
+
+				}while(
+#ifdef STRICTLY_CHECK_EVENT_SIGNALS
+					duplex ||
+#endif
+					ps->ri!=next_wait_index);
+
+			}
+		}
+
+		//# write-through caching ( async )
+		if( (loop_model&1) && hasWThrough ) {
+
+			char *p = NULL, *r ;
+			int sz, amount = 0 ;
+			do {
+				r = NULL ;
+				sz  = tsthread_read( ps, (void**) &r ) ;
+				if(r) {
+					if(!p)
+						p=r, amount=sz, sz=0 ;
+					else if(&p[amount]==r)
+						amount+=sz, sz=0 ;
+				}
+				if(!r||sz>0) {
+					if(p) pTSFifo->writeThrough(p, amount, pTSFifo->arg) ;
+					p=r, amount=sz ;
+				}
+			}while(p) ;
+
+		}
+
+		//# submitting loop model
+		if( loop_model&2 ) {
+
+			if( duplex && ps->total_submit>=(ps->flags&0x10U?ps->io_num:MIN_IOLIMIT) ) {
+				HANDLE events[2];
+				events[0]=ps->hTsReap;
+				events[1]=ps->hTsRestart ;
+				//# wait for reaping buffer...
+				HRWaitForMultipleObjects(2, events , FALSE, TSTHREAD_POLL_TIMEOUT,0 );
+				if(ps->total_submit>=ps->io_num)
+					continue ; //# still full, redo...
+			}
+
+			if (HasSignal(ps->hTsRestart)) continue;
+
+			//# submit
+			if( ps->total_submit<ps->io_num && (ps->flags & 0x01U) ) {
+				DWORD tick = GetTickCount() ;
+				int fulfill = duplex || !(ps->flags&0x10U) ;
+				void *buffer;
+				DWORD lnTransfered;
+				int num_empties=0,max_empties=ps->io_num;
+				int last_state=0;
+				dRet = 0;bRet = FALSE;
+				//# calculate the real maximum number of empties on the buffer
+				if(!isWBack) {
+					EnterCriticalSection(&ps->csTsExclusive) ;
+					tsthread_readable(ps);
+					last_state = ps->actual_length[ps->buff_pop] ;
+					#if 1
+					if(ps->buff_push==ps->buff_pop)
+						max_empties =
+							last_state==-1 ? ps->buff_num : 0 ;
+					else
+					#endif
+						max_empties = ps->buff_push<ps->buff_pop ?
+							ps->buff_pop-ps->buff_push :
+							ps->buff_num-ps->buff_push + ps->buff_pop ;
+					ResetEvent(ps->hTsRead);
+					LeaveCriticalSection(&ps->csTsExclusive) ;
+					max_empties -= POPDELTA; //# subtract deadzone
+				}
+				//# total I/O submittable empties
+				num_empties=ps->io_num-ps->total_submit;
+				num_empties*=frames;
+				//start=ps->si ;
+				if(num_empties>max_empties) {
+					num_empties = max_empties ;
+					#if 1
+					if(num_empties<=0&&ps->total_submit<=0) {
+						//# in the dead zone
+						if(!isWBack&&!hasWThrough&&last_state>=0) {
+							HANDLE events[2];
+							events[0]=ps->hTsRead;
+							events[1]=ps->hTsRestart ;
+							//# wait for reading buffer...
+							dRet=HRWaitForMultipleObjects(2, events , FALSE, TSTHREAD_POLL_TIMEOUT,0 );
+							if(dRet==WAIT_TIMEOUT)
+							  DBGOUT("read: wait timeout\n") ;
+							else if(dRet==WAIT_OBJECT_0)
+							  DBGOUT("read: wait success\n") ;
+						}
+					}
+					#endif
+				}
+				//# submit to empties
+				while (num_empties>=frames) {
+					BOOL submitted = FALSE ;
+					struct TSIO_CONTEXT* pContext = &ps->ioContext[ps->si];
+					if (isCritical(ps)) break;
+					if(ps->total_submit>=ps->io_num) break;
+					if (pContext->index>=0) break ;
+					//if (HasSignal(ps->hTsEvents[ps->ri])) break;
+#ifndef INCLUDE_ISOCH_XFER
+					if (ps->pUSB->endpoint & 0x100) { //# Isochronous
+						//tsthread_stop(ps);
+						break;
+					}
+#endif
+					if(isWBack) {
+						buffer = pTSFifo->writeBackBegin(ps->si, ps->buff_unitSize, pTSFifo->arg) ;
+						if(!buffer) break ; //# buffer overflow
+					}
+#ifdef STRICTLY_CHECK_EMPTY_FRAMES
+					else {
+						register int n,*p=&ps->actual_length[ps->buff_push] ;
+						if(frames==1)
+							n = *p==-1 ? 0: 1;
+						else {
+#if defined(_WIN32) && !defined(_WIN64)
+							_asm {
+								mov eax, -1
+								mov edi, p
+								mov ecx, frames
+								cld
+								repe scasd //# dw string scan
+								mov n, ecx
+							}
+#else
+#if defined(_WIN32) && defined(_WIN64)
+							if(!(frames&1)) for(n=frames*sizeof(*p)/sizeof(__int64);n;n--) {
+								if(((__int64*)p)[n-1]!=-1) break ; //# qw scan
+							}else
+#endif
+							for(n=frames;n;n--) { if(p[n-1]!=-1) break; }
+#endif
+						}
+						if(n) break ; //# buffer busy
+					}
+#endif
+					if(!isWBack) {
+						buffer = ps->buffer + ps->buff_push * ps->buff_unitSize ;
+						last_state = ps->actual_length[ps->buff_push] ;
+						ps->actual_length[ps->buff_push] = -2;
+					}
+					pContext->index = isWBack ? ps->si : ps->buff_push;
+					pContext->bytesRead = 0 ;
+					ZeroMemory(&pContext->ol,sizeof(OVERLAPPED));
+					pContext->ol.hEvent = ps->hTsEvents[ps->si];
+					lnTransfered = 0;
+					ResetEvent(pContext->ol.hEvent);
+					lockWinUsb(ps,1) ;
+					if(isCritical(ps)) {
+						bRet=FALSE ;
+						dRet=ERROR_OPERATION_ABORTED ;
+					}else {
+						if (ps->pUSB->endpoint & 0x100) { //# Isochronous
+#ifdef INCLUDE_ISOCH_XFER
+							bRet = WinUsb_ReadIsochPipeAsap(
+								ps->hIsochBuffer,
+								ps->buff_push * ps->buff_unitSize, /*offset*/
+								frames * ps->buff_unitSize,  /*length*/
+								ps->flags & 0x10U ? TRUE: FALSE, /*continuous*/
+								frames, pContext->isochFrameDesc,
+								&(pContext->ol));
+							dRet = GetLastError();
+#endif
+						}else {
+							bRet = WinUsb_ReadPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF,
+								buffer, ps->buff_unitSize, &lnTransfered, &(pContext->ol));
+							dRet = GetLastError();
+						}
+					}
+					lockWinUsb(ps,0) ;
+					if (FALSE == bRet && ERROR_IO_PENDING != dRet) {
+						//# submitting failed
+						DBGOUT("submit: error (code=%d, size=%d)\n",dRet,lnTransfered) ;
+						warn_info(dRet, "submitURB failed");
+						if(isWBack)
+							pTSFifo->writeBackFinish(ps->si,0,pTSFifo->arg);
+						else
+							ps->actual_length[ps->buff_push] = last_state;
+						ResetEvent(ps->hTsEvents[ps->si]);
+						pContext->index = -1;
+						if(ps->flags&0x10U) ps->flags &= ~0x10U; //# not cont
+					}else {
+						//# submitting succeeded
+						if(!isWBack) {
+#ifdef STRICTLY_CHECK_EMPTY_FRAMES
+							if(frames>1) {
+#ifdef STRICTLY_CHECK_EMPTY_FRAMES_ALL
+								//# fill all frames
+								__stosd(&ps->actual_length[ps->buff_push+1],-2,frames-1);
+#else
+								//# make a gatekeeper frame
+								ps->actual_length[ps->buff_push+frames-1]=-2;
+#endif
+							}
+#endif
+							if(ps->buff_push+frames>=ps->buff_num)
+								ps->buff_push=0;
+							else
+								ps->buff_push+=frames;
+						}
+						if(bRet) {
+							DBGOUT("submit: success (size=%d)\n",lnTransfered) ;
+							pContext->bytesRead = lnTransfered ;
+							SetEvent(ps->hTsEvents[ps->si]) ;
+						}else {
+							if(lnTransfered>0)
+								DBGOUT("submit: pending (size=%d)\n",lnTransfered) ;
+						}
+						dRet = 0;
+						if(++ps->si >= ps->io_num) ps->si^=ps->si;
+						if(duplex) EnterCriticalSection(&ps->csTsExclusive) ;
+						++ps->total_submit;
+						if(duplex) LeaveCriticalSection(&ps->csTsExclusive) ;
+						SetEvent(ps->hTsSubmit) ;
+						submitted=TRUE;
+						if(!(ps->flags&0x10U)) ps->flags |= 0x10U; //# cont
+					}
+					//# check submitting failed or not
+					if(!submitted) break ;
+					num_empties-=frames;
+					if(fulfill) continue;
+					if (GetTickCount()-tick>=TSTHREAD_SUBMIT_TIMEOUT
+						&& ps->total_submit>=ps->io_limit )
+						break; //# submitting timeout
+				}
+				//if(dRet) break ;
+			}
+
+		}
+
+	}
+
+	EnterCriticalSection(&ps->csTsExclusive);
+	ps->loop_flags |= (loop_model<<4) ; //# end of loop
+	if((ps->loop_flags&(3<<4))==(3<<4)) tsthread_purgeURB(ps); //# dispose
+	LeaveCriticalSection(&ps->csTsExclusive);
+
+	return dRet ;
+}
+
+/* TS thread function issues URB requests. */
+static unsigned int __stdcall tsthread(void* const param)
+{
+	struct tsthread_param* const ps = param;
+	unsigned int result = 0;
+
+	result = tsthread_bulkURB(ps);
+
+	_endthreadex( 0 );
+	return result ;
+}
+
+/* public function */
+
+int tsthread_create( tsthread_ptr* const tptr,
+					 const struct usb_endpoint_st* const pusbep,
+					 const struct tsfifo_t * const ptsfifo
+				   )
+{
+
+	int result = 0 ;
+	struct tsthread_param* ps;
+	DWORD dwRet; int i;
+
+	unsigned io_num = TSTHREAD_NUMIO ;
+	unsigned io_limit = TSTHREAD_SUBMIT_IOLIMIT ;
+	unsigned TS_BufPackets = 1 ;
+	if(io_limit<MIN_IOLIMIT) io_limit=MIN_IOLIMIT ;
+	if (io_num < io_limit) io_num = io_limit;
+	else if (io_num > TS_MaxNumIO) io_num = TS_MaxNumIO;
+	if(io_limit > io_num) io_limit = io_num ;
+	while(TS_BufPackets<io_num+TS_CalcDeadZone(TS_BufPackets))
+		TS_BufPackets<<=1 ;
+
+	{ //#
+		const BOOL tsfifo_exists = ptsfifo ? TRUE : FALSE ;
+		const BOOL wback_exists =
+#ifdef INCLUDE_ISOCH_XFER
+			(pusbep->endpoint & 0x100) ? FALSE:
+#endif
+			(tsfifo_exists && ptsfifo->writeBackBegin && ptsfifo->writeBackFinish? TRUE: FALSE);
+		const unsigned param_size = ROUNDUP( sizeof( struct tsthread_param ), 0xF );
+		const unsigned xferSize = pusbep->xfer_size ;
+		const unsigned unitSize = pusbep->endpoint & 0x100 ? xferSize : ROUNDUP( xferSize, 0x1FF ) ;
+		const unsigned unitNum =
+#ifdef INCLUDE_ISOCH_XFER
+			pusbep->endpoint & 0x100 ? ISOCH_PacketFrames*TS_BufPackets :
+#endif
+			TS_CalcBufSize(xferSize,TS_BufPackets)/unitSize ;
+		const unsigned buffSize = wback_exists ? 0 : unitSize*unitNum ;
+		const unsigned buffer_size = wback_exists ? 0 : ROUNDUP( buffSize, 0xF );
+		const unsigned actlen_size = wback_exists ? 0 : sizeof( int ) * unitNum;
+		const unsigned tsfifo_size = tsfifo_exists ? ROUNDUP( sizeof( struct tsfifo_t ), 0xF) : 0;
+		const unsigned iocontext_size = ROUNDUP( io_num * sizeof(struct TSIO_CONTEXT), 0xF);
+		const unsigned htsevents_size = ROUNDUP(  (io_num * 2 - 1) * sizeof(HANDLE), 0xF);
+		char *ptr, *buffer_ptr;
+		struct tsfifo_t *tsfifo_ptr;
+		unsigned totalSize =  param_size + actlen_size + buffer_size + tsfifo_size + iocontext_size + htsevents_size ;
+		ptr = uHeapAlloc( totalSize );
+		if ( NULL == ptr ) {
+			dwRet = GetLastError();
+			warn_msg( dwRet, "failed to allocate TS buffer" );
+			return -1;
+		}
+		buffer_ptr = ptr;
+		ptr += buffer_size;
+		ps = ( struct tsthread_param* ) ptr;
+		ps->buffer = buffer_ptr;
+		ptr += param_size;
+		ps->actual_length = ( int* ) ptr ;
+		ptr += actlen_size;
+		tsfifo_ptr = ( struct tsfifo_t * ) ptr;
+		ptr += tsfifo_size;
+		ps->ioContext = ( struct TSIO_CONTEXT * ) ptr;
+		ptr += iocontext_size;
+		ps->hTsEvents = (HANDLE*) ptr ;
+		ptr += htsevents_size;
+		ps->xfer_size= xferSize;
+		ps->buff_unitSize = unitSize;
+		ps->buff_num = unitNum;
+		ps->buff_size = buffSize;
+		ps->io_num = io_num ;
+		ps->io_limit = io_limit ;
+		assert(ptr-buffer_ptr==totalSize) ;
+		if ( actlen_size ) {
+			//# reset all values to empty
+			memset(&ps->actual_length[0],0xFF,actlen_size);
+		}else
+			ps->actual_length = NULL;
+		if ( tsfifo_exists ) {
+			CopyMemory( tsfifo_ptr, ptsfifo, sizeof( struct tsfifo_t ) );
+			ps->tsfifo = tsfifo_ptr;
+		}else
+			ps->tsfifo = NULL ;
+	}
+	ps->pUSB = pusbep;
+	ps->flags = 0x00U;
+	ps->buff_push = 0;
+	ps->buff_pop = 0;
+	ps->total_submit = 0;
+	ps->ri = 0;
+	ps->si = 0;
+#ifdef INCLUDE_ISOCH_XFER
+	ps->hIsochBuffer = NULL;
+	if (pusbep->endpoint & 0x100) { //# Isochronous
+		DBGOUT("-*- ISOCHRONOUS TRANSFER MODE -*-\n") ;
+		if (!WinUsb_RegisterIsochBuffer(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF,
+			ps->buffer, ps->buff_size, &(ps->hIsochBuffer))) {
+			DWORD dwRet = GetLastError();
+			ps->hIsochBuffer = NULL;
+			warn_info(dwRet, "WinUsb_RegisterIsochBuffer failed");
+			DBGOUT("-*- Isoch Buffer Creation Failed -*-\n") ;
+		}else {
+			DBGOUT(
+				"Isoch buffer size = %d (unit size = %d, unit num = %d)\n",
+				ps->buff_size, ps->buff_unitSize, ps->buff_num);
+		}
+	}
+#else
+	if (pusbep->endpoint & 0x100) { //# Isochronous
+		warn_msg(0, "Please change to BULK transfer mode :-P");
+	}
+#endif
+
+	for ( i = 0; i < ps->io_num; i++ ) {
+		ps->ioContext[ i ].index = -1;    //# mark it unused
+		ps->hTsEvents[ i ] = CreateEvent( NULL, TRUE, FALSE, NULL );
+		ZeroMemory( &ps->ioContext[ i ].ol, sizeof( OVERLAPPED ) );
+		ps->ioContext[ i ].ol.hEvent = ps->hTsEvents[ i ];
+	}
+
+	//# it arranges for event handles to look like circular buffer
+	for ( i = 0; i < ps->io_num - 1; i++ ) {
+		ps->hTsEvents[ i + ps->io_num ] = ps->hTsEvents[ i ];
+	}
+	ps->hTsAvailable = CreateEvent( NULL, FALSE, FALSE, NULL );
+	ps->hTsRead = CreateEvent( NULL, FALSE, FALSE, NULL );
+	ps->hTsRestart = CreateEvent( NULL, TRUE, FALSE, NULL );
+	ps->hTsStopped = CreateEvent( NULL, FALSE, FALSE, NULL );
+	ps->hTsLoopIn = CreateEvent( NULL, TRUE, FALSE, NULL ) ;
+	ps->hTsReap = CreateEvent( NULL, FALSE, FALSE, NULL );
+	ps->hTsSubmit = CreateEvent( NULL, FALSE, FALSE, NULL );
+	InitializeCriticalSection(&ps->csTsExclusive) ;
+
+	//# set USB pipe policy settings
+	WinUsb_ResetPipe( pusbep->fd, pusbep->endpoint & 0xFF );
+	#define SETUSBPIPEPOLICY_BOOL(name) do { UCHAR v=(DWORD)USBPIPEPOLICY_##name?1:0; \
+		WinUsb_SetPipePolicy( pusbep->fd, \
+			pusbep->endpoint & 0xFF, name,  sizeof( UCHAR ), &v ); }while(0)
+	#define SETUSBPIPEPOLICY_DWORD(name) do { DWORD v=(DWORD)USBPIPEPOLICY_##name; \
+		WinUsb_SetPipePolicy( pusbep->fd, \
+			pusbep->endpoint & 0xFF, name,  sizeof( DWORD ), &v ); }while(0)
+	SETUSBPIPEPOLICY_BOOL(RAW_IO);
+	SETUSBPIPEPOLICY_BOOL(AUTO_CLEAR_STALL);
+	SETUSBPIPEPOLICY_BOOL(ALLOW_PARTIAL_READS);
+	SETUSBPIPEPOLICY_BOOL(AUTO_FLUSH);
+	SETUSBPIPEPOLICY_BOOL(IGNORE_SHORT_PACKETS);
+	SETUSBPIPEPOLICY_BOOL(SHORT_PACKET_TERMINATE);
+	SETUSBPIPEPOLICY_DWORD(PIPE_TRANSFER_TIMEOUT);
+	SETUSBPIPEPOLICY_BOOL(RESET_PIPE_ON_RESUME);
+	#undef SETUSBPIPEPOLICY_BOOL
+	#undef SETUSBPIPEPOLICY_DWORD
+
+	//# set USB power policy settings
+	if(USBPOWERPOLICY_AVOID_SUSPEND) {
+		ULONG delay = INFINITE ;
+		UCHAR suspend = 0 ;
+		WinUsb_SetPowerPolicy(pusbep->fd,SUSPEND_DELAY,sizeof(delay),&delay);
+		WinUsb_SetPowerPolicy(pusbep->fd,AUTO_SUSPEND,sizeof(suspend),&suspend);
+	}
+
+	#ifdef _DEBUG
+
+	dwRet = sizeof( i );
+	WinUsb_GetPipePolicy( ps->pUSB->fd, ps->pUSB->endpoint & 0xFF, MAXIMUM_TRANSFER_SIZE, &dwRet, &i );
+	dmsg( "MAX_TRANSFER_SIZE=%u", i );
+	#endif
+
+	SetEvent(ps->hTsRestart);
+
+	ps->loop_flags = 0 ;
+	ps->hThreads[0]=ps->hThreads[1]=INVALID_HANDLE_VALUE;
+	for(i=0;i<(TSTHREAD_DUPLEX?2:1);i++) {
+		EnterCriticalSection(&ps->csTsExclusive);
+		ps->loop_flags |= TSTHREAD_DUPLEX ? 1<<(2+i)/*duplex*/: 3<<2/*simplex*/;
+		LeaveCriticalSection(&ps->csTsExclusive);
+		ResetEvent(ps->hTsLoopIn);
+		ps->hThreads[i] = ( HANDLE ) _beginthreadex( NULL, 0, tsthread, ps, 0, NULL );
+		if ( INVALID_HANDLE_VALUE == ps->hThreads[i] ) {
+			warn_info( errno, "tsthread_create(%d) failed",i );
+			result = -1 ;
+		}else {
+			SetThreadPriority( ps->hThreads[i], TSTHREAD_PRIORITY );
+			if(TSTHREAD_DUPLEX) WaitForSingleObject(ps->hTsLoopIn,INFINITE);
+		}
+	}
+
+	*tptr = ps;
+
+	return result ;
+}
+
+void tsthread_destroy(const tsthread_ptr ptr)
+{
+	int i;
+	struct tsthread_param* const ps = ptr;
+
+	tsthread_stop(ptr);
+	ps->flags |= 0x02U;    //# canceled = T
+	SetEvent(ps->hTsRead);
+	SetEvent(ps->hTsAvailable);
+	SetEvent(ps->hTsReap);
+	SetEvent(ps->hTsSubmit);
+	for(i=0;i<2;i++) {
+		if(ps->hThreads[i]!=INVALID_HANDLE_VALUE) {
+			if (HRWaitForSingleObject(ps->hThreads[i],
+					USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT,0) != WAIT_OBJECT_0) {
+				warn_msg(GetLastError(), "tsthread_destroy timeout(%d)",i);
+				TerminateThread(ps->hThreads[i], 0);
+			}
+			CloseHandle(ps->hThreads[i]);
+		}
+	}
+	for (i = 0; i < ps->io_num; i++)
+		CloseHandle(ps->hTsEvents[i]);
+	CloseHandle(ps->hTsAvailable);
+	CloseHandle(ps->hTsRead);
+	CloseHandle(ps->hTsRestart);
+	CloseHandle(ps->hTsStopped);
+	CloseHandle(ps->hTsLoopIn);
+	CloseHandle(ps->hTsReap);
+	CloseHandle(ps->hTsSubmit);
+#ifdef INCLUDE_ISOCH_XFER
+	if(ps->hIsochBuffer) {
+		WinUsb_UnregisterIsochBuffer( ps->hIsochBuffer );
+		ps->hIsochBuffer = NULL;
+	}
+#endif
+	DeleteCriticalSection(&ps->csTsExclusive);
+
+	uHeapFree(ps->buffer);
+}
+
+void tsthread_start(const tsthread_ptr ptr)
+{
+	struct tsthread_param* const ps = ptr;
+	BOOL stopped;
+
+	EnterCriticalSection(&ps->csTsExclusive) ;
+	lockWinUsb(ps,1);
+
+	ResetEvent(ps->hTsStopped);
+	ps->flags &= ~0x01U;    //# continue = F
+
+	lockWinUsb(ps,0);
+	LeaveCriticalSection(&ps->csTsExclusive) ;
+
+	stopped = HRWaitForSingleObject(ps->hTsStopped,USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT,0) == WAIT_OBJECT_0 ? TRUE : FALSE ;
+
+	EnterCriticalSection(&ps->csTsExclusive) ;
+	lockWinUsb(ps,1);
+
+	if (ps->pUSB->startstopFunc)
+		ps->pUSB->startstopFunc(ps->pUSB->dev, 1);
+
+	ps->flags |= 0x01U;    //# continue = T
+	if(!stopped) SetEvent(ps->hTsRestart);
+	else SetEvent(ps->hTsAvailable);
+
+	lockWinUsb(ps,0);
+	LeaveCriticalSection(&ps->csTsExclusive) ;
+}
+
+void tsthread_stop(const tsthread_ptr ptr)
+{
+	struct tsthread_param* const ps = ptr;
+	BOOL stopped;
+
+	EnterCriticalSection(&ps->csTsExclusive) ;
+
+	ResetEvent(ps->hTsStopped);
+	ps->flags &= ~0x01U;    //# continue = F
+
+	LeaveCriticalSection(&ps->csTsExclusive) ;
+
+	stopped = HRWaitForSingleObject(ps->hTsStopped,USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT,0) == WAIT_OBJECT_0 ? TRUE : FALSE ;
+
+	EnterCriticalSection(&ps->csTsExclusive) ;
+	lockWinUsb(ps,1);
+
+	if(!(ps->pUSB->endpoint & 0x100) && stopped) { //# Bulk
+		WinUsb_AbortPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF);
+	}
+
+	if(ps->pUSB->startstopFunc)
+		ps->pUSB->startstopFunc(ps->pUSB->dev, 0);
+
+	lockWinUsb(ps,0);
+	LeaveCriticalSection(&ps->csTsExclusive) ;
+}
+
+int tsthread_read(const tsthread_ptr tptr, void ** const ptr)
+{
+	struct tsthread_param* const ps = tptr;
+	char *p ;
+	int i, j ;
+
+	if(!ptr) {
+		//# purge
+		SetEvent(ps->hTsRestart);
+		return 0 ;
+	}
+
+	if(!ps->actual_length)
+		return 0 ;
+
+	p = NULL;
+
+	EnterCriticalSection(&ps->csTsExclusive) ;
+
+	i = tsthread_readable(tptr);
+	if(i>0) {
+		j = ps->buff_pop;
+		p = ps->buffer + (j * ps->buff_unitSize);
+		ps->actual_length[ps->buff_pop] = -1;
+		ps->buff_pop = (ps->buff_num > j+1) ? j+1 : 0;
+	}
+
+	LeaveCriticalSection(&ps->csTsExclusive) ;
+
+	*ptr=p ;
+	if(p) SetEvent(ps->hTsRead) ;
+	return i<0?0:i ;
+}
+
+int tsthread_readable(const tsthread_ptr tptr)
+{
+	struct tsthread_param* const ps = tptr;
+	int j ;
+
+	if(!ps->actual_length) return 0 ;
+	if(!(ps->flags&0x01U)) return 0;
+	if(HasSignal(ps->hTsRestart))
+		return 0 ;
+
+	EnterCriticalSection(&ps->csTsExclusive) ;
+	j= ps->buff_pop;
+	if(0 > j || ps->buff_num <= j) {  //# bug check
+		warn_info(j,"ts.buff_pop Out of range");
+		j = -1;
+	}else do {  //# skip empty blocks
+		if(!ps->actual_length[j]) {
+			ps->actual_length[j]=-1;
+		}else break;
+		if(ps->buff_num -1 > j) {
+			j++;
+		}else{
+			j = 0;
+		}
+	} while(j != ps->buff_pop);
+	ps->buff_pop = j<0 ? 0 : j ;
+	LeaveCriticalSection(&ps->csTsExclusive) ;
+	return j<0 ? 0 : ps->actual_length[j];
+}
+
+int tsthread_wait(const tsthread_ptr tptr, const int timeout)
+{
+	struct tsthread_param* const ps = tptr;
+	DWORD dRet ;
+	if(tsthread_readable(tptr)>0) return 1 ; //# already available
+	{
+		HANDLE events[2];
+		events[0]=ps->hTsRestart ;
+		events[1]=ps->hTsAvailable;
+		//# wait for buffer available...
+		dRet = HRWaitForMultipleObjects(2, events , FALSE, timeout,0);
+	}
+	if(WAIT_OBJECT_0+1 == dRet)  return 1;
+	else if(WAIT_OBJECT_0 == dRet || WAIT_TIMEOUT == dRet)  return 0;
+
+	warn_info(dRet,"poll failed");
+	return -1;
+}
+
+
 /*EOF*/
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/tsthread.h BonD_FSHybrid-20201009_mod10.1/src/tsthread.h
--- BonD_FSHybrid-20201009_org/src/tsthread.h	2016-01-04 16:39:06.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/tsthread.h	2020-11-21 02:46:48.000000000 +0900
@@ -6,9 +6,48 @@
 #pragma once
 #include "types_u.h"
 
+//# URB thread settings
+extern BOOL TSTHREAD_DUPLEX;
+extern int TSTHREAD_PRIORITY;
+extern DWORD TSTHREAD_POLL_TIMEOUT;
+extern DWORD TSTHREAD_SUBMIT_TIMEOUT;
+extern int TSTHREAD_NUMIO; //# number of I/O buffering
+extern int TSTHREAD_SUBMIT_IOLIMIT; //# keeping number of I/O buffering at least
+extern BOOL TSTHREAD_LOCK_ON_WINUSB;
+
+//# power policy disable suspending
+extern BOOL USBPOWERPOLICY_AVOID_SUSPEND ;
+
+//# pipe policy settings
+extern BOOL USBPIPEPOLICY_RAW_IO;
+extern BOOL USBPIPEPOLICY_AUTO_CLEAR_STALL;
+extern BOOL USBPIPEPOLICY_ALLOW_PARTIAL_READS;
+extern BOOL USBPIPEPOLICY_AUTO_FLUSH;
+extern BOOL USBPIPEPOLICY_IGNORE_SHORT_PACKETS;
+extern BOOL USBPIPEPOLICY_SHORT_PACKET_TERMINATE;
+extern DWORD USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT;
+extern BOOL USBPIPEPOLICY_RESET_PIPE_ON_RESUME;
+
 typedef void* tsthread_ptr;
 
-int tsthread_create(tsthread_ptr* const, const struct usb_endpoint_st * const);
+typedef void *(*tsfifo_writeback_begin_t)(int id, size_t max_size, void *arg) ;
+typedef void (*tsfifo_writeback_finish_t)(int id, size_t wrote_size, void *arg) ;
+typedef void (*tsfifo_writethrough_t)(const void *buffer, size_t size, void *arg) ;
+typedef void (*tsfifo_purge_t)(void *arg) ;
+
+struct tsfifo_t {
+  //# For the write-back caching
+  tsfifo_writeback_begin_t      writeBackBegin;
+  tsfifo_writeback_finish_t     writeBackFinish;
+  //# For the write-through caching
+  tsfifo_writethrough_t         writeThrough;
+  //# For purging the fifo cache
+  tsfifo_purge_t                purge;
+  //# App's argument to be called back
+  void *                        arg;
+};
+
+int tsthread_create(tsthread_ptr* const, const struct usb_endpoint_st * const, const struct tsfifo_t *const);
 void tsthread_destroy(const tsthread_ptr);
 void tsthread_start(const tsthread_ptr);
 void tsthread_stop(const tsthread_ptr);
diff -uPr BonD_FSHybrid-20201009_org/src/twindbg.h BonD_FSHybrid-20201009_mod10.1/src/twindbg.h
--- BonD_FSHybrid-20201009_org/src/twindbg.h	2010-09-22 03:19:32.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/twindbg.h	2019-12-06 00:36:44.000000000 +0900
@@ -1,10 +1,39 @@
 #pragma once
 
+#define DEBUG_TO_X_DRIVE
+
 #ifdef _DEBUG
 #include <stdio.h>
-#define DBG_INFO(...) { char d_buff[128]; \
+#include <stdarg.h>
+#define DBG_INFO(...) do{ char d_buff[128]; \
 	_snprintf_s(d_buff,128, __VA_ARGS__); \
-	::OutputDebugStringA(d_buff);}
+	::OutputDebugStringA(d_buff);}while(0)
+#define TRACE(...) do{ wchar_t d_buff[128]; \
+	_snwprintf_s(d_buff,128, __VA_ARGS__); \
+	::OutputDebugStringW(d_buff);}while(0)
+    void __inline DBGOUT( const char* format,... )
+    {
+        va_list marker ;
+        char edit_str[1024] ;
+        va_start( marker, format ) ;
+        vsprintf_s( edit_str, sizeof(edit_str), format, marker ) ;
+        va_end( marker ) ;
+        #ifndef DEBUG_TO_X_DRIVE
+        OutputDebugStringA(edit_str) ;
+        #else
+        {
+			FILE *fp = NULL ;
+            fopen_s(&fp,"X:\\Debug.txt","a+t") ;
+            if(fp) {
+              fputs(edit_str,fp) ;
+              fclose(fp) ;
+            }
+		}
+        #endif
+    }
 #else
-#define DBG_INFO(...) void()
+#define DBG_INFO(...) /*empty*/
+#define TRACE(...) /*empty*/
+#define DBGOUT(...) /*empty*/
 #endif
+
diff -uPr BonD_FSHybrid-20201009_org/src/types_u.h BonD_FSHybrid-20201009_mod10.1/src/types_u.h
--- BonD_FSHybrid-20201009_org/src/types_u.h	2016-01-22 09:39:12.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/types_u.h	2020-04-27 00:20:10.000000000 +0900
@@ -13,7 +13,8 @@
 	unsigned  endpoint;    //# USB endpoint
 	void* dev;
 	int (* startstopFunc)(void * const  dev, const int start);
-	unsigned  xfer_size;    //# transfer unit size
+	int (* lockunlockFunc)(void * const  dev, const int lock);
+    unsigned  xfer_size;    //# transfer unit size
 };
 
 struct i2c_device_st {
diff -uPr BonD_FSHybrid-20201009_org/src/uSUNpTV.sln BonD_FSHybrid-20201009_mod10.1/src/uSUNpTV.sln
--- BonD_FSHybrid-20201009_org/src/uSUNpTV.sln	2016-01-23 00:07:42.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/uSUNpTV.sln	2019-12-16 05:14:42.000000000 +0900
@@ -1,18 +1,26 @@
 ﻿
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual C++ Express 2010
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver", "BonDriver\BonDriver_uSUNpTV.vcxproj", "{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.24720.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_uSUNpTV", "BonDriver_uSUNpTV\BonDriver_uSUNpTV.vcxproj", "{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Win32 = Debug|Win32
-		Release|Win32 = Release|Win32
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|Win32.ActiveCfg = Debug|Win32
-		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|Win32.Build.0 = Debug|Win32
-		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|Win32.ActiveCfg = Release|Win32
-		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|Win32.Build.0 = Release|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x64.ActiveCfg = Debug|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x64.Build.0 = Debug|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x86.ActiveCfg = Debug|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x86.Build.0 = Debug|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x64.ActiveCfg = Release|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x64.Build.0 = Release|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x86.ActiveCfg = Release|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x86.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff -uPr BonD_FSHybrid-20201009_org/src/uSUNpTV_VS2008.sln BonD_FSHybrid-20201009_mod10.1/src/uSUNpTV_VS2008.sln
--- BonD_FSHybrid-20201009_org/src/uSUNpTV_VS2008.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/uSUNpTV_VS2008.sln	2019-12-20 14:08:42.000000000 +0900
@@ -0,0 +1,26 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_uSUNpTV", "BonDriver_uSUNpTV\BonDriver_uSUNpTV.vcproj", "{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|Win32.ActiveCfg = Debug|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|Win32.Build.0 = Debug|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x64.ActiveCfg = Debug|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x64.Build.0 = Debug|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|Win32.ActiveCfg = Release|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|Win32.Build.0 = Release|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x64.ActiveCfg = Release|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/uSUNpTV_isoch.sln BonD_FSHybrid-20201009_mod10.1/src/uSUNpTV_isoch.sln
--- BonD_FSHybrid-20201009_org/src/uSUNpTV_isoch.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/uSUNpTV_isoch.sln	2020-10-03 19:38:34.000000000 +0900
@@ -0,0 +1,28 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.25420.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_uSUNpTV_isoch", "BonDriver_uSUNpTV\BonDriver_uSUNpTV_isoch.vcxproj", "{264FED43-93BD-4D55-B545-DD16668B7BB7}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Debug|x64.ActiveCfg = Debug|x64
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Debug|x64.Build.0 = Debug|x64
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Debug|x86.ActiveCfg = Debug|Win32
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Debug|x86.Build.0 = Debug|Win32
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Release|x64.ActiveCfg = Release|x64
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Release|x64.Build.0 = Release|x64
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Release|x86.ActiveCfg = Release|Win32
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/usbdevfile.cpp BonD_FSHybrid-20201009_mod10.1/src/usbdevfile.cpp
--- BonD_FSHybrid-20201009_org/src/usbdevfile.cpp	2016-01-23 00:02:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/usbdevfile.cpp	2019-12-16 07:27:20.000000000 +0900
@@ -11,15 +11,11 @@
 
 #include "usbdevfile.h"
 
-// Driver Instance GUID
-DEFINE_GUID( GUID_WINUSB_DRV,	0xa70cc802, 0x7309, 0x486d, 0xbe, 0xe8, 0x93, 0xa0, 0x48, 0xcf, 0x6c, 0x63);
-
-HANDLE usbdevfile_alloc(unsigned int * const idx)
+HANDLE usbdevfile_alloc(int * const idx, const GUID *pDrvID)
 {
 	DWORD dwRet;
 	ULONG length;
 	HANDLE hDev = INVALID_HANDLE_VALUE;
-	GUID * const pDrvID = (GUID *)&GUID_WINUSB_DRV;
 
 	// get handle to device info.
 	HDEVINFO deviceInfo = SetupDiGetClassDevs(pDrvID, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
@@ -28,7 +24,10 @@
 	SP_DEVICE_INTERFACE_DATA interfaceData;
 	interfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
 
-	for(; *idx < 40; (*idx)++ ) {
+    const int idmax = (*idx<0) ? 40 : *idx+1 ;
+    if(*idx<0) *idx=0 ;
+
+	for(; *idx < idmax; (*idx)++ ) {
 		//# enumerate device interfaces
 		if( FALSE == SetupDiEnumDeviceInterfaces(deviceInfo, NULL, pDrvID, *idx, &interfaceData) ) {
 			dwRet = GetLastError();
@@ -58,7 +57,7 @@
 		GlobalFree(detailData);
 	}
 	SetupDiDestroyDeviceInfoList(deviceInfo);
-	
+
 	if(INVALID_HANDLE_VALUE == hDev) return NULL;
 	return hDev;
 }
diff -uPr BonD_FSHybrid-20201009_org/src/usbdevfile.h BonD_FSHybrid-20201009_mod10.1/src/usbdevfile.h
--- BonD_FSHybrid-20201009_org/src/usbdevfile.h	2015-12-10 01:42:56.000000000 +0900
+++ BonD_FSHybrid-20201009_mod10.1/src/usbdevfile.h	2020-01-01 16:05:48.000000000 +0900
@@ -5,7 +5,12 @@
 */
 #pragma once
 
-HANDLE usbdevfile_alloc(unsigned int * const idx);
+// Driver Instance GUID
+DEFINE_GUID( GUID_WINUSB_FSUSB2N_DRV,	0xb35924d6, 0x3e09, 0x4a9e, 0x97, 0x82, 0x55, 0x24, 0xa4, 0xb7, 0x9b, 0xa4 );
+DEFINE_GUID( GUID_WINUSB_FSUSB2V3_DRV,	0x77ed26ec, 0x2783, 0x7bba, 0xa8, 0x24, 0x00, 0xbc, 0xad, 0x7a, 0xcd, 0xb9 );
+DEFINE_GUID( GUID_WINUSB_US3POUT_DRV,	0xa70cc802, 0x7309, 0x486d, 0xbe, 0xe8, 0x93, 0xa0, 0x48, 0xcf, 0x6c, 0x63 );
+
+HANDLE usbdevfile_alloc(int * const idx, const GUID *pDrvID);
 HANDLE usbdevfile_init(HANDLE hDev);
 void usbdevfile_free(HANDLE usbHandle);
 
