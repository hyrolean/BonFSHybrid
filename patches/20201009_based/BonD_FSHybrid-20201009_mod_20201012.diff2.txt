diff -uPr BonD_FSHybrid-20201009_org/patching.txt BonD_FSHybrid-20201009_mod2/patching.txt
--- BonD_FSHybrid-20201009_org/patching.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/patching.txt	2020-10-09 01:01:23.000000000 +0900
@@ -0,0 +1,151 @@
+$B%Q%C%A$N=<$FJ}(B
+
+  $B0lEYL\$N%Q%C%A$G$OC1$K$3$N%U%!%$%k$H(Breadme$B$J$I$N%F%-%9%H72$,@8@.$5$l$k$@$1$@$H;W$o$l$k!#(B
+  $B0J2<$N9)Dx$rDI$&$3$H$K$h$C$F3F<+40A4$J%Q%C%A$r@8@.$9$k$3$H$,=PMh$k$+$b$7$l$J$$!#(B
+  $B>0!"$3$N%Q%C%A$r=<$F$k$3$H$K$h$C$FH/@8$7$?B;32$O%Q%C%A:n@.<T$O0l@ZJ]>Z$7$J$$$3$H$H$9$k!#(B
+
+
+$B"#2<=`Hw(B
+
+  $B-!0J2<$N%U%!%$%k$r%M%C%H$+$i=&$C$F$/$k(B
+
+    1) 33ac6f08023bf02372959acc05ff8174  fsusb2n-src-20120929.7z $B"((B1
+    2) d46988c458cb3e94208c138f69c77690  BonD_FSUSB2i-20160219.src.7z $B"((B2
+    3) ca92730e06a52de1a9ad66d6a08410d0  BonD_uSUNpTV-20160219.src.7z $B"((B3
+
+   $B"((B1: http://ktvwiki.22web.org/index.php?Download $B"+(B $B%3%3$GF~<j2D(B($B:G8eHx(B)
+   $B"((B2: http://ktvwiki.22web.org/index.php?BonDriver_FSUSB2i $B"+(B $B%3%3$GF~<j2D(B
+   $B"((B3: http://ktvwiki.22web.org/index.php?BonDriver_uSUNpTV $B"+(B $B%3%3$GF~<j2D(B
+
+  $B-"(Bfsusb2n-src-20120929.7z$B$rE83+$7$F0J2<$N=$@5$r2C$($k(B
+
+    1) $B%U%!%$%kL>$NJQ99(B FSUSB2N-src\BonTuner\BonTuner.vcproj $B"*(B FSUSB2N-src\BonTuner\BonTuner_FSUSB2N.vcproj
+    2) $B%U%!%$%kL>$NJQ99(B FSUSB2N-src\BonTuner\BonTuner.cpp $B"*(B FSUSB2N-src\BonTuner\BonTuner_FSUSB2N.cpp
+    3) $B%U%!%$%kL>$NJQ99(B FSUSB2N-src\BonTuner\BonTuner.h $B"*(B FSUSB2N-src\BonTuner\BonTuner_FSUSB2N.h
+    4) $B%U%)%k%@L>$NJQ99(B FSUSB2N-src\BonTuner $B"*(B FSUSB2N-src\BonTuner_FSUSB2N
+    5) $B%U%)%k%@L>$NJQ99(B FSUSB2N-src $B"*(B src
+
+  $B-#(BBonD_FSUSB2i-20160219.src.7z$B$rE83+$7$F0J2<$N=$@5$r2C$($k(B
+
+    1) $B%U%!%$%kL>$NJQ99(B src\BonTuner\BonTuner.cpp $B"*(B src\BonTuner\BonTuner_FSUSB2i.cpp
+    2) $B%U%!%$%kL>$NJQ99(B src\BonTuner\BonTuner.h $B"*(B src\BonTuner\BonTuner_FSUSB2i.h
+    3) $B%U%)%k%@L>$NJQ99(B src\BonTuner $B"*(B src\BonTuner_FSUSB2i
+
+  $B-$(BBonD_uSUNpTV-20160219.src.7z$B$rE83+$7$F0J2<$N=$@5$r2C$($k(B
+
+    1) $B%U%!%$%kL>$NJQ99(B src\BonTuner\BonTuner.cpp $B"*(B src\BonTuner\BonTuner_uSUNpTV.cpp
+    2) $B%U%!%$%kL>$NJQ99(B src\BonTuner\BonTuner.h $B"*(B src\BonTuner\BonTuner_uSUNpTV.h
+    3) $B%U%)%k%@L>$NJQ99(B src\BonTuner $B"*(B src\BonTuner_uSUNpTV
+
+  $B-%(Bsrc$B%U%)%k%@$rE}9g(B
+
+    $B>e5-$N#3$D$N%U%!%$%k$rE83+$7$F=$@5$r2C$($?7k2L=PMh$"$,$C$?#3$D$N8DJL$N(Bsrc$B%U%)%k%@$rF10l$N(Bsrc$B%U%)%k%@$H$7$F>e=q$-$7$FE}9g$9$k(B
+    $B"(=EJ#$9$k%U%!%$%k$O(B"$B?7$7$$%U%!%$%k(B"$B$NJ}$G>e=q$-$9$k$3$H!JF|IU$,F1$8$+8E$$%U%!%$%k$O%9%-%C%W$9$k!K(B
+
+  $B-&(Bsrc\inc\legacy$B%U%)%k%@$N:n@.$H%U%!%$%k$N0\F0(B
+  
+    $B=PMh>e$,$C$?E}9g%U%)%k%@(Bsrc$BG[2<$N(Binc$B%U%)%k%@$NCf$K(Blegacy$B$H$$$&?75,%U%)%k%@$r:n@.$7!"$=$N:n@.$7$?(Blegacy$B%U%)%k%@$K0J2<$N#29`L\$N%U%!%$%k$r0\F0$9$k(B
+    
+    1) $B%U%!%$%k$N0\F0(B src\inc\winusb.h $B"*(B src\inc\legacy\winusb.h
+    2) $B%U%!%$%k$N0\F0(B src\inc\winusbio.h $B"*(B src\inc\legacy\winusbio.h
+    
+  $B-'(BFSHybrid$B%U%)%k%@$r:n@.$7$F%k!<%H$K$9$k(B
+
+    $BE}9g$,40N;$7$?(Bsrc$B%U%)%k%@$HF13,AX>e$K(BFSHybrid$B%U%)%k%@$r:n$j!"(Bsrc$B%U%)%k%@$4$H(BFSHybrid$B%U%)%k%@$NCf$X0\F0$9$k(B
+
+  $B-(%G%#%l%/%H%j%D%j!<9=B$$r3NG'$9$k(B
+
+    $B%U%)%k%@$N3,AX$,0J2<$N$h$&$J%D%j!<9=B$$G9=@.$5$l$F$$$k$3$H$r3NG'$9$k(B
+
+     <FSHybrid>
+      `--<src>
+          |--<BonDriver_FSUSB2N>
+          |   |-- 14071a2340874b69b16a370107255b93  BonDriver.rc
+          |   |-- 5009476bd025d7ad3caa901da47fc628  BonDriver_FSUSB2N.vcproj
+          |   |-- 7b5e3739173d7de017e222b18947de85  BonTuner_FSUSB2N.cpp
+          |   |-- 9a813835243e70b1c7f19187baf560af  BonTuner_FSUSB2N.h
+          |   |-- cdbfc961c3dc8f0ac6c579ea586832b5  dllmain.cpp
+          |   |-- 65e6e3d79ad3ced6c525378dae395cd0  stdafx.cpp
+          |   `-- 38007ee695d8f22e79d0e76bc296a22e  stdafx.h
+          |--<BonDriver_FSUSB2i>
+          |   |-- 38854f78b814c2909db5298e48c85446  BonDriver.rc
+          |   |-- 9de57bf59af30d8aa6e3e0978a4ef8f5  BonDriver_FSUSB2i.vcxproj
+          |   |-- d577da9bbdcefc5cf476c29fcd062e00  BonDriver_FSUSB2i.vcxproj.filters $B"((B
+          |   |-- b7a22e70347383444c0c7fe9a77474eb  BonDriver_FSUSB2i.vcxproj.user $B"((B
+          |   |-- 251ae6943e2b406aea61be92c56a5c75  BonTuner_FSUSB2i.cpp
+          |   |-- e9f835dd28dd6ff7da7a477c00e19742  BonTuner_FSUSB2i.h
+          |   |-- 88a10878ae76f396798672be97c0fec1  dllmain.cpp
+          |   |-- 0f98e16fbd1fa15aebca4db062f1ef85  stdafx.c
+          |   |-- 6ab53a63f9a44cb6f5ecfd055a907134  stdafx.h
+          |   `-- 0f98e16fbd1fa15aebca4db062f1ef85  stdafx2.cpp
+          |--<BonDriver_uSUNpTV>
+          |   |-- 395e4076e8320ec201699bcbe5900003  BonDriver.rc
+          |   |-- 125cd70a7c437eb5d5e6ed4fe4710a3a  BonDriver_uSUNpTV.vcxproj
+          |   |-- 2bd50d33ef16b3bdd0bf66e9ea6d015c  BonDriver_uSUNpTV.vcxproj.filters $B"((B
+          |   |-- b7a22e70347383444c0c7fe9a77474eb  BonDriver_uSUNpTV.vcxproj.user $B"((B
+          |   |-- 203349afbc699a983bd88ad441ee459f  BonTuner_uSUNpTV.cpp
+          |   |-- 92cf0f2d7938860d46c990743429eeb2  BonTuner_uSUNpTV.h
+          |   |-- 88a10878ae76f396798672be97c0fec1  dllmain.cpp
+          |   |-- 0f98e16fbd1fa15aebca4db062f1ef85  stdafx.c
+          |   |-- 6ab53a63f9a44cb6f5ecfd055a907134  stdafx.h
+          |   `-- 0f98e16fbd1fa15aebca4db062f1ef85  stdafx2.cpp
+          |--<inc>
+          |   |-- ff2511620cb48e582be9ff138fb7ac7e  IBonDriver.h
+          |   |-- 01f7183a9e294c57dbd2527651a3dc5a  IBonDriver2.h
+          |   |-- 19385f4f504162ab3e5e9e78a714b688  usb.h
+          |   |-- 95e6b2dfedec517d62fb172f12790c38  usb100.h
+          |   |-- 3e4cf48f6585a52456b16403769eb631  usb200.h
+          |   `--<legacy>
+          |       |-- 85207bb61f771871b36aa9121ae25bbe  winusb.h
+          |       `-- 69cc6ce4c1d8ea195d746359c06ad78e  winusbio.h
+          |--<lib>
+          |   `-- 200155c22aa44ecd566b4290f56ef4df  winusb.lib
+          |--<lib64>
+          |   `-- 727449d734bfb2daad67568ff27efc0f  winusb.lib
+          |-- c2f62cf93ec519b33786ba49a4d7d6ef  FSUSB2i.sln
+          |-- 348c14eaa696d92a20c7ced00cdcf93b  em2874.cpp
+          |-- d21854b3f6a1a93d8e085dd4a337a38d  em2874.h
+          |-- afcb47262bef1a9c793a75b52771d084  em287x.c
+          |-- a086f2dd5a16ca1215a8586dc00a035a  em287x.h
+          |-- 6b0d232c8a6a76f9347cc40a68f1a4af  em287x_priv.h
+          |-- 6a7b277dcae7e35a43bc38b312938ac7  em287x_usb.c
+          |-- 08971f62053b3d04a5cc99eb536a1fed  em287x_usb.h
+          |-- f59f8b3850d5a23b99301c4fc9092d0f  it9175.c
+          |-- 8667f851f592562d4003087e5dba625b  it9175.h
+          |-- 754f3cbbdf52dcce297467d0e6a2520c  it9175_fw.h
+          |-- d38813a015adafb6b1bdd9a464a05b8d  it9175_priv.h
+          |-- 1326dc92706ba28b88a70bb5687a95ef  it9175_usb.c
+          |-- d8c5649a2bfcdf736f201a956b31e54d  it9175_usb.h
+          |-- 453f897bbe3f8f431641fc41d02d3e08  ktv.cpp
+          |-- 033750ec2dc3e8012ea3653635093db6  ktv.h
+          |-- 46cd3bf9afda7dc48e69f55475009f0d  message.c
+          |-- f5a991f0018935a543d2b915701555db  message.h
+          |-- aff132772e86436ba116c331d9634b9c  mxl136.c
+          |-- 584ca5fbc404fafa015dba0bbb442416  mxl136.h
+          |-- 153be3cf1c681c60b9659758224828f7  osdepend.c
+          |-- 3d14334c2f325708543bfa76ab7ed490  osdepend.h
+          |-- 62f70654d9b275f3c34ef8d6127bab8e  targetver.h
+          |-- b3019d7afcd706f21904b27ca50d2124  tc90522.c
+          |-- 150d362d4cf59e7d20f2a35d9d26ebfc  tc90522.h
+          |-- 51b884a54318b19ed9cbe84135881ac1  tda20142.c
+          |-- dd05eae951f8a24c1e867a41d16b091f  tda20142.h
+          |-- 3011e3daa628ab299caee6822fc11dc9  tsbuff.h
+          |-- a2c129561323cf41bd840b9672924a2f  tsthread.c
+          |-- 19296dc339524b226bc80a8629149471  tsthread.h
+          |-- 289e2c6f0d4955cc2d84962d3cd83072  twindbg.h
+          |-- 96dabbc3238c41ca178bd4ca9a9743b5  types_u.h
+          |-- b54f9e90fd9c2c885652fd602e57d60c  uSUNpTV.sln
+          |-- fb56b93a573dc4478b3fe88935662a4c  usbdevfile.cpp
+          |-- d4b4523c9754d3a612775dcbba7ab05f  usbdevfile.h
+          |-- 93c80d9dddf9bb6c6394b42a5aac5ea9  usbops.c
+          `-- 4962a4e00482019927089a06f4e20561  usbops.h
+
+    $B"((B: $B:o=|2D(B
+
+
+$B"#%Q%C%A$r=<$F$k(B
+
+  $B%7%'%k$r5/F0$7%+%l%s%H%G%#%l%/%H%j$r(BFSHybrid$B%U%)%k%@$K0\$7!"0J2<$N%3%^%s%I$r<B9T$7$F%Q%C%A$r40N;$5$;$k(B
+
+  patch -p1 --binary < BonD_FSHybrid_20201009_mod_xxxxxxxx.patch.diff
+
diff -uPr BonD_FSHybrid-20201009_org/readme_mod_FSHybrid.txt BonD_FSHybrid-20201009_mod2/readme_mod_FSHybrid.txt
--- BonD_FSHybrid-20201009_org/readme_mod_FSHybrid.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/readme_mod_FSHybrid.txt	2020-10-12 00:44:00.000000000 +0900
@@ -0,0 +1,78 @@
+BonDriver_FSHybrid.dll MOD @ 2020/10/12
+
+KEIAN/Digibestn3̋@\𓯎ɗLnCubh^BonDriver.dll
+
+  t@Cς邱Ƃɂ蓮ύX\
+  t@CK؂ɕύXȂƂƓ삵Ȃ̂Œ
+
+  BonDriver_FSHybrid.dll
+   BonDriver_FSUSB2N.dll / BonDriver_FSUSB2Nxxxxxx.dll 
+
+    FSUSB2V^(V2)A܂́AFSPCIE p BonDriver Ƃē
+
+      戵 : readme_mod_FSUSB2N.txt
+
+
+  BonDriver_FSHybrid.dll
+   BonDriver_FSUSB2i.dll / BonDriver_FSUSB2ixxxxxx.dll 
+
+    FSUSB2/V3A܂́AFSMINI p BonDriver Ƃē
+
+      戵 : readme_mod_FSUSB2i.txt
+
+
+  BonDriver_FSHybrid.dll
+   BonDriver_uSUNpTV.dll / BonDriver_uSUNpTVxxxxxx.dll 
+
+    US-3POUT (ςOo) p BonDriver Ƃē
+
+      戵 : readme_mod_uSUNpTV.txt
+
+
+  : xxxxxx ́ACӂ̉p
+
+
+XV
+
+2020/10/9 ̕ύX_
+
+  Einit@CNULLpPbgVbgAEg邩ǂ𔻒f邽߂̃tO
+    TSCACHING_DROPNULLPACKETS ڂǉ
+
+2020/6/20 ̕ύX_
+
+  Einit@CɃoN]̃pPbgTCYI[o[Ch邱Ƃ̂ł
+    TSCACHING_BULKPACKETSIZE ڂǉ
+
+  EAC\NiX]ɑΉȉ̃\[VVɒǉ
+
+     FSHybrid_isoch.sln / uSUNpTV_isoch.sln / FSUSB2N_isoch.sln
+
+2020/4/27 ̕ύX_
+
+  Einit@CɈȉ̎OñVOi擾rɊւtOǉ
+  
+     FSUSB2N_LOCK_ON_SIGNAL / FSUSB2I_LOCK_ON_SIGNAL / USUNPTV_LOCK_ON_SIGNAL
+  
+2020/1/12 ̕ύX_
+
+  EdBǂĂȂƂ肱ڂ̃v`hbvۂ̍{IȖC
+   iWinUsb̃pCvǏon̏rōsdg݂̃R[hǉđΉj
+
+2020/1/3 ̕ύX_
+
+  Einit@Cݒǂݍ߂@\ǉ
+    (TvƂBonDriver_FSHybrid.iniYt)
+
+  EfoCX̏Ɏsꍇ͊ōőR܂ōĎsdlɕύX
+
+2019/12/23 ̕ύX_
+
+  ER[ht@N^OăoCiTCY10KB팸
+
+
+gp
+
+  ۏ؁iNO WARRANTYj
+
+
diff -uPr BonD_FSHybrid-20201009_org/readme_mod_FSUSB2N.txt BonD_FSHybrid-20201009_mod2/readme_mod_FSUSB2N.txt
--- BonD_FSHybrid-20201009_org/readme_mod_FSUSB2N.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/readme_mod_FSUSB2N.txt	2020-10-12 00:53:46.000000000 +0900
@@ -0,0 +1,100 @@
+BonDriver_FSUSB2N.dll MOD @ 2020/10/9
+
+IWiłVɒǉ@\
+
+  EIDŌʎwł@\ǉ
+
+    BonDriver_FSUSB2N_dev + ID(ԍ) + .dll ̃t@C̋Lq@Ŏw\B
+    BonDriver_FSUSB2N_dev0.dll  ڑ1Ԗڂ̋@
+    BonDriver_FSUSB2N_dev1.dll  ڑ2Ԗڂ̋@
+    BonDriver_FSUSB2N_dev2.dll  ڑ3Ԗڂ̋@
+    LȊŐLq̏ꍇ́A󂢂Ă@킩珇ɒTIWiɏB
+    BonDriver_FSUSB2N_abc.dll ȂǂƋLqƂ܂܂Œʂ莩IDĂB
+
+
+  EƎ`lt@C@\ǉ
+
+    hCoƓOŊgq .ch.txt ɂ̂Ƀ`lLq
+    ƂɂƎ̃`lɃAW邱Ƃ\B
+    TvƂ BonDriver_FSUSB2N.ch.txt YtB
+
+
+XV
+
+2020/6/20 ̕ύX_
+
+  EWindows8.1ȍ~œ삷AC\NiX](ύXK0905̌)ɑΉv
+    WFNgt@C BonDriver_FSUSB2N_isoch.vcxproj Vɒǉ
+    (̃[hœ삳ꍇ́AύXK0905EEPROMɏĂB
+     \[Vt@C FSUSB2N_isoch.sln \zĂB)
+
+2020/5/22 ̕ύX_
+
+  EJ`[i[ۂɋHɃt[YsC
+
+2020/4/27 ̕ύX_
+
+  EVOi擾ɓ]~߂邩ǂ肷tO .ini ɒǉ
+    ( FSUSB2N_LOCK_ON_SIGNALŕύX\ l1<bN> )
+    
+2019/12/22 ̕ύX_
+
+  EVOi擾̍œK
+
+2019/12/8 ̕ύX_
+
+  ELbVAP[^hbvNƂ̂oOC[12/22]
+
+  E\[Xɂ񓯊obt@Ɋւ鐔l𒲐[12/21(ES)]
+
+    pPbgTCY̕ύXɔA񓯊obt@Ɋւȉ̋Kl
+
+      ASYNCTS_QUEUENUM c obt@ Kl66  3M (47K*66) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl660 30M (47K*660) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl22 1MB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl11 0.5MB
+
+  ELbVAP[^̃ANZXG[sC[12/21(ES)]
+
+2019/12/7 ̕ύX_
+
+  EWXgɔ񓯊obt@ɊւIvVǉ
+
+    WXg HKEY_CURRENT_USER\Software\tri.dw.land.to\FSUSB2N 
+    ȉ̂SڂDWORDlŕύX\B
+
+      ASYNCTS_QUEUENUM c obt@ Kl32  2M (64K*32) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl320 20M (64K*320) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl12 750KB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl6 375KB
+
+2018/3/4 ̕ύX_
+
+  EWXgɃLbVOɊւIvVǉ
+
+    WXg HKEY_CURRENT_USER\Software\tri.dw.land.to\FSUSB2N 
+    "TSCACHING_LEGACY"ƂDWORDl쐬ĒlƂ"1"Lq
+    tri.dw.land.to񒼓`̃LbVœ삳邱Ƃ\B
+    (s̃LbVɖ߂ɂ͒l̂폜邩lƂ"0"Lq)
+
+  EFIFOobt@OœK
+
+    Hɔhbv̏CB
+
+2015/1/4 ̕ύX_
+
+  EJ VisualStudio 2015 ɕύX
+  EIDŌʎwł@\̃t@C̏
+	 BonDriver_FSUSB2_ + ԍ + .dll 
+	 BonDriver_FSUSB2N_dev + ԍ + .dll ɕύX
+
+2015/1/3 ̕ύX_
+
+  EPurgeTSStream() R[ƍňTSXg[XgbvoOC
+
+
+gp
+
+  ۏ؁iNO WARRANTYj
+
+
diff -uPr BonD_FSHybrid-20201009_org/readme_mod_FSUSB2i.txt BonD_FSHybrid-20201009_mod2/readme_mod_FSUSB2i.txt
--- BonD_FSHybrid-20201009_org/readme_mod_FSUSB2i.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/readme_mod_FSUSB2i.txt	2020-05-22 19:03:32.000000000 +0900
@@ -0,0 +1,76 @@
+BonDriver_FSUSB2i.dll MOD @ 2020/5/22
+
+IWiłVɒǉ@\
+
+  ELbV̐ؑւɑΉ(2019/12/7)
+
+    WXg HKEY_CURRENT_USER\Software\trinity19683\FSUSB2i 
+    "TSCACHING_LEGACY"ƂDWORDl쐬ĒlƂ"1"Lq
+    trinity19683񒼓`̃LbVœ삳邱Ƃ\B
+    (s̃LbVɖ߂ɂ͒l̂폜邩lƂ"0"Lq)
+
+  Eobt@̍œK
+
+    Hɔhbv̏CB
+
+  EIDŌʎwł@\ǉ
+
+    BonDriver_FSUSB2i_dev + ID(ԍ) + .dll ̃t@C̋Lq@Ŏw\B
+    BonDriver_FSUSB2i_dev0.dll  ڑꂽPԖڂFSUSB2/V3
+    BonDriver_FSUSB2i_dev1.dll  ڑꂽQԖڂFSUSB2/V3
+    BonDriver_FSUSB2i_dev2.dll  ڑꂽRԖڂFSUSB2/V3
+    LȊŐLq̏ꍇ́A󂢂Ă@킩珇ɒTIWiɏB
+    BonDriver_FSUSB2i_A.dll ȂǂƋLqƂ܂܂Œʂ莩IDĂB
+
+
+  EƎ`lt@C@\ǉ
+
+    hCoƓOŊgq .ch.txt ɂ̂Ƀ`lLq
+    ƂɂƎ̃`lɃAW邱Ƃ\B
+    TvƂ BonDriver_FSUSB2i.ch.txt YtB
+
+
+XV
+
+2020/4/27 ̕ύX_
+
+  EBonDriver_FSUSB2iL̍{Iȃv`hbvC[it9175.c(515)]
+  EVOi擾ɓ]~߂邩ǂ肷tO .ini ɒǉ
+    ( FSUSB2I_LOCK_ON_SIGNALŕύX\ l1<bN> )
+
+2019/12/22 ̕ύX_
+
+  EVOi擾̊ȗƍœK
+
+2019/12/8 ̕ύX_
+
+  ELbVAP[^hbvNƂ̂oOC[12/22]
+
+  E\[Xɂ񓯊obt@Ɋւ鐔l𒲐[12/21(ES)]
+
+    pPbgTCY̕ύXɔA񓯊obt@Ɋւȉ̋Kl
+
+      ASYNCTS_QUEUENUM c obt@ Kl66  3M (47K*66) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl660 30M (47K*660) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl22 1MB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl11 0.5MB
+
+  ELbVAP[^̃ANZXG[sC[12/21(ES)]
+
+2019/12/7 ̕ύX_
+
+  EWXgɔ񓯊obt@ɊւIvVǉ
+
+    WXg HKEY_CURRENT_USER\Software\trinity19683\FSUSB2i 
+    ȉ̂SڂDWORDlŕύX\B
+
+      ASYNCTS_QUEUENUM c obt@ Kl32  2M (64K*32) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl320 20M (64K*320) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl12 750KB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl6 375KB
+
+gp
+
+  ۏ؁iNO WARRANTYj
+
+
diff -uPr BonD_FSHybrid-20201009_org/readme_mod_uSUNpTV.txt BonD_FSHybrid-20201009_mod2/readme_mod_uSUNpTV.txt
--- BonD_FSHybrid-20201009_org/readme_mod_uSUNpTV.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/readme_mod_uSUNpTV.txt	2020-10-12 00:53:25.000000000 +0900
@@ -0,0 +1,100 @@
+BonDriver_uSUNpTV.dll MOD @ 2020/10/9
+
+IWiłVɒǉ@\
+
+  ELbV̐ؑւɑΉ(2019/12/7)
+
+    WXg HKEY_CURRENT_USER\Software\trinity19683\FSUSB2i 
+    "TSCACHING_LEGACY"ƂDWORDl쐬ĒlƂ"1"Lq
+    trinity19683񒼓`̃LbVœ삳邱Ƃ\B
+    (s̃LbVɖ߂ɂ͒l̂폜邩lƂ"0"Lq)
+
+  ELbVŐ(2019/12/1)
+
+    obt@ỎP
+
+  EIDŌʎwł@\ǉ
+
+    BonDriver_uSUNpTV_dev + ID(ԍ) + .dll ̃t@C̋Lq@Ŏw\B
+    BonDriver_uSUNpTV_dev0.dll  ڑꂽPԖڂUS-3POUT
+    BonDriver_uSUNpTV_dev1.dll  ڑꂽQԖڂUS-3POUT
+    BonDriver_uSUNpTV_dev2.dll  ڑꂽRԖڂUS-3POUT
+    LȊŐLq̏ꍇ́A󂢂Ă@킩珇ɒTIWiɏB
+    BonDriver_uSUNpTV_A.dll ȂǂƋLqƂ܂܂Œʂ莩IDĂB
+
+
+  EƎ`lt@C@\ǉ
+
+    hCoƓOŊgq .ch.txt ɂ̂Ƀ`lLq
+    ƂɂƎ̃`lɃAW邱Ƃ\B
+    TvƂ BonDriver_uSUNpTV.ch.txt YtB
+
+
+XV
+
+2020/5/22 ̕ύX_
+
+  EWindows8.1ȍ~œ삷AC\NiX](̌)ɑΉvWF
+    Ngt@C BonDriver_uSUNpTV_isoch.vcxproj Vɒǉ
+    (\[Vt@C uSUNpTV_isoch.sln \zĂB)
+
+2020/4/27 ̕ύX_
+
+  EVOi擾ɓ]~߂邩ǂ肷tO .ini ɒǉ
+    ( USUNPTV_LOCK_ON_SIGNALŕύX\ l1<bN> )
+    
+2019/12/23 ̕ύX_
+
+  EVOi擾̍œK
+
+2019/12/22 ̕ύX_
+
+  ENHK BS1  X^[`l2/3 A`l BS15/TS1  BS15/TS2 
+    v BS15/TS0  BS15/TS1 ̊Ԉ`lƈv̏C
+    (PSKWX^甲tsid̉3rbg`l̃Xg[
+     ԍƎۂɈv邩ǂrĊmFR[hʓrǉđΉ)
+
+2019/12/9 ̕ύX_
+
+  ELbVAP[^hbvNƂ̂oOC[12/22]
+
+  EBS`l̃Xg[ؑւ̃^C~OĒ[12/21(ES)]
+    (PSKWX^tmcerrrbgNAmɎbҋ@Ătsidؑւ)
+
+  ELbVAP[^̃ANZXG[sC[12/21(ES)]
+
+2019/12/8 ̕ύX_
+
+  EUSB BULK Xg[̒ʐMpPbgTCYő47KBɕύX
+    ( 12/8C64KB͂R[hCYĂĐݒłĂȂB
+      R[hʁA47KB傫l͐ݒłȂۂB )
+
+  E񓯊obt@Ɋւ鐔l𒲐
+
+    pPbgTCY̕ύXɔA񓯊obt@Ɋւȉ̋Kl
+
+      ASYNCTS_QUEUENUM c obt@ Kl66  3M (47K*66) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl660 30M (47K*660) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl22 1MB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl11 0.5MB
+
+2019/12/7 ̕ύX_
+
+  E`lt@C̕`lTSID(ID[])Lqł鍀ڂǉ
+  EBS`l̃Xg[ؑւɋHɎs邱Ƃ̂錻ۂC
+  EWXgɔ񓯊obt@ɊւIvVǉ
+
+    WXg HKEY_CURRENT_USER\Software\trinity19683\FSUSB2i 
+    ȉ̂SڂDWORDlŕύX\B
+
+      ASYNCTS_QUEUENUM c obt@ Kl32  2M (64K*32) bytes
+      ASYNCTS_QUEUEMAX c őobt@ Kl320 20M (64K*320) bytes
+      ASYNCTS_EMPTYBORDER c AP[VJnobt@ Kl12 750KB
+      ASYNCTS_EMPTYLIMIT c I[o[bvۏႷobt@ Kl6 375KB
+
+
+gp
+
+  ۏ؁iNO WARRANTYj
+
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_FSHybrid.ini BonD_FSHybrid-20201009_mod2/sample/BonDriver_FSHybrid.ini
--- BonD_FSHybrid-20201009_org/sample/BonDriver_FSHybrid.ini	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/sample/BonDriver_FSHybrid.ini	2020-10-12 00:05:46.000000000 +0900
@@ -0,0 +1,169 @@
+; BonDriver_FSHybrid.ini FSnBonDriver̋ʍ (2020/10/12)
+;
+;       eBonDriver̋ʍڂύXꍇ́Ãt@CҏW
+;     eBonDriver݂fBNg BonDriver_FSHybrid.ini Ƃ
+;     ̃t@CuƁAʍڂƂĊeBonDriverɐݒ肪ǂݏo܂B
+;       ܂Ãt@CeBonDriverDLLt@C̃vtBbNX+.ini
+;     OύXABonDriverƓfBNgɒuĂƁÅeDLL
+;     ʂ̐ݒƂēǂݍ܂邱Ƃ\łB
+;
+;     WXg .ini ɓ񂪑݂ꍇA.ini ̕D悳܂B
+;
+[BonTuner]
+
+; Lɂtrinity19683񒼓`̃LbVɕύX[0/1]
+TSCACHING_LEGACY=0
+; LbV𐮍邩ǂ[0/1]i肷邪ׂj
+TSCACHING_DEFRAGMENT=0
+; LbV𐮍ꍇ̃pPbgTCY[bytes]
+TSCACHING_DEFRAGSIZE=131072
+; oN][h̃I[o[ChpPbgTCY[bytes]
+;TSCACHING_BULKPACKETSIZE=65536
+; NULLpPbgVbgAEg邩ǂ[0/1]
+TSCACHING_DROPNULLPACKETS=1
+
+; 񓯊LbV̐ݒ
+ASYNCTS_QUEUENUM=66
+ASYNCTS_QUEUEMAX=660
+ASYNCTS_EMPTYBORDER=22
+ASYNCTS_EMPTYLIMIT=11
+
+; foCXɎsꍇɍĎső
+DEVICE_RETRY_TIMES=3
+
+; USBfoCX̃pCv|V[
+USBPIPEPOLICY_RAW_IO=1
+USBPIPEPOLICY_AUTO_CLEAR_STALL=1
+USBPIPEPOLICY_ALLOW_PARTIAL_READS=1
+USBPIPEPOLICY_AUTO_FLUSH=0
+USBPIPEPOLICY_IGNORE_SHORT_PACKETS=0
+USBPIPEPOLICY_SHORT_PACKET_TERMINATE=0
+USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT=5000
+USBPIPEPOLICY_RESET_PIPE_ON_RESUME=0
+
+; BonDriver_FSUSB2N ŗL̐ݒ
+FSUSB2N_INTERIM_WAIT=20
+FSUSB2N_SETFREQ_TIMES=2
+FSUSB2N_RESETDEMOD_TIMES=1
+FSUSB2N_LOCK_ON_SIGNAL=1
+
+; BonDriver_FSUSB2i ŗL̐ݒ
+FSUSB2I_SETFREQ_TIMES=2
+FSUSB2I_TUNING_WAIT=1500
+FSUSB2I_LOCK_ON_SIGNAL=1
+
+; BonDriver_uSUNpTV ŗL̐ݒ
+USUNPTV_SETSFREQ_TIMES=1
+USUNPTV_SETSTSID_TIMES=2
+USUNPTV_SETTFREQ_TIMES=1
+USUNPTV_SETSLOCK_WAIT=10
+USUNPTV_SETSTSID_WAIT=800
+USUNPTV_CHANNEL_WAIT=480
+USUNPTV_LOCK_ON_SIGNAL=1
+
+
+;  ȉ̃IvVύXʁAAvP[VŗL̃`l
+; ꍇAɔAvP[Ṽ`l̍폜
+; XLʓrKvɂȂ邱ƂׁAAvP[V̋cȂ
+; ꂮ\ɒӂȂ珑ĂB
+
+; ̃`lVHF܂߂邩ǂ[0/1]
+DEFSPACE_VHF=0
+; ̃`lUHF܂߂邩ǂ[0/1]
+DEFSPACE_UHF=1
+; ̃`lCATV܂߂邩ǂ[0/1]
+DEFSPACE_CATV=0
+; ̃`lɃWXg̃`l܂߂邩ǂ[0/1]
+DEFSPACE_AUX=1
+; ̎Og`[i[`lBS܂߂邩ǂ[0/1]
+DEFSPACE_BS=1
+; ̎Og`[i[BS`l̊eXg[[0-8]
+DEFSPACE_BS_STREAMS=3
+; ̎Og`[i[`lCS110܂߂邩ǂ[0/1]
+DEFSPACE_CS110=1
+; ̎Og`[i[CS110`l̊eXg[[0-8]
+DEFSPACE_CS110_STREAMS=0
+; ̃`ĺA`lt@C .ch.txt `Ă
+; ̃`lt@C̕D悳Ã`l͔j܂B
+
+; IBonDriverSetChannelɃ`lt@C̒`gp邩ǂ[0/1]
+; (`lt@C݂ꍇɗL)
+BYTETUNING_USER=0
+
+; gpȂ`[i[Ԃ̗ InvisibleSpaces ɋLq
+; ̃`[i[Ԃƃ`ĺA܂B
+;InvisibleSpaces=VHF,CATV
+
+; `[i[Ԃ̗ SpaceArrangement ɋLqƂ̋Lqꂽ
+; ԒʂɃ`[i[Ԃבւĕ\邱Ƃ\łB
+;iLq̂Ȃ`[i[Ԃ͎IɍŌɒǋLBj
+;SpaceArrangement=UHF,AUX,BS,CS110
+
+
+[Channels]
+; ɃWXg̃`lƓ`̋LqsƂɂ背WXg
+; `lo^ȂĂAUX`[i[Ԃ̃`lƂēo^
+; Ƃł܂B
+; ȉ"CATV̎gϊpXX[̐ݒ背WXg"̓eƓłB
+; ̃`l𖳌ɂɂ́A[Channels]ZNV폜
+;   A[BonTuner]ZNVDEFSPACE_AUX̒l0ɂĂB
+C13=0x0001B227
+C14=0x0101C997
+C15=0x0201E107
+C16=0x0301F877
+C17=0x04020FE7
+C18=0x05022757
+C19=0x06023EC7
+C20=0x07025637
+C21=0x08026DA7
+C22=0x09028CE7
+VHF4=0x0A02A457
+VHF5=0x0B02BBC7
+VHF6=0x0C02D337
+VHF7=0x0D02EAA7
+VHF8=0x0E030217
+VHF9=0x0F0311B7
+VHF10=0x10032927
+VHF11=0x11034097
+VHF12=0x12035807
+C23=0x13036F77
+C24=0x140386E7
+C25=0x15039E57
+C26=0x1603B5C7
+C27=0x1703CD37
+C28=0x1803E4A7
+C29=0x1903FC17
+C30=0x1A041387
+C31=0x1B042AF7
+C32=0x1C044267
+C33=0x1D0459D7
+C34=0x1E047147
+C35=0x1F0488B7
+C36=0x2004A027
+C37=0x2104B797
+C38=0x2204CF07
+C39=0x2304E677
+C40=0x2404FDE7
+C41=0x25051557
+C42=0x26052CC7
+C43=0x27054437
+C44=0x28055BA7
+C45=0x29057317
+C46=0x2A058A87
+C47=0x2B05A1F7
+C48=0x2C05B967
+C49=0x2D05D0D7
+C50=0x2E05E847
+C51=0x2F05FFB7
+C52=0x30061727
+C53=0x31062E97
+C54=0x32064607
+C55=0x33065D77
+C56=0x340674E7
+C57=0x35068C57
+C58=0x3606A3C7
+C59=0x3706BB37
+C60=0x3806D2A7
+C61=0x3906EA17
+C62=0x3A070187
+C63=0x3B0718F7
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2N.ch - MHz.txt BonD_FSHybrid-20201009_mod2/sample/BonDriver_FSUSB2N.ch - MHz.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2N.ch - MHz.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/sample/BonDriver_FSUSB2N.ch - MHz.txt	2015-01-02 07:01:08.000000000 +0900
@@ -0,0 +1,135 @@
+; BonDriver_FSUSB2N p `lt@CgMHz\LC (2015/1/2)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; Xy[X, `lԍorgMHz, `l
+
+  ; VHF
+
+VHF, 93.143MHz, 1ch
+VHF, 99.143MHz, 2ch
+VHF,105.143MHz, 3ch
+VHF,173.143MHz, 4ch
+VHF,179.143MHz, 5ch
+VHF,185.143MHz, 6ch
+VHF,191.143MHz, 7ch
+VHF,195.143MHz, 8ch
+VHF,201.143MHz, 9ch
+VHF,207.143MHz,10ch
+VHF,213.143MHz,11ch
+VHF,219.143MHz,12ch
+
+  ; UHF
+
+UHF,473.143MHz,13ch
+UHF,479.143MHz,14ch
+UHF,485.143MHz,15ch
+UHF,491.143MHz,16ch
+UHF,497.143MHz,17ch
+UHF,503.143MHz,18ch
+UHF,509.143MHz,19ch
+UHF,515.143MHz,20ch
+UHF,521.143MHz,21ch
+UHF,527.143MHz,22ch
+UHF,533.143MHz,23ch
+UHF,539.143MHz,24ch
+UHF,545.143MHz,25ch
+UHF,551.143MHz,26ch
+UHF,557.143MHz,27ch
+UHF,563.143MHz,28ch
+UHF,569.143MHz,29ch
+UHF,575.143MHz,30ch
+UHF,581.143MHz,31ch
+UHF,587.143MHz,32ch
+UHF,593.143MHz,33ch
+UHF,599.143MHz,34ch
+UHF,605.143MHz,35ch
+UHF,611.143MHz,36ch
+UHF,617.143MHz,37ch
+UHF,623.143MHz,38ch
+UHF,629.143MHz,39ch
+UHF,635.143MHz,40ch
+UHF,641.143MHz,41ch
+UHF,647.143MHz,42ch
+UHF,653.143MHz,43ch
+UHF,659.143MHz,44ch
+UHF,665.143MHz,45ch
+UHF,671.143MHz,46ch
+UHF,677.143MHz,47ch
+UHF,683.143MHz,48ch
+UHF,689.143MHz,49ch
+UHF,695.143MHz,50ch
+UHF,701.143MHz,51ch
+UHF,707.143MHz,52ch
+UHF,713.143MHz,53ch
+UHF,719.143MHz,54ch
+UHF,725.143MHz,55ch
+UHF,731.143MHz,56ch
+UHF,737.143MHz,57ch
+UHF,743.143MHz,58ch
+UHF,749.143MHz,59ch
+UHF,755.143MHz,60ch
+UHF,761.143MHz,61ch
+UHF,767.143MHz,62ch
+
+  ; CATV
+
+CATV,111.143MHz,C13ch
+CATV,117.143MHz,C14ch
+CATV,123.143MHz,C15ch
+CATV,129.143MHz,C16ch
+CATV,135.143MHz,C17ch
+CATV,141.143MHz,C18ch
+CATV,147.143MHz,C19ch
+CATV,153.143MHz,C20ch
+CATV,159.143MHz,C21ch
+CATV,167.143MHz,C22ch
+CATV,225.143MHz,C23ch
+CATV,231.143MHz,C24ch
+CATV,237.143MHz,C25ch
+CATV,243.143MHz,C26ch
+CATV,249.143MHz,C27ch
+CATV,255.143MHz,C28ch
+CATV,261.143MHz,C29ch
+CATV,267.143MHz,C30ch
+CATV,273.143MHz,C31ch
+CATV,279.143MHz,C32ch
+CATV,285.143MHz,C33ch
+CATV,291.143MHz,C34ch
+CATV,297.143MHz,C35ch
+CATV,303.143MHz,C36ch
+CATV,309.143MHz,C37ch
+CATV,315.143MHz,C38ch
+CATV,321.143MHz,C39ch
+CATV,327.143MHz,C40ch
+CATV,333.143MHz,C41ch
+CATV,339.143MHz,C42ch
+CATV,345.143MHz,C43ch
+CATV,351.143MHz,C44ch
+CATV,357.143MHz,C45ch
+CATV,363.143MHz,C46ch
+CATV,369.143MHz,C47ch
+CATV,375.143MHz,C48ch
+CATV,381.143MHz,C49ch
+CATV,387.143MHz,C50ch
+CATV,393.143MHz,C51ch
+CATV,399.143MHz,C52ch
+CATV,405.143MHz,C53ch
+CATV,411.143MHz,C54ch
+CATV,417.143MHz,C55ch
+CATV,423.143MHz,C56ch
+CATV,429.143MHz,C57ch
+CATV,435.143MHz,C58ch
+CATV,441.143MHz,C59ch
+CATV,447.143MHz,C60ch
+CATV,453.143MHz,C61ch
+CATV,459.143MHz,C62ch
+CATV,465.143MHz,C63ch
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2N.ch.txt BonD_FSHybrid-20201009_mod2/sample/BonDriver_FSUSB2N.ch.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2N.ch.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/sample/BonDriver_FSUSB2N.ch.txt	2015-01-02 07:01:02.000000000 +0900
@@ -0,0 +1,135 @@
+; BonDriver_FSUSB2N p `lt@C (2015/1/2)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; Xy[X, `lԍorgMHz, `l
+
+  ; VHF
+
+VHF, 1, 1ch
+VHF, 2, 2ch
+VHF, 3, 3ch
+VHF, 4, 4ch
+VHF, 5, 5ch
+VHF, 6, 6ch
+VHF, 7, 7ch
+VHF, 8, 8ch
+VHF, 9, 9ch
+VHF,10,10ch
+VHF,11,11ch
+VHF,12,12ch
+
+  ; UHF
+
+UHF,13,13ch
+UHF,14,14ch
+UHF,15,15ch
+UHF,16,16ch
+UHF,17,17ch
+UHF,18,18ch
+UHF,19,19ch
+UHF,20,20ch
+UHF,21,21ch
+UHF,22,22ch
+UHF,23,23ch
+UHF,24,24ch
+UHF,25,25ch
+UHF,26,26ch
+UHF,27,27ch
+UHF,28,28ch
+UHF,29,29ch
+UHF,30,30ch
+UHF,31,31ch
+UHF,32,32ch
+UHF,33,33ch
+UHF,34,34ch
+UHF,35,35ch
+UHF,36,36ch
+UHF,37,37ch
+UHF,38,38ch
+UHF,39,39ch
+UHF,40,40ch
+UHF,41,41ch
+UHF,42,42ch
+UHF,43,43ch
+UHF,44,44ch
+UHF,45,45ch
+UHF,46,46ch
+UHF,47,47ch
+UHF,48,48ch
+UHF,49,49ch
+UHF,50,50ch
+UHF,51,51ch
+UHF,52,52ch
+UHF,53,53ch
+UHF,54,54ch
+UHF,55,55ch
+UHF,56,56ch
+UHF,57,57ch
+UHF,58,58ch
+UHF,59,59ch
+UHF,60,60ch
+UHF,61,61ch
+UHF,62,62ch
+
+  ; CATV
+
+CATV,113,C13ch
+CATV,114,C14ch
+CATV,115,C15ch
+CATV,116,C16ch
+CATV,117,C17ch
+CATV,118,C18ch
+CATV,119,C19ch
+CATV,120,C20ch
+CATV,121,C21ch
+CATV,122,C22ch
+CATV,123,C23ch
+CATV,124,C24ch
+CATV,125,C25ch
+CATV,126,C26ch
+CATV,127,C27ch
+CATV,128,C28ch
+CATV,129,C29ch
+CATV,130,C30ch
+CATV,131,C31ch
+CATV,132,C32ch
+CATV,133,C33ch
+CATV,134,C34ch
+CATV,135,C35ch
+CATV,136,C36ch
+CATV,137,C37ch
+CATV,138,C38ch
+CATV,139,C39ch
+CATV,140,C40ch
+CATV,141,C41ch
+CATV,142,C42ch
+CATV,143,C43ch
+CATV,144,C44ch
+CATV,145,C45ch
+CATV,146,C46ch
+CATV,147,C47ch
+CATV,148,C48ch
+CATV,149,C49ch
+CATV,150,C50ch
+CATV,151,C51ch
+CATV,152,C52ch
+CATV,153,C53ch
+CATV,154,C54ch
+CATV,155,C55ch
+CATV,156,C56ch
+CATV,157,C57ch
+CATV,158,C58ch
+CATV,159,C59ch
+CATV,160,C60ch
+CATV,161,C61ch
+CATV,162,C62ch
+CATV,163,C63ch
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2i.ch - MHz.txt BonD_FSHybrid-20201009_mod2/sample/BonDriver_FSUSB2i.ch - MHz.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2i.ch - MHz.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/sample/BonDriver_FSUSB2i.ch - MHz.txt	2018-02-07 00:16:20.000000000 +0900
@@ -0,0 +1,135 @@
+; BonDriver_FSUSB2i p `lt@CgMHz\LC (2018/2/7)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; Xy[X, `lԍorgMHz, `l
+
+  ; VHF
+
+;VHF, 93.143MHz, 1ch
+;VHF, 99.143MHz, 2ch
+;VHF,105.143MHz, 3ch
+;VHF,173.143MHz, 4ch
+;VHF,179.143MHz, 5ch
+;VHF,185.143MHz, 6ch
+;VHF,191.143MHz, 7ch
+;VHF,195.143MHz, 8ch
+;VHF,201.143MHz, 9ch
+;VHF,207.143MHz,10ch
+;VHF,213.143MHz,11ch
+;VHF,219.143MHz,12ch
+
+  ; UHF
+
+UHF,473.143MHz,13ch
+UHF,479.143MHz,14ch
+UHF,485.143MHz,15ch
+UHF,491.143MHz,16ch
+UHF,497.143MHz,17ch
+UHF,503.143MHz,18ch
+UHF,509.143MHz,19ch
+UHF,515.143MHz,20ch
+UHF,521.143MHz,21ch
+UHF,527.143MHz,22ch
+UHF,533.143MHz,23ch
+UHF,539.143MHz,24ch
+UHF,545.143MHz,25ch
+UHF,551.143MHz,26ch
+UHF,557.143MHz,27ch
+UHF,563.143MHz,28ch
+UHF,569.143MHz,29ch
+UHF,575.143MHz,30ch
+UHF,581.143MHz,31ch
+UHF,587.143MHz,32ch
+UHF,593.143MHz,33ch
+UHF,599.143MHz,34ch
+UHF,605.143MHz,35ch
+UHF,611.143MHz,36ch
+UHF,617.143MHz,37ch
+UHF,623.143MHz,38ch
+UHF,629.143MHz,39ch
+UHF,635.143MHz,40ch
+UHF,641.143MHz,41ch
+UHF,647.143MHz,42ch
+UHF,653.143MHz,43ch
+UHF,659.143MHz,44ch
+UHF,665.143MHz,45ch
+UHF,671.143MHz,46ch
+UHF,677.143MHz,47ch
+UHF,683.143MHz,48ch
+UHF,689.143MHz,49ch
+UHF,695.143MHz,50ch
+UHF,701.143MHz,51ch
+UHF,707.143MHz,52ch
+UHF,713.143MHz,53ch
+UHF,719.143MHz,54ch
+UHF,725.143MHz,55ch
+UHF,731.143MHz,56ch
+UHF,737.143MHz,57ch
+UHF,743.143MHz,58ch
+UHF,749.143MHz,59ch
+UHF,755.143MHz,60ch
+UHF,761.143MHz,61ch
+UHF,767.143MHz,62ch
+
+  ; CATV
+
+CATV,111.143MHz,C13ch
+CATV,117.143MHz,C14ch
+CATV,123.143MHz,C15ch
+CATV,129.143MHz,C16ch
+CATV,135.143MHz,C17ch
+CATV,141.143MHz,C18ch
+CATV,147.143MHz,C19ch
+CATV,153.143MHz,C20ch
+CATV,159.143MHz,C21ch
+CATV,167.143MHz,C22ch
+CATV,225.143MHz,C23ch
+CATV,231.143MHz,C24ch
+CATV,237.143MHz,C25ch
+CATV,243.143MHz,C26ch
+CATV,249.143MHz,C27ch
+CATV,255.143MHz,C28ch
+CATV,261.143MHz,C29ch
+CATV,267.143MHz,C30ch
+CATV,273.143MHz,C31ch
+CATV,279.143MHz,C32ch
+CATV,285.143MHz,C33ch
+CATV,291.143MHz,C34ch
+CATV,297.143MHz,C35ch
+CATV,303.143MHz,C36ch
+CATV,309.143MHz,C37ch
+CATV,315.143MHz,C38ch
+CATV,321.143MHz,C39ch
+CATV,327.143MHz,C40ch
+CATV,333.143MHz,C41ch
+CATV,339.143MHz,C42ch
+CATV,345.143MHz,C43ch
+CATV,351.143MHz,C44ch
+CATV,357.143MHz,C45ch
+CATV,363.143MHz,C46ch
+CATV,369.143MHz,C47ch
+CATV,375.143MHz,C48ch
+CATV,381.143MHz,C49ch
+CATV,387.143MHz,C50ch
+CATV,393.143MHz,C51ch
+CATV,399.143MHz,C52ch
+CATV,405.143MHz,C53ch
+CATV,411.143MHz,C54ch
+CATV,417.143MHz,C55ch
+CATV,423.143MHz,C56ch
+CATV,429.143MHz,C57ch
+CATV,435.143MHz,C58ch
+CATV,441.143MHz,C59ch
+CATV,447.143MHz,C60ch
+CATV,453.143MHz,C61ch
+CATV,459.143MHz,C62ch
+;CATV,465.143MHz,C63ch
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2i.ch.txt BonD_FSHybrid-20201009_mod2/sample/BonDriver_FSUSB2i.ch.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_FSUSB2i.ch.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/sample/BonDriver_FSUSB2i.ch.txt	2018-02-07 00:16:20.000000000 +0900
@@ -0,0 +1,135 @@
+; BonDriver_FSUSB2i p `lt@C (2018/2/7)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; Xy[X, `lԍorgMHz, `l
+
+  ; VHF
+
+;VHF, 1, 1ch
+;VHF, 2, 2ch
+;VHF, 3, 3ch
+;VHF, 4, 4ch
+;VHF, 5, 5ch
+;VHF, 6, 6ch
+;VHF, 7, 7ch
+;VHF, 8, 8ch
+;VHF, 9, 9ch
+;VHF,10,10ch
+;VHF,11,11ch
+;VHF,12,12ch
+
+  ; UHF
+
+UHF,13,13ch
+UHF,14,14ch
+UHF,15,15ch
+UHF,16,16ch
+UHF,17,17ch
+UHF,18,18ch
+UHF,19,19ch
+UHF,20,20ch
+UHF,21,21ch
+UHF,22,22ch
+UHF,23,23ch
+UHF,24,24ch
+UHF,25,25ch
+UHF,26,26ch
+UHF,27,27ch
+UHF,28,28ch
+UHF,29,29ch
+UHF,30,30ch
+UHF,31,31ch
+UHF,32,32ch
+UHF,33,33ch
+UHF,34,34ch
+UHF,35,35ch
+UHF,36,36ch
+UHF,37,37ch
+UHF,38,38ch
+UHF,39,39ch
+UHF,40,40ch
+UHF,41,41ch
+UHF,42,42ch
+UHF,43,43ch
+UHF,44,44ch
+UHF,45,45ch
+UHF,46,46ch
+UHF,47,47ch
+UHF,48,48ch
+UHF,49,49ch
+UHF,50,50ch
+UHF,51,51ch
+UHF,52,52ch
+UHF,53,53ch
+UHF,54,54ch
+UHF,55,55ch
+UHF,56,56ch
+UHF,57,57ch
+UHF,58,58ch
+UHF,59,59ch
+UHF,60,60ch
+UHF,61,61ch
+UHF,62,62ch
+
+  ; CATV
+
+CATV,113,C13ch
+CATV,114,C14ch
+CATV,115,C15ch
+CATV,116,C16ch
+CATV,117,C17ch
+CATV,118,C18ch
+CATV,119,C19ch
+CATV,120,C20ch
+CATV,121,C21ch
+CATV,122,C22ch
+CATV,123,C23ch
+CATV,124,C24ch
+CATV,125,C25ch
+CATV,126,C26ch
+CATV,127,C27ch
+CATV,128,C28ch
+CATV,129,C29ch
+CATV,130,C30ch
+CATV,131,C31ch
+CATV,132,C32ch
+CATV,133,C33ch
+CATV,134,C34ch
+CATV,135,C35ch
+CATV,136,C36ch
+CATV,137,C37ch
+CATV,138,C38ch
+CATV,139,C39ch
+CATV,140,C40ch
+CATV,141,C41ch
+CATV,142,C42ch
+CATV,143,C43ch
+CATV,144,C44ch
+CATV,145,C45ch
+CATV,146,C46ch
+CATV,147,C47ch
+CATV,148,C48ch
+CATV,149,C49ch
+CATV,150,C50ch
+CATV,151,C51ch
+CATV,152,C52ch
+CATV,153,C53ch
+CATV,154,C54ch
+CATV,155,C55ch
+CATV,156,C56ch
+CATV,157,C57ch
+CATV,158,C58ch
+CATV,159,C59ch
+CATV,160,C60ch
+CATV,161,C61ch
+CATV,162,C62ch
+;CATV,163,C63ch
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch - BSAlmighty.txt BonD_FSHybrid-20201009_mod2/sample/BonDriver_uSUNpTV.ch - BSAlmighty.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch - BSAlmighty.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/sample/BonDriver_uSUNpTV.ch - BSAlmighty.txt	2019-12-19 15:10:24.000000000 +0900
@@ -0,0 +1,199 @@
+; BonDriver_uSUNpTV p `lt@CarI[}CeB (2019/12/21)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; `lԍ̕\L@F
+;
+;   1`63               : nfW(VHF/UHFш)̕`l
+;   C13`C63            : CATVpXX[(UHFш)̕`l
+;   BS[1`23]/TS[0`7]  : BS̕`l(`lԍ/Xg[ԍ)
+;   BS[1`23]/ID[]  : BS̕`l(`lԍ/Xg[hc)
+;   ND[2`24]			: CS̕`l(`lԍ)
+;
+;     TS[0`7]AID[] ͏ȗB
+;
+; Xy[X, `lԍorgMHz[, `l(Ă)]
+
+  ; VHF
+
+;VHF, 1
+;VHF, 2
+;VHF, 3
+;VHF, 4
+;VHF, 5
+;VHF, 6
+;VHF, 7
+;VHF, 8
+;VHF, 9
+;VHF,10
+;VHF,11
+;VHF,12
+
+  ; UHF
+
+UHF,13
+UHF,14
+UHF,15
+UHF,16
+UHF,17
+UHF,18
+UHF,19
+UHF,20
+UHF,21
+UHF,22
+UHF,23
+UHF,24
+UHF,25
+UHF,26
+UHF,27
+UHF,28
+UHF,29
+UHF,30
+UHF,31
+UHF,32
+UHF,33
+UHF,34
+UHF,35
+UHF,36
+UHF,37
+UHF,38
+UHF,39
+UHF,40
+UHF,41
+UHF,42
+UHF,43
+UHF,44
+UHF,45
+UHF,46
+UHF,47
+UHF,48
+UHF,49
+UHF,50
+UHF,51
+UHF,52
+UHF,53
+UHF,54
+UHF,55
+UHF,56
+UHF,57
+UHF,58
+UHF,59
+UHF,60
+UHF,61
+UHF,62
+
+  ; CATV
+
+CATV,C13
+CATV,C14
+CATV,C15
+CATV,C16
+CATV,C17
+CATV,C18
+CATV,C19
+CATV,C20
+CATV,C21
+CATV,C22
+CATV,C23
+CATV,C24
+CATV,C25
+CATV,C26
+CATV,C27
+CATV,C28
+CATV,C29
+CATV,C30
+CATV,C31
+CATV,C32
+CATV,C33
+CATV,C34
+CATV,C35
+CATV,C36
+CATV,C37
+CATV,C38
+CATV,C39
+CATV,C40
+CATV,C41
+CATV,C42
+CATV,C43
+CATV,C44
+CATV,C45
+CATV,C46
+CATV,C47
+CATV,C48
+CATV,C49
+CATV,C50
+CATV,C51
+CATV,C52
+CATV,C53
+CATV,C54
+CATV,C55
+CATV,C56
+CATV,C57
+CATV,C58
+CATV,C59
+CATV,C60
+CATV,C61
+CATV,C62
+;CATV,C63
+
+  ; BS ( TS0`TS2 ׂ̂Ẳ\ɑΉ )
+
+BS, BS01/TS0
+BS, BS01/TS1
+BS, BS01/TS2
+BS, BS03/TS0
+BS, BS03/TS1
+BS, BS03/TS2
+BS, BS05/TS0
+BS, BS05/TS1
+BS, BS05/TS2
+BS, BS07/TS0
+BS, BS07/TS1
+BS, BS07/TS2
+BS, BS09/TS0
+BS, BS09/TS1
+BS, BS09/TS2
+BS, BS11/TS0
+BS, BS11/TS1
+BS, BS11/TS2
+BS, BS13/TS0
+BS, BS13/TS1
+BS, BS13/TS2
+BS, BS15/TS0
+BS, BS15/TS1
+BS, BS15/TS2
+BS, BS17/TS0
+BS, BS17/TS1
+BS, BS17/TS2
+BS, BS19/TS0
+BS, BS19/TS1
+BS, BS19/TS2
+BS, BS21/TS0
+BS, BS21/TS1
+BS, BS21/TS2
+BS, BS23/TS0
+BS, BS23/TS1
+BS, BS23/TS2
+
+  ; CS110
+
+CS110, ND2
+CS110, ND4
+CS110, ND6
+CS110, ND8
+CS110, ND10
+CS110, ND12
+CS110, ND14
+CS110, ND16
+CS110, ND18
+CS110, ND20
+CS110, ND22
+CS110, ND24
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch - MHz.txt BonD_FSHybrid-20201009_mod2/sample/BonDriver_uSUNpTV.ch - MHz.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch - MHz.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/sample/BonDriver_uSUNpTV.ch - MHz.txt	2020-01-03 02:40:12.000000000 +0900
@@ -0,0 +1,199 @@
+; BonDriver_uSUNpTV p `lt@CgMHz\L (2020/1/3)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; `lԍ̕\L@F
+;
+;   1`63               : nfW(VHF/UHFш)̕`l
+;   C13`C63            : CATVpXX[(UHFш)̕`l
+;   BS[1`23]/TS[0`7]  : BS̕`l(`lԍ/Xg[ԍ)
+;   BS[1`23]/ID[]  : BS̕`l(`lԍ/Xg[hc)
+;   ND[2`24]			: CS̕`l(`lԍ)
+;
+;     TS[0`7]AID[] ͏ȗB
+;
+; Xy[X, `lԍorgMHz[, `l(Ă)]
+
+  ; VHF
+
+;VHF, 93.143MHz, 1ch
+;VHF, 99.143MHz, 2ch
+;VHF,105.143MHz, 3ch
+;VHF,173.143MHz, 4ch
+;VHF,179.143MHz, 5ch
+;VHF,185.143MHz, 6ch
+;VHF,191.143MHz, 7ch
+;VHF,195.143MHz, 8ch
+;VHF,201.143MHz, 9ch
+;VHF,207.143MHz,10ch
+;VHF,213.143MHz,11ch
+;VHF,219.143MHz,12ch
+
+  ; UHF
+
+UHF,473.143MHz,13ch
+UHF,479.143MHz,14ch
+UHF,485.143MHz,15ch
+UHF,491.143MHz,16ch
+UHF,497.143MHz,17ch
+UHF,503.143MHz,18ch
+UHF,509.143MHz,19ch
+UHF,515.143MHz,20ch
+UHF,521.143MHz,21ch
+UHF,527.143MHz,22ch
+UHF,533.143MHz,23ch
+UHF,539.143MHz,24ch
+UHF,545.143MHz,25ch
+UHF,551.143MHz,26ch
+UHF,557.143MHz,27ch
+UHF,563.143MHz,28ch
+UHF,569.143MHz,29ch
+UHF,575.143MHz,30ch
+UHF,581.143MHz,31ch
+UHF,587.143MHz,32ch
+UHF,593.143MHz,33ch
+UHF,599.143MHz,34ch
+UHF,605.143MHz,35ch
+UHF,611.143MHz,36ch
+UHF,617.143MHz,37ch
+UHF,623.143MHz,38ch
+UHF,629.143MHz,39ch
+UHF,635.143MHz,40ch
+UHF,641.143MHz,41ch
+UHF,647.143MHz,42ch
+UHF,653.143MHz,43ch
+UHF,659.143MHz,44ch
+UHF,665.143MHz,45ch
+UHF,671.143MHz,46ch
+UHF,677.143MHz,47ch
+UHF,683.143MHz,48ch
+UHF,689.143MHz,49ch
+UHF,695.143MHz,50ch
+UHF,701.143MHz,51ch
+UHF,707.143MHz,52ch
+UHF,713.143MHz,53ch
+UHF,719.143MHz,54ch
+UHF,725.143MHz,55ch
+UHF,731.143MHz,56ch
+UHF,737.143MHz,57ch
+UHF,743.143MHz,58ch
+UHF,749.143MHz,59ch
+UHF,755.143MHz,60ch
+UHF,761.143MHz,61ch
+UHF,767.143MHz,62ch
+
+  ; CATV
+
+CATV,111.143MHz,C13ch
+CATV,117.143MHz,C14ch
+CATV,123.143MHz,C15ch
+CATV,129.143MHz,C16ch
+CATV,135.143MHz,C17ch
+CATV,141.143MHz,C18ch
+CATV,147.143MHz,C19ch
+CATV,153.143MHz,C20ch
+CATV,159.143MHz,C21ch
+CATV,167.143MHz,C22ch ; C22
+CATV,225.143MHz,C23ch
+CATV,231.143MHz,C24ch
+CATV,237.143MHz,C25ch
+CATV,243.143MHz,C26ch
+CATV,249.143MHz,C27ch
+CATV,255.143MHz,C28ch
+CATV,261.143MHz,C29ch
+CATV,267.143MHz,C30ch
+CATV,273.143MHz,C31ch
+CATV,279.143MHz,C32ch
+CATV,285.143MHz,C33ch
+CATV,291.143MHz,C34ch
+CATV,297.143MHz,C35ch
+CATV,303.143MHz,C36ch
+CATV,309.143MHz,C37ch
+CATV,315.143MHz,C38ch
+CATV,321.143MHz,C39ch
+CATV,327.143MHz,C40ch
+CATV,333.143MHz,C41ch
+CATV,339.143MHz,C42ch
+CATV,345.143MHz,C43ch
+CATV,351.143MHz,C44ch
+CATV,357.143MHz,C45ch
+CATV,363.143MHz,C46ch
+CATV,369.143MHz,C47ch
+CATV,375.143MHz,C48ch
+CATV,381.143MHz,C49ch
+CATV,387.143MHz,C50ch
+CATV,393.143MHz,C51ch
+CATV,399.143MHz,C52ch
+CATV,405.143MHz,C53ch
+CATV,411.143MHz,C54ch
+CATV,417.143MHz,C55ch
+CATV,423.143MHz,C56ch
+CATV,429.143MHz,C57ch
+CATV,435.143MHz,C58ch
+CATV,441.143MHz,C59ch
+CATV,447.143MHz,C60ch
+CATV,453.143MHz,C61ch
+CATV,459.143MHz,C62ch
+;CATV,465.143MHz,C63ch
+
+  ; BS
+
+BS, 1049.48MHz/TS0, BS01/TS0 ;arP
+BS, 1049.48MHz/TS1, BS01/TS1 ;ar|sar
+BS, 1049.48MHz/TS2, BS01/TS2 ;arWp
+BS, 1087.84MHz/TS0, BS03/TS0 ;vnvnvvC
+BS, 1087.84MHz/TS1, BS03/TS1 ;mgjarv~A
+BS, 1087.84MHz/TS2, BS03/TS2 ;fBYj[`l
+BS, 1126.20MHz/TS0, BS05/TS0 ;vnvnvCu
+BS, 1126.20MHz/TS1, BS05/TS1 ;vnvnvVl}
+;BS, 1164.56MHz/TS0, BS07/TS0
+;BS, 1164.56MHz/TS1, BS07/TS1
+;BS, 1164.56MHz/TS2, BS07/TS2
+BS, 1202.92MHz/TS0, BS09/TS0 ;arPPCu
+BS, 1202.92MHz/TS1, BS09/TS1 ;X^[`lP
+BS, 1202.92MHz/TS2, BS09/TS2 ;arPQgDGr
+BS, 1241.28MHz/TS0, BS11/TS0 ;enwX|[cG^
+BS, 1241.28MHz/TS1, BS11/TS1 ;arXJp[I
+BS, 1241.28MHz/TS2, BS11/TS2 ;warP
+BS, 1279.64MHz/TS0, BS13/TS0 ;are
+BS, 1279.64MHz/TS1, BS13/TS1 ;artWEPWP
+BS, 1279.64MHz/TS2, BS13/TS2 ;arAj}bNX
+;BS, 1318.00MHz/ID0x40F1, BS15/TS1 ;mgjarP
+;BS, 1318.00MHz/ID0x40F2, BS15/TS2 ;X^[`lQ^X^[`lR
+BS, 1318.00MHz/TS1, BS15/TS1 ;mgjarP
+BS, 1318.00MHz/TS2, BS15/TS2 ;X^[`lQ^X^[`lR
+;BS, 1356.36MHz/TS0, BS17/TS0
+;BS, 1356.36MHz/TS1, BS17/TS1
+;BS, 1356.36MHz/TS2, BS17/TS2
+BS, 1394.72MHz/TS0, BS19/TS0 ;O[`l
+BS, 1394.72MHz/TS1, BS19/TS1 ;i@ronqsr@P
+BS, 1394.72MHz/TS2, BS19/TS2 ;i@ronqsr@Q
+BS, 1433.08MHz/TS0, BS21/TS0 ;VltBvnvnv
+BS, 1433.08MHz/TS1, BS21/TS1 ;i@ronqsr@R
+BS, 1433.08MHz/TS2, BS21/TS2 ;i@ronqsr@S
+BS, 1471.44MHz/TS0, BS23/TS0 ;arނrW
+BS, 1471.44MHz/TS1, BS23/TS1 ;{f傃
+BS, 1471.44MHz/TS2, BS23/TS2 ;fB[Ct
+
+  ; CS110
+
+CS110, 1613.0MHz, ND2
+CS110, 1653.0MHz, ND4
+CS110, 1693.0MHz, ND6
+CS110, 1733.0MHz, ND8
+CS110, 1773.0MHz, ND10
+CS110, 1813.0MHz, ND12
+CS110, 1853.0MHz, ND14
+CS110, 1893.0MHz, ND16
+CS110, 1933.0MHz, ND18
+CS110, 1973.0MHz, ND20
+CS110, 2013.0MHz, ND22
+CS110, 2053.0MHz, ND24
+
diff -uPr BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch.txt BonD_FSHybrid-20201009_mod2/sample/BonDriver_uSUNpTV.ch.txt
--- BonD_FSHybrid-20201009_org/sample/BonDriver_uSUNpTV.ch.txt	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/sample/BonDriver_uSUNpTV.ch.txt	2020-01-03 02:40:12.000000000 +0900
@@ -0,0 +1,199 @@
+; BonDriver_uSUNpTV p `lt@CȈՕ\L (2020/1/3)
+;
+;       `lύXꍇ́Ãt@CҏW
+;       vtBbNXÕhCoƓfBNg
+;       gq .ch.txt ƂẴt@CuƁB
+;
+;  ̃t@C𗘗pꍇ́AK`lXLĉB
+;  Xy[X̏Ԃ̓ubNƃJbgy[Xgēւ邱Ƃł܂B
+;    iCATV̋Lq̓rVHF}(~bNX)邱Ƃ͂ł܂Bj
+;  pȂXy[X͊ۂƖ邩RgAEgĂB
+;
+; `lԍ̕\L@F
+;
+;   1`63               : nfW(VHF/UHFш)̕`l
+;   C13`C63            : CATVpXX[(UHFш)̕`l
+;   BS[1`23]/TS[0`7]  : BS̕`l(`lԍ/Xg[ԍ)
+;   BS[1`23]/ID[]  : BS̕`l(`lԍ/Xg[hc)
+;   ND[2`24]			: CS̕`l(`lԍ)
+;
+;     TS[0`7]AID[] ͏ȗB
+;
+; Xy[X, `lԍorgMHz[, `l(Ă)]
+
+  ; VHF
+
+;VHF, 1
+;VHF, 2
+;VHF, 3
+;VHF, 4
+;VHF, 5
+;VHF, 6
+;VHF, 7
+;VHF, 8
+;VHF, 9
+;VHF,10
+;VHF,11
+;VHF,12
+
+  ; UHF
+
+UHF,13
+UHF,14
+UHF,15
+UHF,16
+UHF,17
+UHF,18
+UHF,19
+UHF,20
+UHF,21
+UHF,22
+UHF,23
+UHF,24
+UHF,25
+UHF,26
+UHF,27
+UHF,28
+UHF,29
+UHF,30
+UHF,31
+UHF,32
+UHF,33
+UHF,34
+UHF,35
+UHF,36
+UHF,37
+UHF,38
+UHF,39
+UHF,40
+UHF,41
+UHF,42
+UHF,43
+UHF,44
+UHF,45
+UHF,46
+UHF,47
+UHF,48
+UHF,49
+UHF,50
+UHF,51
+UHF,52
+UHF,53
+UHF,54
+UHF,55
+UHF,56
+UHF,57
+UHF,58
+UHF,59
+UHF,60
+UHF,61
+UHF,62
+
+  ; CATV
+
+CATV,C13
+CATV,C14
+CATV,C15
+CATV,C16
+CATV,C17
+CATV,C18
+CATV,C19
+CATV,C20
+CATV,C21
+CATV,C22
+CATV,C23
+CATV,C24
+CATV,C25
+CATV,C26
+CATV,C27
+CATV,C28
+CATV,C29
+CATV,C30
+CATV,C31
+CATV,C32
+CATV,C33
+CATV,C34
+CATV,C35
+CATV,C36
+CATV,C37
+CATV,C38
+CATV,C39
+CATV,C40
+CATV,C41
+CATV,C42
+CATV,C43
+CATV,C44
+CATV,C45
+CATV,C46
+CATV,C47
+CATV,C48
+CATV,C49
+CATV,C50
+CATV,C51
+CATV,C52
+CATV,C53
+CATV,C54
+CATV,C55
+CATV,C56
+CATV,C57
+CATV,C58
+CATV,C59
+CATV,C60
+CATV,C61
+CATV,C62
+;CATV,C63
+
+  ; BS
+
+BS, BS01/TS0 ;arP
+BS, BS01/TS1 ;ar|sar
+BS, BS01/TS2 ;are
+BS, BS03/TS0 ;vnvnvvC
+BS, BS03/TS1 ;mgjarv~A
+BS, BS03/TS2 ;fBYj[`l
+BS, BS05/TS0 ;vnvnvCu
+BS, BS05/TS1 ;vnvnvVl}
+;BS, BS07/TS0
+;BS, BS07/TS1
+;BS, BS07/TS2
+BS, BS09/TS0 ;arPPCu
+BS, BS09/TS1 ;X^[`lP
+BS, BS09/TS2 ;arPQgDGr
+BS, BS11/TS0 ;enwX|[cG^
+BS, BS11/TS1 ;arXJp[I
+BS, BS11/TS2 ;warP
+BS, BS13/TS0 ;are
+BS, BS13/TS1 ;artWEPWP
+BS, BS13/TS2 ;arAj}bNX
+;BS, BS15/ID16625, BS15/TS1 ;mgjarP
+;BS, BS15/ID16626, BS15/TS2 ;X^[`lQ^X^[`lR
+BS, BS15/TS1 ;mgjarP
+BS, BS15/TS2 ;X^[`lQ^X^[`lR
+;BS, BS17/TS0
+;BS, BS17/TS1
+;BS, BS17/TS2
+BS, BS19/TS0 ;O[`l
+BS, BS19/TS1 ;i@ronqsr@P
+BS, BS19/TS2 ;i@ronqsr@Q
+BS, BS21/TS0 ;VltBvnvnv
+BS, BS21/TS1 ;i@ronqsr@R
+BS, BS21/TS2 ;i@ronqsr@S
+BS, BS23/TS0 ;arނrW
+BS, BS23/TS1 ;{f傃
+BS, BS23/TS2 ;fB[Ct
+
+  ; CS110
+
+CS110, ND2
+CS110, ND4
+CS110, ND6
+CS110, ND8
+CS110, ND10
+CS110, ND12
+CS110, ND14
+CS110, ND16
+CS110, ND18
+CS110, ND20
+CS110, ND22
+CS110, ND24
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver.rc BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/BonDriver.rc
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver.rc	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/BonDriver.rc	2020-10-12 00:45:18.000000000 +0900
@@ -0,0 +1,42 @@
+#include <windows.h>
+
+LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT
+1 VERSIONINFO
+ FILEVERSION 0,2020,10,12
+ PRODUCTVERSION 0,2020,10,12
+ FILEFLAGSMASK 0x17L
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS VOS_NT
+ FILETYPE VFT_DLL
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "041104b0"
+        BEGIN
+            VALUE "CompanyName", "hyrolean-dtv inspired by trinity19683"
+            VALUE "FileVersion", "0,2020,10,12"
+#ifdef INCLUDE_ISOCH_XFER
+            VALUE "FileDescription", "Hybrid BonDriver for FSUSB2N/FSUSB2i/uSUNpTV (isoch support)"
+            VALUE "InternalName", "BonDriver_FSHybrid_isoch.dll"
+            VALUE "OriginalFilename", "BonDriver_FSHybrid_isoch.dll"
+            VALUE "ProductName", "BonDriver_FSHybrid_isoch"
+#else
+            VALUE "FileDescription", "Hybrid BonDriver for FSUSB2N/FSUSB2i/uSUNpTV"
+            VALUE "InternalName", "BonDriver_FSHybrid.dll"
+            VALUE "OriginalFilename", "BonDriver_FSHybrid.dll"
+            VALUE "ProductName", "BonDriver_FSHybrid"
+#endif
+            VALUE "LegalCopyright", "hyrolean-dtv 2019-2020 inspired by trinity19683 2015-2016"
+            VALUE "ProductVersion", "0,2020,10,12"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x411, 1200
+    END
+END
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcproj BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcproj	2020-10-02 05:27:44.000000000 +0900
@@ -0,0 +1,1261 @@
+<?xml version="1.0" encoding="shift_jis"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="BonDriver_FSHybrid"
+	ProjectGUID="{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}"
+	RootNamespace="BonDriver_FSHybrid"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="196613"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSHybrid.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSHybrid_x64.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSHybrid.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSHybrid_x64.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="\[X t@C"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\bonhybrid.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\dllmain.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\em2874.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\em287x.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\em287x_usb.c"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\it9175_usb.c"
+				>
+			</File>
+			<File
+				RelativePath="..\ktv.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\message.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\mxl136.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\osdepend.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\pryutil.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx2.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tc90522.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tda20142.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tsthread.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbops.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="wb_[ t@C"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\bonhybrid.h"
+				>
+			</File>
+			<File
+				RelativePath="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.h"
+				>
+			</File>
+			<File
+				RelativePath="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.h"
+				>
+			</File>
+			<File
+				RelativePath="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em2874.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x_priv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x_usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_fw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_priv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\ktv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\message.h"
+				>
+			</File>
+			<File
+				RelativePath="..\mxl136.h"
+				>
+			</File>
+			<File
+				RelativePath="..\osdepend.h"
+				>
+			</File>
+			<File
+				RelativePath="..\pryutil.h"
+				>
+			</File>
+			<File
+				RelativePath=".\resource.h"
+				>
+			</File>
+			<File
+				RelativePath=".\stdafx.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\stdint_.h"
+				>
+			</File>
+			<File
+				RelativePath="..\targetver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tc90522.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tda20142.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsbuff.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsthread.h"
+				>
+			</File>
+			<File
+				RelativePath="..\twindbg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\types_u.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb100.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb200.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbops.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusbio.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="\[X t@C"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\BonDriver.rc"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcxproj BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcxproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/BonDriver_FSHybrid.vcxproj	2020-10-02 04:54:58.000000000 +0900
@@ -0,0 +1,263 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>FSHybrid</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
+    <UseDebugLibraries>true</UseDebugLibraries>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'" Label="Configuration">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <EmbedManifest>false</EmbedManifest>
+    <IncludePath>..\inc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='Win32'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.h" />
+    <ClInclude Include="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.h" />
+    <ClInclude Include="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.h" />
+    <ClInclude Include="..\bonhybrid.h" />
+    <ClInclude Include="..\em2874.h" />
+    <ClInclude Include="..\em287x.h" />
+    <ClInclude Include="..\em287x_priv.h" />
+    <ClInclude Include="..\em287x_usb.h" />
+    <ClInclude Include="..\it9175.h" />
+    <ClInclude Include="..\it9175_fw.h" />
+    <ClInclude Include="..\it9175_priv.h" />
+    <ClInclude Include="..\it9175_usb.h" />
+    <ClInclude Include="..\ktv.h" />
+    <ClInclude Include="..\message.h" />
+    <ClInclude Include="..\mxl136.h" />
+    <ClInclude Include="..\targetver.h" />
+    <ClInclude Include="..\osdepend.h" />
+    <ClInclude Include="..\tc90522.h" />
+    <ClInclude Include="..\tda20142.h" />
+    <ClInclude Include="..\tsbuff.h" />
+    <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
+    <ClInclude Include="..\types_u.h" />
+    <ClInclude Include="..\usbdevfile.h" />
+    <ClInclude Include="..\usbops.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="stdafx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\em2874.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\em287x.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\em287x_usb.c" />
+    <ClCompile Include="..\it9175.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\it9175_usb.c" />
+    <ClCompile Include="..\ktv.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\message.c" />
+    <ClCompile Include="..\mxl136.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c" />
+    <ClCompile Include="..\tc90522.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tda20142.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tsthread.c" />
+    <ClCompile Include="..\usbdevfile.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\usbops.c" />
+    <ClCompile Include="dllmain.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="stdafx.c">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="stdafx2.cpp">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid_isoch.vcxproj BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/BonDriver_FSHybrid_isoch.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/BonDriver_FSHybrid_isoch.vcxproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/BonDriver_FSHybrid_isoch.vcxproj	2020-10-11 01:47:28.000000000 +0900
@@ -0,0 +1,275 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{58814608-686F-46B4-9061-B647F45A1151}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>FSHybrid</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
+    <UseDebugLibraries>true</UseDebugLibraries>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'" Label="Configuration">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <EmbedManifest>false</EmbedManifest>
+    <IncludePath>..\inc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='Win32'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.h" />
+    <ClInclude Include="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.h" />
+    <ClInclude Include="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.h" />
+    <ClInclude Include="..\bonhybrid.h" />
+    <ClInclude Include="..\em2874.h" />
+    <ClInclude Include="..\em287x.h" />
+    <ClInclude Include="..\em287x_priv.h" />
+    <ClInclude Include="..\em287x_usb.h" />
+    <ClInclude Include="..\it9175.h" />
+    <ClInclude Include="..\it9175_fw.h" />
+    <ClInclude Include="..\it9175_priv.h" />
+    <ClInclude Include="..\it9175_usb.h" />
+    <ClInclude Include="..\ktv.h" />
+    <ClInclude Include="..\message.h" />
+    <ClInclude Include="..\mxl136.h" />
+    <ClInclude Include="..\targetver.h" />
+    <ClInclude Include="..\osdepend.h" />
+    <ClInclude Include="..\tc90522.h" />
+    <ClInclude Include="..\tda20142.h" />
+    <ClInclude Include="..\tsbuff.h" />
+    <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
+    <ClInclude Include="..\types_u.h" />
+    <ClInclude Include="..\usbdevfile.h" />
+    <ClInclude Include="..\usbops.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="stdafx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\BonDriver_FSUSB2i\BonTuner_FSUSB2i.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\BonDriver_FSUSB2N\BonTuner_FSUSB2N.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\BonDriver_uSUNpTV\BonTuner_uSUNpTV.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\em2874.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\em287x.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\em287x_usb.c" />
+    <ClCompile Include="..\it9175.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\it9175_usb.c" />
+    <ClCompile Include="..\ktv.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\message.c" />
+    <ClCompile Include="..\mxl136.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c" />
+    <ClCompile Include="..\tc90522.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tda20142.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tsthread.c" />
+    <ClCompile Include="..\usbdevfile.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\usbops.c" />
+    <ClCompile Include="dllmain.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="stdafx.c">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="stdafx2.cpp">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/dllmain.cpp BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/dllmain.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/dllmain.cpp	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/dllmain.cpp	2020-01-07 03:24:36.000000000 +0900
@@ -0,0 +1,68 @@
+//# 2020-1-3
+//#   BonDriver_FSUSB2N.dll / BonDriver_FSUSB2i.dll / BonDriver_uSUNpTV.dll
+//#   Hybrid dll entry point.
+//# Coded by 2019-2020 LVhJPic0JSk5LiQ1ITskKVk9UGBg
+#include "stdafx.h"
+#include <cstring>
+#include <string>
+#include "IBonDriver2.h"
+#include "../BonDriver_FSUSB2N/BonTuner_FSUSB2N.h"
+#include "../BonDriver_FSUSB2i/BonTuner_FSUSB2i.h"
+#include "../BonDriver_uSUNpTV/BonTuner_uSUNpTV.h"
+#include "../pryutil.h"
+
+using namespace std ;
+
+enum BONDRIVER_FSHYBRID {
+	BONDRIVER_UNKNOWN,
+	BONDRIVER_FSUSB2N,
+	BONDRIVER_FSUSB2I,
+	BONDRIVER_USUNPTV,
+};
+
+BONDRIVER_FSHYBRID FSHybrid = BONDRIVER_UNKNOWN;
+
+void FSIdentify(HMODULE hModule)
+{
+	char path[_MAX_PATH] ;
+	GetModuleFileNameA( hModule, path, _MAX_PATH ) ;
+	std::string prefix = upper_case(file_prefix_of(path)) ;
+	#define IDENTIFY(name) do { \
+		if(prefix.substr(0,strlen(#name))==string(#name)) \
+		{FSHybrid=name;return;} } while(0)
+	IDENTIFY(BONDRIVER_FSUSB2N) ;
+	IDENTIFY(BONDRIVER_FSUSB2I) ;
+	IDENTIFY(BONDRIVER_USUNPTV) ;
+	#undef IDENTIFY
+	FSHybrid = BONDRIVER_UNKNOWN;
+}
+
+BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )
+{
+	switch (ul_reason_for_call) {
+	case DLL_PROCESS_ATTACH:
+		FSIdentify(hModule) ;
+		CBonFSHybrid::m_hModule = hModule;
+		break;
+	case DLL_PROCESS_DETACH:
+		if(CBonFSHybrid::m_pThis)CBonFSHybrid::m_pThis->Release();
+		break;
+	}
+	return TRUE;
+}
+
+#pragma warning( disable : 4273 )
+extern "C" __declspec(dllexport) IBonDriver *CreateBonDriver()
+{
+	switch(FSHybrid) {
+		case BONDRIVER_FSUSB2N:
+			return BonFSCreate<FSUSB2N::CBonTuner>();
+		case BONDRIVER_FSUSB2I:
+			return BonFSCreate<FSUSB2i::CBonTuner>();
+		case BONDRIVER_USUNPTV:
+			return BonFSCreate<uSUNpTV::CBonTuner>();
+	}
+	return NULL ;
+}
+#pragma warning( default : 4273 )
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx.c BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/stdafx.c
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx.c	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/stdafx.c	2015-12-09 05:03:22.000000000 +0900
@@ -0,0 +1 @@
+#include "stdafx.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx.h BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/stdafx.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/stdafx.h	2019-12-20 15:14:54.000000000 +0900
@@ -0,0 +1,10 @@
+#pragma once
+#include "../targetver.h"
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <tchar.h>
+#include <process.h>
+
+#include "../message.h"
+
+#include "../twindbg.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx2.cpp BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/stdafx2.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSHybrid/stdafx2.cpp	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSHybrid/stdafx2.cpp	2015-12-10 03:50:18.000000000 +0900
@@ -0,0 +1 @@
+#include "stdafx.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver.rc BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonDriver.rc
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver.rc	2012-09-29 04:42:03.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonDriver.rc	2020-10-12 00:45:18.000000000 +0900
@@ -4,8 +4,8 @@
 
 LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT
 1 VERSIONINFO
- FILEVERSION 1,0,1,3
- PRODUCTVERSION 1,0,1,3
+ FILEVERSION 0,2020,10,12
+ PRODUCTVERSION 0,2020,10,12
  FILEFLAGSMASK 0x17L
 #ifdef _DEBUG
  FILEFLAGS 0x1L
@@ -20,14 +20,21 @@
     BEGIN
         BLOCK "041104b0"
         BEGIN
-            VALUE "CompanyName", "WPjeGg6tSA"
+            VALUE "CompanyName", "hyrolean-dtv inspired by WPjeGg6tSA"
+            VALUE "FileVersion", "0,2020,10,12"
+#ifdef INCLUDE_ISOCH_XFER
+            VALUE "FileDescription", "BonDriver for FSUSB2N (isoch support)"
+            VALUE "InternalName", "BonDriver_FSUSB2N_isoch.dll"
+            VALUE "OriginalFilename", "BonDriver_FSUSB2N_isoch.dll"
+            VALUE "ProductName", "BonDriver_FSUSB2N_isoch"
+#else
             VALUE "FileDescription", "BonDriver for FSUSB2N"
-            VALUE "FileVersion", "1,0,1,3"
             VALUE "InternalName", "BonDriver_FSUSB2N.dll"
-            VALUE "LegalCopyright", "WPjeGg6tSA 2009-2012"
             VALUE "OriginalFilename", "BonDriver_FSUSB2N.dll"
             VALUE "ProductName", "BonDriver_FSUSB2N"
-            VALUE "ProductVersion", "1,0,1,3"
+#endif
+            VALUE "LegalCopyright", "hyrolean-dtv 2014-2020 inspired by WPjeGg6tSA 2009-2012"
+            VALUE "ProductVersion", "0,2020,10,12"
         END
     END
     BLOCK "VarFileInfo"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcproj BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcproj	2012-09-28 02:45:21.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcproj	2020-10-02 05:27:42.000000000 +0900
@@ -2,9 +2,9 @@
 <VisualStudioProject
 	ProjectType="Visual C++"
 	Version="9.00"
-	Name="BonDriver"
+	Name="BonDriver_FSUSB2N"
 	ProjectGUID="{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}"
-	RootNamespace="BonDriver"
+	RootNamespace="BonDriver_FSUSB2N"
 	Keyword="Win32Proj"
 	TargetFrameworkVersion="196613"
 	>
@@ -12,14 +12,17 @@
 		<Platform
 			Name="Win32"
 		/>
+		<Platform
+			Name="x64"
+		/>
 	</Platforms>
 	<ToolFiles>
 	</ToolFiles>
 	<Configurations>
 		<Configuration
 			Name="Debug|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
 			ConfigurationType="2"
 			CharacterSet="1"
 			>
@@ -41,7 +44,7 @@
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="0"
-				AdditionalIncludeDirectories="../inc"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
 				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS"
 				MinimalRebuild="true"
 				BasicRuntimeChecks="3"
@@ -92,9 +95,85 @@
 			/>
 		</Configuration>
 		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2N_x64.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
 			Name="Release|Win32"
-			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
-			IntermediateDirectory="$(ConfigurationName)"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
 			ConfigurationType="2"
 			CharacterSet="1"
 			WholeProgramOptimization="1"
@@ -118,7 +197,7 @@
 				Name="VCCLCompilerTool"
 				Optimization="2"
 				EnableIntrinsicFunctions="true"
-				AdditionalIncludeDirectories="../inc"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
 				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS"
 				RuntimeLibrary="2"
 				BufferSecurityCheck="false"
@@ -170,6 +249,86 @@
 				Name="VCPostBuildEventTool"
 			/>
 		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2N_x64.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
 	</Configurations>
 	<References>
 	</References>
@@ -180,7 +339,11 @@
 			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
 			>
 			<File
-				RelativePath=".\BonTuner.cpp"
+				RelativePath="..\bonhybrid.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\BonTuner_FSUSB2N.cpp"
 				>
 			</File>
 			<File
@@ -196,6 +359,15 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
 					Name="Release|Win32"
 					>
 					<Tool
@@ -204,6 +376,15 @@
 						CompileAsManaged="0"
 					/>
 				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
 			</File>
 			<File
 				RelativePath="..\em2874.cpp"
@@ -222,6 +403,86 @@
 				>
 			</File>
 			<File
+				RelativePath="..\message.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\osdepend.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\pryutil.cpp"
+				>
+			</File>
+			<File
+				RelativePath="..\pryutil.h"
+				>
+			</File>
+			<File
 				RelativePath=".\stdafx.cpp"
 				>
 				<FileConfiguration
@@ -233,11 +494,103 @@
 					/>
 				</FileConfiguration>
 				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx2.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
 					Name="Release|Win32"
 					>
 					<Tool
 						Name="VCCLCompilerTool"
 						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tsthread.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
 					/>
 				</FileConfiguration>
 			</File>
@@ -245,6 +598,10 @@
 				RelativePath="..\twindbg.h"
 				>
 			</File>
+			<File
+				RelativePath="..\usbdevfile.cpp"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="wb_[ t@C"
@@ -252,7 +609,11 @@
 			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
 			>
 			<File
-				RelativePath=".\BonTuner.h"
+				RelativePath="..\bonhybrid.h"
+				>
+			</File>
+			<File
+				RelativePath=".\BonTuner_FSUSB2N.h"
 				>
 			</File>
 			<File
@@ -264,9 +625,33 @@
 				>
 			</File>
 			<File
+				RelativePath="..\message.h"
+				>
+			</File>
+			<File
+				RelativePath="..\osdepend.h"
+				>
+			</File>
+			<File
 				RelativePath=".\stdafx.h"
 				>
 			</File>
+			<File
+				RelativePath="..\tsbuff.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsthread.h"
+				>
+			</File>
+			<File
+				RelativePath="..\types_u.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.h"
+				>
+			</File>
 		</Filter>
 		<Filter
 			Name="\[X t@C"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcxproj BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcxproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N.vcxproj	2020-10-06 07:15:46.000000000 +0900
@@ -0,0 +1,269 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}</ProjectGuid>
+    <RootNamespace>BonDriver_FSUSB2N</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>14.0.25431.1</_ProjectFileVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <TargetName>$(ProjectName)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\bonhybrid.cpp" />
+    <ClCompile Include="..\em2874.cpp" />
+    <ClCompile Include="..\ktv.cpp" />
+    <ClCompile Include="..\message.c">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\tsthread.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\usbdevfile.cpp" />
+    <ClCompile Include="BonTuner_FSUSB2N.cpp" />
+    <ClCompile Include="dllmain.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp" />
+    <ClCompile Include="stdafx.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="stdafx2.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\bonhybrid.h" />
+    <ClInclude Include="..\em2874.h" />
+    <ClInclude Include="..\inc\IBonDriver.h" />
+    <ClInclude Include="..\inc\IBonDriver2.h" />
+    <ClInclude Include="..\ktv.h" />
+    <ClInclude Include="..\osdepend.h" />
+    <ClInclude Include="..\tsbuff.h" />
+    <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
+    <ClInclude Include="..\types_u.h" />
+    <ClInclude Include="..\usbdevfile.h" />
+    <ClInclude Include="BonTuner_FSUSB2N.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="stdafx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N_isoch.vcxproj BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N_isoch.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N_isoch.vcxproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonDriver_FSUSB2N_isoch.vcxproj	2020-10-11 01:51:26.000000000 +0900
@@ -0,0 +1,281 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}</ProjectGuid>
+    <RootNamespace>BonDriver_FSUSB2N</RootNamespace>
+    <Keyword>Win32Proj</Keyword>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <_ProjectFileVersion>14.0.25431.1</_ProjectFileVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>true</LinkIncremental>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <TargetName>$(ProjectName)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <MinimalRebuild>true</MinimalRebuild>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX86</TargetMachine>
+    </Link>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Midl>
+      <TargetEnvironment>X64</TargetEnvironment>
+    </Midl>
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <AdditionalIncludeDirectories>../inc;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <WarningLevel>Level3</WarningLevel>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+    </ClCompile>
+    <Link>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <SubSystem>Windows</SubSystem>
+      <OptimizeReferences>true</OptimizeReferences>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <TargetMachine>MachineX64</TargetMachine>
+    </Link>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\bonhybrid.cpp" />
+    <ClCompile Include="..\em2874.cpp" />
+    <ClCompile Include="..\ktv.cpp" />
+    <ClCompile Include="..\message.c">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\tsthread.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\usbdevfile.cpp" />
+    <ClCompile Include="BonTuner_FSUSB2N.cpp" />
+    <ClCompile Include="dllmain.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+      </PrecompiledHeader>
+      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp" />
+    <ClCompile Include="stdafx.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="stdafx2.c">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)2.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\bonhybrid.h" />
+    <ClInclude Include="..\em2874.h" />
+    <ClInclude Include="..\inc\IBonDriver.h" />
+    <ClInclude Include="..\inc\IBonDriver2.h" />
+    <ClInclude Include="..\ktv.h" />
+    <ClInclude Include="..\osdepend.h" />
+    <ClInclude Include="..\tsbuff.h" />
+    <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
+    <ClInclude Include="..\types_u.h" />
+    <ClInclude Include="..\usbdevfile.h" />
+    <ClInclude Include="BonTuner_FSUSB2N.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="stdafx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.cpp BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.cpp	2012-09-29 04:43:19.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.cpp	2020-06-19 15:22:12.000000000 +0900
@@ -1,45 +1,43 @@
 
 #include "stdafx.h"
-#include "BonTuner.h"
-#include "../twindbg.h"
+#include "BonTuner_FSUSB2N.h"
 
-#pragma warning( disable : 4273 )
-extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
-{
-	return (CBonTuner::m_pThis)? CBonTuner::m_pThis : ((IBonDriver *) new CBonTuner);
-}
-#pragma warning( default : 4273 )
+using namespace std ;
+
+namespace FSUSB2N {
 
-// ÓIo
-CBonTuner * CBonTuner::m_pThis = NULL;
-HINSTANCE CBonTuner::m_hModule = NULL;
+DWORD FSUSB2N_INTERIM_WAIT       = 20 ;
+DWORD FSUSB2N_SETFREQ_TIMES      = 2 ;
+DWORD FSUSB2N_RESETDEMOD_TIMES   = 1 ;
+BOOL  FSUSB2N_LOCK_ON_SIGNAL     = TRUE ; 
 
 const TCHAR *g_RegKey = TEXT("Software\\tri.dw.land.to\\FSUSB2N");
 
 CBonTuner::CBonTuner()
-: m_dwCurSpace(0) , m_dwCurChannel(0) , usbDev(NULL) , pDev(NULL) , m_TsBuffSize(NULL) , m_ChannelList(NULL)
-#ifndef NO_TSTHREAD
-, m_hThread(NULL)
-#endif
+: CBonFSHybrid(), m_dwCurSpace(0), m_dwCurChannel(0), usbDev(NULL), pDev(NULL),
+  m_hDev(NULL), m_hUsbDev(NULL)
 {
-	m_pThis = this;
-	this->LoadData();
+	ZeroMemory(&m_USBEP, sizeof m_USBEP);
 }
 
 CBonTuner::~CBonTuner()
 {
 	// JĂꍇ͕
 	CloseTuner();
+}
 
-	if(m_ChannelList != NULL) ::GlobalFree(m_ChannelList);
-	m_pThis = NULL;
+const TCHAR *CBonTuner::RegName()
+{
+	return g_RegKey ;
 }
 
-inline void WaitSleep (const DWORD dwStart, const DWORD dwTime)
+int CBonTuner::UserDecidedDeviceIdx()
 {
-	DWORD dwLeft = dwStart + dwTime - ::GetTickCount();
-	if(dwLeft < 60000U)
-		::Sleep(dwLeft);
+	int idx=0 ;
+	if(sscanf_s( upper_case(file_prefix_of(ModuleFileName())).c_str() , "BONDRIVER_FSUSB2N_DEV%d", &idx )==1)
+	  return idx ;
+
+	return -1 ;
 }
 
 const BOOL CBonTuner::OpenTuner()
@@ -49,22 +47,22 @@
 	if(IsTunerOpening())return FALSE;
 
 	try{
-		// AllocTuner
-		for(int idx = 0;;)
-		{
-			EM2874Device* pDevTmp = EM2874Device::AllocDevice(idx);
-			if(pDevTmp == NULL) {
-				// DeviceȂꍇ
-				throw (const DWORD)__LINE__;
-			}
-			// Devicemۂ
-			usbDev = pDevTmp;
-			break;
+
+		//# AllocTuner
+		if(!FindDevice(GUID_WINUSB_FSUSB2N_DRV,m_hDev,m_hUsbDev)) {
+		  if(m_hDev==NULL) throw (const DWORD)__LINE__;
+		  if(m_hUsbDev==NULL) throw (const DWORD)__LINE__;
+		}
+		usbDev = EM2874Device::AllocDevice(m_hDev,m_hUsbDev);
+		if(usbDev == NULL) {
+			// DeviceȂꍇ
+			throw (const DWORD)__LINE__;
 		}
+
 		// Device
 		usbDev->initDevice2();
 
-		DWORD dwTime = ::GetTickCount();
+		DWORD dwStart = PastSleep();
 		::Sleep(80);
 		if(usbDev->getDeviceID() == 2) {
 			pDev = new Ktv2Device(usbDev);
@@ -72,34 +70,29 @@
 			pDev = new Ktv1Device(usbDev);
 		}
 
-		WaitSleep(dwTime, 160);
+		PastSleep(160,dwStart);
 		pDev->InitTuner();
 
-		WaitSleep(dwTime, 180);
+		PastSleep(180,dwStart);
 		pDev->InitDeMod();
 		pDev->ResetDeMod();
 
-		WaitSleep(dwTime, 500);
-		//
-		m_TsBuffSize = (int*)VirtualAlloc( NULL, RINGBUFF_SIZE*USBBULK_XFERSIZE + 0x1000, MEM_COMMIT, PAGE_READWRITE );
-		if(m_TsBuffSize == NULL)	throw (const DWORD)__LINE__;
-		m_pTsBuff = (BYTE*)(m_TsBuffSize + 0x400);
-		m_indexTsBuff = 0;
-
-		usbDev->SetBuffer( (void*)m_TsBuffSize );
-		usbDev->TransferStart();
-#ifndef NO_TSTHREAD
-		m_hThread = (HANDLE)_beginthreadex( NULL, 0, TsThread, (PVOID)this, 0, NULL );
-		if(m_hThread == INVALID_HANDLE_VALUE) {
-			m_hThread = NULL;
-		}else{
-			::SetThreadPriority( m_hThread, THREAD_PRIORITY_TIME_CRITICAL );
-			m_hTsRecv = ::CreateEvent ( NULL, FALSE, FALSE, NULL );
-		}
-#endif
+		PastSleep(500,dwStart);
+
+		usbDev->SetupUSBEndPoint(&m_USBEP);
+
+		// FIFO
+		if(!FifoInitialize(&m_USBEP)) throw (const DWORD)__LINE__;
+
 		// foCXgp Iǂ͂܂
+		DBGOUT("OpenTuner done.\n");
 	}
-	catch (const DWORD dwErrorStep) {
+	catch (
+		const DWORD
+#ifdef _DEBUG
+		dwErrorStep
+#endif
+		) {
 		// Error
 		DBG_INFO("BonDriver_FSUSB2N:OpenTuner dwErrorStep = %lu\n", dwErrorStep);
 
@@ -111,24 +104,10 @@
 
 void CBonTuner::CloseTuner()
 {
-	if(m_TsBuffSize)
-	{
-		usbDev->TransferStop();
-		usbDev->SetBuffer(NULL);
-		::VirtualFree( (LPVOID)m_TsBuffSize, 0, MEM_RELEASE );
-		m_TsBuffSize = NULL;
-	}
 
-#ifndef NO_TSTHREAD
-	if(m_hThread != NULL) {
-		if(::WaitForSingleObject(m_hThread, 1500) != WAIT_OBJECT_0) {
-			::TerminateThread(m_hThread, 0);
-		}
-		::CloseHandle(m_hThread);
-		::CloseHandle(m_hTsRecv);
-		m_hThread = NULL;
-	}
-#endif
+	FifoFinalize() ;
+
+	if(usbDev) usbDev->CleanupUSBEndPoint(&m_USBEP);
 
 	if(pDev) {
 		delete pDev;
@@ -139,142 +118,27 @@
 		delete usbDev;
 		usbDev = NULL;
 	}
-}
 
-const BOOL CBonTuner::SetChannel(const BYTE bCh)
-{
-	// IBonDriverƂ̌݊ۂ߂Ɏb
+	FreeDevice(m_hDev,m_hUsbDev);
 
-	if(bCh < 13 || bCh > 52) return FALSE;
-	else return SetChannel(0UL, bCh - 13U);
+	DBGOUT("CloseTuner done.\n");
 }
 
 const float CBonTuner::GetSignalLevel(void)
 {
 	if(pDev == NULL) return 0.0f;
-	return pDev->DeMod_GetQuality() * 0.01f;
-}
-
-const DWORD CBonTuner::WaitTsStream(const DWORD dwTimeOut)
-{
-	if(GetReadyCount() > 0)
-	{
-		return WAIT_OBJECT_0;
-	}
-	if(m_TsBuffSize == NULL)
-	{
-		::Sleep(dwTimeOut < 2000 ? dwTimeOut : 2000 );
-		return WAIT_TIMEOUT;
-	}
-#ifdef NO_TSTHREAD
-	DWORD dwRet = ::WaitForSingleObject( usbDev->GetHandle() , dwTimeOut );
-
-	if( dwRet == WAIT_OBJECT_0  )
-	{
-		int nRet = usbDev->DispatchTSRead();
-		if( nRet < 0 )	return WAIT_FAILED;
-	}
-	return dwRet;
-#else
-	return ::WaitForSingleObject(m_hTsRecv, dwTimeOut);
-#endif
-}
-
-const DWORD CBonTuner::GetReadyCount()
-{
-	// o\TSf[^擾
-	if(m_TsBuffSize == NULL) return 0;
-	const int indexCurrent = m_indexTsBuff;
-	int val;
-
-#ifdef NO_TSTHREAD
-	DWORD dwRet = ::WaitForSingleObject( usbDev->GetHandle() , 0 );
-
-	if( dwRet == WAIT_FAILED )
-	{
-		return 0;
-	}else if( dwRet == WAIT_OBJECT_0 || dwRet == WAIT_TIMEOUT )
-	{
-		usbDev->DispatchTSRead();
-	}
-#endif
-
-	// size=0skip
-	do {
-		val = m_TsBuffSize[m_indexTsBuff];
-		if(val > 0 || val == -1) {
-			break;
-		}else if(val <= -2) {
-			m_indexTsBuff = 0;
-		}else if(val == 0) {
-			m_indexTsBuff++;
-		}
-	} while(m_indexTsBuff != indexCurrent);
-
-	return m_TsBuffSize[m_indexTsBuff] < 0 ? 0 : 1;
-}
-
-const BOOL CBonTuner::GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	BYTE *pSrc = NULL;
-
-	// TSf[^Buffero
-	if(GetTsStream(&pSrc, pdwSize, pdwRemain)){
-		if(*pdwSize) {
-			::CopyMemory(pDst, pSrc, *pdwSize);
-		}
-		return TRUE;
-	}
-	
-	return FALSE;
-}
 
-const BOOL CBonTuner::GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	//
-	if(m_TsBuffSize == NULL) return FALSE;
-	const unsigned int BuffBlockSize = -m_TsBuffSize[0x3ff];
-	int val;
-
-	if(GetReadyCount() == 0) {
-		// o\ȃf[^Ȃ
-		*pdwSize = 0;
-		*pdwRemain = 0;
-		return TRUE;
-	}
+	const bool do_locking = FSUSB2N_LOCK_ON_SIGNAL && m_USBEP.dev && m_USBEP.lockunlockFunc ;
+    
+	if(do_locking) //# lock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,1);
 
-	*ppDst = m_pTsBuff + (m_indexTsBuff * BuffBlockSize);
-	int dataLen = 0;
-	do {
-		val = m_TsBuffSize[m_indexTsBuff];
-
-		if(val >= 0) {
-			dataLen += val;
-			m_indexTsBuff++;
-		}
-	} while(val == BuffBlockSize);
-
-	*pdwSize = dataLen;
-	*pdwRemain = GetReadyCount();
-	return TRUE;
-}
+	float db = pDev->DeMod_GetQuality() * 0.01f;
 
-void CBonTuner::PurgeTsStream()
-{
-	if(m_TsBuffSize == NULL) return;
-	if(m_TsBuffSize[m_indexTsBuff] < 0) return;
+	if(do_locking) //# unlock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,0);
 
-	// Buffero\f[^p[W
-	for(int i = 0; i <= 0x3fe; i++) {
-		if(m_TsBuffSize[i] == -1)
-		{
-			m_indexTsBuff = i;
-			return;
-		}else if(m_TsBuffSize[i] == -2)
-		{
-			return;
-		}
-	}
+	return db ;
 }
 
 void CBonTuner::Release()
@@ -286,80 +150,56 @@
 LPCTSTR CBonTuner::GetTunerName(void)
 {
 	// `[iԂ
-	return TEXT("KTV-FSUSB2V");
+	return TEXT("FSUSB2N");
 }
 
 const BOOL CBonTuner::IsTunerOpening(void)
 {
-	return pDev ? TRUE : FALSE;
-}
-
-LPCTSTR CBonTuner::EnumTuningSpace(const DWORD dwSpace)
-{
-	// gp\ȃ`[jOԂԂ
-	if(dwSpace == 0U) return TEXT("nfW");
-	else if(m_ChannelList != NULL && dwSpace == 1U) return TEXT("nfW(ǉ)");
-	return NULL;
-}
-
-LPCTSTR CBonTuner::EnumChannelName(const DWORD dwSpace, const DWORD dwChannel)
-{
-	// gp\ChannelԂ
-
-	static const TCHAR ChannelNameT[][3] = 
-	{
-		TEXT("13"), TEXT("14"), TEXT("15"), TEXT("16"), TEXT("17"), TEXT("18"), TEXT("19"),
-		TEXT("20"), TEXT("21"), TEXT("22"), TEXT("23"), TEXT("24"), TEXT("25"), TEXT("26"), TEXT("27"), TEXT("28"), TEXT("29"),
-		TEXT("30"), TEXT("31"), TEXT("32"), TEXT("33"), TEXT("34"), TEXT("35"), TEXT("36"), TEXT("37"), TEXT("38"), TEXT("39"), 
-		TEXT("40"), TEXT("41"), TEXT("42"), TEXT("43"), TEXT("44"), TEXT("45"), TEXT("46"), TEXT("47"), TEXT("48"), TEXT("49"), 
-		TEXT("50"), TEXT("51"), TEXT("52")
-	};
-
-	if(m_ChannelList != NULL && dwSpace == 1U) {
-		/* [U[` */
-		DWORD dwChannelLen		= m_ChannelList[0] >> 16;
-		DWORD dwNumOfChannels	= m_ChannelList[0] & 0xffff;
-		TCHAR *ptrStr = (TCHAR*)(m_ChannelList + dwNumOfChannels + 1);
-		if(dwChannel < dwNumOfChannels)	return ptrStr + (dwChannelLen * dwChannel);
-	}else if(dwSpace == 0U) {
-		if(dwChannel < 40)
-			return ChannelNameT[dwChannel];
-	}
-	return NULL;
+	return m_hUsbDev ? TRUE : FALSE;
 }
 
 const BOOL CBonTuner::SetChannel(const DWORD dwSpace, const DWORD dwChannel)
 {
-	if(pDev == NULL) return FALSE;
-	if(NULL == EnumChannelName(dwSpace, dwChannel)) return FALSE;
+	if(NULL == pDev) return FALSE;
+	if(NULL == tsthr) return FALSE;
 
-	DWORD dwFreq;
+	
+    DWORD dwFreq = GetChannel(dwSpace,dwChannel).Freq ;
 
-	if(m_ChannelList != NULL && dwSpace == 1U) {
-		/* [U[` */
-		dwFreq = m_ChannelList[dwChannel + 1];
-	}else if(dwSpace == 0U) {
-		dwFreq = dwChannel * 6000U + 473143U;
-	}else{
-		return FALSE;
-	}
 	if(dwFreq < 90000U || dwFreq > 772000U) return FALSE;
 
 	// ChannelύX
-	usbDev->TransferPause();
 
-	pDev->SetFrequency(dwFreq);
-	::Sleep(5);
-	pDev->ResetDeMod();
-	::Sleep(20);
-	usbDev->TransferResume();
-	::Sleep(10);
+	FifoStop();
+	::Sleep(FSUSB2N_INTERIM_WAIT);
+
+	const bool do_locking = FSUSB2N_LOCK_ON_SIGNAL && m_USBEP.dev && m_USBEP.lockunlockFunc ;
+    
+	if(do_locking) //# lock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,1);
+
+	for(DWORD i=FSUSB2N_SETFREQ_TIMES;i;i--) {
+		pDev->SetFrequency(dwFreq);
+		::Sleep(FSUSB2N_INTERIM_WAIT);
+	}
+	for(DWORD i=FSUSB2N_RESETDEMOD_TIMES;i;i--) {
+		pDev->ResetDeMod();
+		::Sleep(FSUSB2N_INTERIM_WAIT);
+	}
+
+	if(do_locking) //# unlock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,0);
+
+	FifoStart();
+	::Sleep(FSUSB2N_INTERIM_WAIT);
+
 	PurgeTsStream();
 
+
 	// ChannelXV
 	m_dwCurSpace = dwSpace;
 	m_dwCurChannel = dwChannel;
-
+    
 	return TRUE;
 }
 
@@ -375,107 +215,22 @@
 	return m_dwCurChannel;
 }
 
-#ifndef NO_TSTHREAD
-unsigned int __stdcall CBonTuner::TsThread (PVOID pv)
+void CBonTuner::LoadValues(const IValueLoader *Loader)
 {
-	DWORD dwRet;
-	int nRet;
-	EM2874Device *pUsbDev;
-
-	if(pv && ((CBonTuner*)pv)->usbDev)
-	{
-		pUsbDev = ((CBonTuner*)pv)->usbDev;
-	}else{
-		::_endthreadex (0);
-		return 0;
-	}
-
-	for(;;)
-	{
-		dwRet = ::WaitForSingleObject( pUsbDev->GetHandle() , 1000 );
-
-		if( dwRet == WAIT_FAILED )
-		{
-			break;
-		}else if( dwRet == WAIT_OBJECT_0 || dwRet == WAIT_TIMEOUT )
-		{
-			nRet = pUsbDev->DispatchTSRead();
-			if(nRet > 0)	::SetEvent(((CBonTuner*)pv)->m_hTsRecv);
-			if(nRet < 0)	break;
-		}
-	}
-	::_endthreadex (0);
-	return 0;
-}
-#endif
-
+	DWORD FunctionMode = DWORD(EM2874Device::UserSettings&0xffff) | DWORD(KtvDevice::UserSettings)<<16 ;
 
-bool CBonTuner::LoadData ()
-{
-	HKEY hKey;
+	CBonFSHybrid::LoadValues (Loader) ;
+	#define LOADDW(val) do { val = Loader->ReadDWORD(L#val,val); } while(0)
+	LOADDW(FunctionMode);
+	LOADDW(FSUSB2N_INTERIM_WAIT);
+	LOADDW(FSUSB2N_SETFREQ_TIMES);
+	LOADDW(FSUSB2N_RESETDEMOD_TIMES);
+	LOADDW(FSUSB2N_LOCK_ON_SIGNAL);
+	#undef LOADDW
 
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, g_RegKey, 0, KEY_READ, &hKey))
-	{
-		ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, g_RegKey, 0, KEY_READ, &hKey))
-	{
-		ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-
-	return true;
+	EM2874Device::UserSettings = FunctionMode & 0xffff;
+	KtvDevice::UserSettings = FunctionMode >> 16;
 }
 
-void CBonTuner::ReadRegMode (HKEY hPKey)
-{
-	DWORD dwValue, dwLen, dwType;
-
-	dwLen = sizeof(dwValue);
-	if(ERROR_SUCCESS != RegQueryValueEx( hPKey, TEXT("FunctionMode"), NULL, &dwType, (BYTE*)&dwValue, &dwLen)
-		|| dwLen != sizeof(DWORD) ) {
-		return;
-	}
-	EM2874Device::UserSettings = dwValue & 0xffff;
-	KtvDevice::UserSettings = dwValue >> 16;
-}
+} // End of namespace FSUSB2N
 
-void CBonTuner::ReadRegChannels (HKEY hPKey)
-{
-	if(m_ChannelList != NULL) return;
-	//
-	HKEY hKey;
-	DWORD NumOfValues;
-	TCHAR szValueName[32];
-	DWORD dwValue, dwLen, dwType, dwByte, dwMaxValueName;
-	if(ERROR_SUCCESS != RegOpenKeyEx( hPKey, TEXT("Channels"), 0, KEY_READ, &hKey)) {
-		return;
-	}
-	if(ERROR_SUCCESS != RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumOfValues, &dwMaxValueName, NULL, NULL, NULL)) {
-		RegCloseKey(hKey);
-		return;
-	}
-	dwMaxValueName++;
-	m_ChannelList = (DWORD*) GlobalAlloc(GMEM_FIXED, NumOfValues * (dwMaxValueName * sizeof(TCHAR) + sizeof(DWORD)) + sizeof(DWORD) );
-	m_ChannelList[0] = dwMaxValueName << 16 | NumOfValues;
-	ZeroMemory( m_ChannelList + 1, sizeof(DWORD) * NumOfValues );
-	TCHAR *ptrStr;
-	for(DWORD dwIdx = 0; dwIdx < NumOfValues; dwIdx++ ) {
-		dwLen = 32;
-		dwByte = sizeof(dwValue);
-		if(ERROR_SUCCESS != RegEnumValue( hKey, dwIdx, szValueName, &dwLen, NULL, &dwType, (BYTE*)&dwValue, &dwByte)
-			|| dwByte != sizeof(DWORD)) {
-			break;
-		}
-		dwByte = dwValue >> 24; // Index
-		if( dwByte >= NumOfValues ) continue;
-		m_ChannelList[dwByte + 1] = dwValue & 0x00ffffffU;
-		ptrStr = (TCHAR*)(m_ChannelList + NumOfValues + 1);
-		ptrStr += dwMaxValueName * dwByte;
-		lstrcpyn( ptrStr, szValueName, dwMaxValueName );
-	}
-	RegCloseKey(hKey);
-}
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.h BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.h	2012-09-28 01:55:04.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/BonTuner_FSUSB2N.h	2020-05-07 14:30:32.000000000 +0900
@@ -3,11 +3,23 @@
 // BonTuner.h: CBonTuner NX̃C^[tFCX
 //////////////////////////////////////////////////
 
+#include <vector>
+#include <queue>
+#include <cstdlib>
 #include "IBonDriver2.h"
 #include "../ktv.h"
+#include "../usbdevfile.h"
+#include "../bonhybrid.h"
 
-class CBonTuner : public IBonDriver2
+namespace FSUSB2N {
+
+class CBonTuner : public CBonFSHybrid
 {
+protected:
+	const TCHAR *RegName() ;
+	int UserDecidedDeviceIdx() ;
+    void LoadValues(const IValueLoader *Loader);
+
 public:
 	CBonTuner();
 	virtual ~CBonTuner();
@@ -16,53 +28,31 @@
 	const BOOL OpenTuner(void);
 	void CloseTuner(void);
 
-	const BOOL SetChannel(const BYTE bCh);
 	const float GetSignalLevel(void);
 
-	const DWORD WaitTsStream(const DWORD dwTimeOut = 0);
-	const DWORD GetReadyCount(void);
-
-	const BOOL GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain);
-	const BOOL GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain);
-
-	void PurgeTsStream(void);
-
 // IBonDriver2(b)
 	LPCTSTR GetTunerName(void);
 
 	const BOOL IsTunerOpening(void);
-	
-	LPCTSTR EnumTuningSpace(const DWORD dwSpace);
-	LPCTSTR EnumChannelName(const DWORD dwSpace, const DWORD dwChannel);
 
 	const BOOL SetChannel(const DWORD dwSpace, const DWORD dwChannel);
-	
+
 	const DWORD GetCurSpace(void);
 	const DWORD GetCurChannel(void);
 
 	void Release(void);
 
-	static CBonTuner * m_pThis;
-	static HINSTANCE m_hModule;
-
 protected:
 	DWORD m_dwCurSpace;
 	DWORD m_dwCurChannel;
-	DWORD *m_ChannelList;
 
+	HANDLE m_hDev;
+	HANDLE m_hUsbDev;
+	struct usb_endpoint_st  m_USBEP;
 	EM2874Device *usbDev;
 	KtvDevice *pDev;
-	BYTE *m_pTsBuff;
-	volatile int *m_TsBuffSize;		// 32bit signed
-	volatile int m_indexTsBuff;
-
-#ifndef NO_TSTHREAD
-	HANDLE m_hThread;
-	HANDLE m_hTsRecv;
-	static unsigned int __stdcall TsThread (PVOID pv);
-#endif
-
-	bool LoadData ();
-	void ReadRegMode (HKEY hPKey);
-	void ReadRegChannels (HKEY hPKey);
+    
 };
+
+} // End of namespace FSUSB2N
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/dllmain.cpp BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/dllmain.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/dllmain.cpp	2009-09-02 03:28:53.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/dllmain.cpp	2020-01-07 03:20:04.000000000 +0900
@@ -1,10 +1,12 @@
 // dllmain.cpp : DLL AvP[ṼGg |Cg`܂B
 #include "stdafx.h"
-#include "BonTuner.h"
+#include "BonTuner_FSUSB2N.h"
+
+using namespace FSUSB2N;
 
 BOOL APIENTRY DllMain( HMODULE hModule,
-                       DWORD  ul_reason_for_call,
-                       LPVOID lpReserved
+					   DWORD  ul_reason_for_call,
+					   LPVOID lpReserved
 					 )
 {
 	switch (ul_reason_for_call)
@@ -14,10 +16,15 @@
 		CBonTuner::m_hModule = hModule;
 		break;
 	case DLL_PROCESS_DETACH:
-		// J̏ꍇ̓CX^XJ		
+		// J̏ꍇ̓CX^XJ
 		if(CBonTuner::m_pThis)CBonTuner::m_pThis->Release();
 		break;
 	}
 	return TRUE;
 }
 
+#pragma warning( disable : 4273 )
+extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
+{return BonFSCreate<CBonTuner>();}
+#pragma warning( default : 4273 )
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/stdafx.h BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/stdafx.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/stdafx.h	2009-09-02 03:29:22.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/stdafx.h	2019-12-31 18:33:12.000000000 +0900
@@ -6,3 +6,7 @@
 #include <windows.h>
 #include <tchar.h>
 #include <process.h>
+
+#include "../message.h"
+
+#include "../twindbg.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/stdafx2.c BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/stdafx2.c
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2N/stdafx2.c	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2N/stdafx2.c	2015-12-09 05:03:24.000000000 +0900
@@ -0,0 +1 @@
+#include "stdafx.h"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver.rc BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/BonDriver.rc
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver.rc	2016-02-18 20:22:16.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/BonDriver.rc	2020-10-12 00:45:18.000000000 +0900
@@ -2,8 +2,8 @@
 
 LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT
 1 VERSIONINFO
- FILEVERSION 0,1,5,5
- PRODUCTVERSION 0,1,5,5
+ FILEVERSION 0,2020,10,12
+ PRODUCTVERSION 0,2020,10,12
  FILEFLAGSMASK 0x17L
 #ifdef _DEBUG
  FILEFLAGS 0x1L
@@ -18,14 +18,14 @@
     BEGIN
         BLOCK "041104b0"
         BEGIN
-            VALUE "CompanyName", "trinity19683"
+            VALUE "CompanyName", "hyrolean-dtv inspired by trinity19683"
             VALUE "FileDescription", "BonDriver for FSUSB2i"
-            VALUE "FileVersion", "0,1,5,5"
+            VALUE "FileVersion", "0,2020,10,12"
             VALUE "InternalName", "BonDriver_FSUSB2i.dll"
-            VALUE "LegalCopyright", "trinity19683 2015-2016"
+            VALUE "LegalCopyright", "hyrolean-dtv 2018-2020 inspired by trinity19683 2015-2016"
             VALUE "OriginalFilename", "BonDriver_FSUSB2i.dll"
             VALUE "ProductName", "BonDriver_FSUSB2i"
-            VALUE "ProductVersion", "0,1,5,5"
+            VALUE "ProductVersion", "0,2020,10,12"
         END
     END
     BLOCK "VarFileInfo"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcproj BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcproj	2020-10-02 05:27:42.000000000 +0900
@@ -0,0 +1,965 @@
+<?xml version="1.0" encoding="shift_jis"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="BonDriver_FSUSB2i"
+	ProjectGUID="{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}"
+	RootNamespace="BonDriver_FSUSB2i"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="196613"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2i.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2i_x64.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2i.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_FSUSB2i_x64.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="\[X t@C"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\bonhybrid.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\BonTuner_FSUSB2i.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\dllmain.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\it9175.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\it9175_usb.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\message.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\osdepend.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\pryutil.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx2.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tsthread.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbops.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="wb_[ t@C"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\bonhybrid.h"
+				>
+			</File>
+			<File
+				RelativePath=".\BonTuner_FSUSB2i.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_fw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_priv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\it9175_usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\message.h"
+				>
+			</File>
+			<File
+				RelativePath="..\osdepend.h"
+				>
+			</File>
+			<File
+				RelativePath="..\pryutil.h"
+				>
+			</File>
+			<File
+				RelativePath=".\stdafx.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\stdint_.h"
+				>
+			</File>
+			<File
+				RelativePath="..\targetver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsbuff.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsthread.h"
+				>
+			</File>
+			<File
+				RelativePath="..\twindbg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\types_u.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb100.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb200.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbops.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusbio.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="\[X t@C"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\BonDriver.rc"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcxproj BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcxproj	2016-02-11 08:58:44.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/BonDriver_FSUSB2i.vcxproj	2020-10-02 04:47:42.000000000 +0900
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Debug|Win32">
       <Configuration>Debug</Configuration>
@@ -22,6 +22,7 @@
     <ProjectGuid>{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>FSUSB2i</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Label="Configuration">
@@ -36,7 +37,13 @@
     <WholeProgramOptimization>true</WholeProgramOptimization>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='x64'" Label="Configuration">
-    <PlatformToolset>Windows7.1SDK</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
@@ -65,10 +72,28 @@
     <LinkIncremental>false</LinkIncremental>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='Win32'">
-    <LibraryPath>..\lib;$(LibraryPath)</LibraryPath>
+    <LibraryPath>$(LibraryPath)</LibraryPath>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='x64'">
-    <LibraryPath>..\lib64;$(LibraryPath)</LibraryPath>
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
   </PropertyGroup>
   <ItemDefinitionGroup>
     <ClCompile>
@@ -106,23 +131,32 @@
     <ClCompile>
       <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;FSUSB2I_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
+    <Link />
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
       <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;FSUSB2I_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
+    <Link>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+    </Link>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
     <ClCompile>
       <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;FSUSB2I_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
+    <Link />
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <ClCompile>
       <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;FSUSB2I_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
+    <Link>
+      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
+    </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClInclude Include="..\bonhybrid.h" />
     <ClInclude Include="..\it9175.h" />
     <ClInclude Include="..\it9175_fw.h" />
     <ClInclude Include="..\it9175_priv.h" />
@@ -135,10 +169,17 @@
     <ClInclude Include="..\types_u.h" />
     <ClInclude Include="..\usbdevfile.h" />
     <ClInclude Include="..\usbops.h" />
-    <ClInclude Include="BonTuner.h" />
+    <ClInclude Include="BonTuner_FSUSB2i.h" />
+    <ClInclude Include="..\pryutil.h" />
     <ClInclude Include="stdafx.h" />
   </ItemGroup>
   <ItemGroup>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="..\it9175.c">
       <PrecompiledHeader>NotUsing</PrecompiledHeader>
     </ClCompile>
@@ -150,7 +191,10 @@
       <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
     <ClCompile Include="..\usbops.c" />
-    <ClCompile Include="BonTuner.cpp">
+    <ClCompile Include="BonTuner_FSUSB2i.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
       <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
     <ClCompile Include="dllmain.cpp">
BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2iȯ: BonDriver_FSUSB2i.vcxproj.filters
BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2iȯ: BonDriver_FSUSB2i.vcxproj.user
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.cpp BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.cpp	2016-02-12 00:14:10.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.cpp	2020-05-19 23:14:36.000000000 +0900
@@ -3,34 +3,43 @@
   BonTuner.cpp
   2016-02-12
 */
-
 #include "stdafx.h"
+
 #include <tchar.h>
-#include "BonTuner.h"
+#include "BonTuner_FSUSB2i.h"
 #include "../usbdevfile.h"
 
-#pragma warning( disable : 4273 )
-extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
-{ return (CBonTuner::m_pThis)? CBonTuner::m_pThis : ((IBonDriver *) new CBonTuner); }
-#pragma warning( default : 4273 )
-
-//# initialize static member variables
-CBonTuner * CBonTuner::m_pThis = NULL;
-HINSTANCE CBonTuner::m_hModule = NULL;
+using namespace std ;
+
+namespace FSUSB2i {
+
+DWORD FSUSB2I_SETFREQ_TIMES     = 2 ;
+DWORD FSUSB2I_TUNING_WAIT       = 1500 ;
+BOOL  FSUSB2I_LOCK_ON_SIGNAL    = TRUE ;
 
 const TCHAR* const g_RegKey = TEXT("Software\\trinity19683\\FSUSB2i");
 
 CBonTuner::CBonTuner()
-: m_dwCurSpace(0), m_dwCurChannel(0), m_hDev(NULL), m_hUsbDev(NULL), pDev(NULL), tsthr(NULL),
- m_ChannelList(NULL)
-{ m_pThis = this; }
+: CBonFSHybrid(), m_dwCurSpace(0), m_dwCurChannel(0), m_hDev(NULL), m_hUsbDev(NULL), pDev(NULL)
+{}
 
 CBonTuner::~CBonTuner()
 {
 	CloseTuner();
+}
+
+const TCHAR *CBonTuner::RegName()
+{
+	return g_RegKey ;
+}
+
+int CBonTuner::UserDecidedDeviceIdx()
+{
+	int idx=0 ;
+	if(sscanf_s( upper_case(file_prefix_of(ModuleFileName())).c_str() , "BONDRIVER_FSUSB2I_DEV%d", &idx )==1)
+	  return idx ;
 
-	if(m_ChannelList != NULL) ::GlobalFree(m_ChannelList);
-	m_pThis = NULL;
+	return -1 ;
 }
 
 const BOOL CBonTuner::OpenTuner()
@@ -41,30 +50,18 @@
 
 	try{
 		//# AllocTuner
-		for(unsigned int idx = 0; idx < 40;) {
-			HANDLE hDev;
-			if((hDev = usbdevfile_alloc(&idx) ) == NULL) {   //# not found
-				throw (const DWORD)__LINE__;
-			}
-			//# found
-			m_hDev = hDev;
-			if((hDev = usbdevfile_init(m_hDev) ) == NULL) {   //# failed
-				throw (const DWORD)__LINE__;
-			}
-			m_hUsbDev = hDev;
-			break;
+		if(!FindDevice(GUID_WINUSB_FSUSB2V3_DRV,m_hDev,m_hUsbDev)) {
+		  if(m_hDev==NULL) throw (const DWORD)__LINE__;
+		  if(m_hUsbDev==NULL) throw (const DWORD)__LINE__;
 		}
 		//# device initialize
 		m_USBEP.fd = m_hUsbDev;
-		if(it9175_create(&pDev, &m_USBEP) != 0) {
-			throw (const DWORD)__LINE__;
-		}
-		if(tsthread_create(&tsthr, &m_USBEP) != 0) {
-			throw (const DWORD)__LINE__;
-		}
+		if(it9175_create(&pDev, &m_USBEP) != 0) throw (const DWORD)__LINE__;
+		//# fifo
+		if(!FifoInitialize(&m_USBEP)) throw (const DWORD)__LINE__;
 
 		//# device has been ready.
-		LoadData();
+		//LoadData();
 	}
 	catch (const DWORD dwErrorStep) {
 		//# Error
@@ -78,89 +75,31 @@
 
 void CBonTuner::CloseTuner()
 {
-	if(tsthr) {
-		tsthread_stop(tsthr);
-		tsthread_destroy(tsthr);
-		tsthr = NULL;
-	}
+	FifoFinalize() ;
 	if(pDev) {
 		it9175_destroy(pDev);
 		pDev = NULL;
 	}
-	if(m_hUsbDev) {
-		usbdevfile_free(m_hUsbDev);
-		m_hUsbDev = NULL;
-	}
-	if(m_hDev) {
-		::CloseHandle( m_hDev );
-		m_hDev = NULL;
-	}
-}
-
-const BOOL CBonTuner::SetChannel(const BYTE bCh)
-{
-	//# compatible with IBonDriver
-	if(bCh < 13 || bCh > 52) return FALSE;
-	else return SetChannel(0, bCh - 13);
+	FreeDevice(m_hDev,m_hUsbDev);
+	m_USBEP.dev=NULL;
 }
 
 const float CBonTuner::GetSignalLevel(void)
 {
 	if(NULL == pDev) return 0.0f;
-	uint8_t statData[44];
-	if(it9175_readStatistic(pDev, statData) != 0) return 0.1f;
-	return statData[3] * 1.0f;
-}
-
-const DWORD CBonTuner::WaitTsStream(const DWORD dwTimeOut)
-{
-	const int remainTime = (dwTimeOut < 0x10000000) ? dwTimeOut : 0x10000000;
-	if(NULL == tsthr) return WAIT_FAILED;
-
-	const int r = tsthread_wait(tsthr, remainTime);
-	if(0 > r)  return WAIT_FAILED;
-	else if(0 < r)  return WAIT_OBJECT_0;
-	else  return WAIT_TIMEOUT;
-}
-
-const DWORD CBonTuner::GetReadyCount()
-{//# number of call GetTsStream()
-	if(NULL == tsthr) return 0;
-	const int ret = tsthread_readable(tsthr);
-	return (ret > 0) ? 1 : 0;
-}
-
-const BOOL CBonTuner::GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	BYTE *pSrc = NULL;
-	if(GetTsStream(&pSrc, pdwSize, pdwRemain)){
-		if(*pdwSize) ::CopyMemory(pDst, pSrc, *pdwSize);
-		return TRUE;
-	}
-	return FALSE;
-}
-
-const BOOL CBonTuner::GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	if(! tsthr) return FALSE;
-	const int ret = tsthread_readable(tsthr);
-	if(ret <= 0) {
-		//# no readable data
-		*pdwSize = 0;
-		*pdwRemain = 0;
-		return TRUE;
-	}
-	*pdwSize = tsthread_read(tsthr, (void**)ppDst);
-	*pdwRemain = GetReadyCount();
-	//dmsg("GetTsStream(%p,%u,%u)", ppDst, *pdwSize, *pdwRemain);
-	return TRUE;
-}
-
-void CBonTuner::PurgeTsStream()
-{
-	if(! tsthr) return;
-	//# purge available data in TS buffer
-	tsthread_read(tsthr, NULL);
+    
+    bool do_locking = FSUSB2I_LOCK_ON_SIGNAL && m_USBEP.dev && m_USBEP.lockunlockFunc ;
+    
+    if(do_locking) //# lock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,1);
+
+	uint8_t dB; float lv ;
+	if(it9175_readSNRatio(pDev, &dB) != 0) lv = 0.1f;
+	else lv = dB * 1.0f;
+
+    if(do_locking) //# unlock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,0);
+    return lv ;
 }
 
 void CBonTuner::Release()  //# release the instance
@@ -172,61 +111,35 @@
 const BOOL CBonTuner::IsTunerOpening(void)
 { return m_hUsbDev ? TRUE : FALSE; }
 
-LPCTSTR CBonTuner::EnumTuningSpace(const DWORD dwSpace)
-{ return (dwSpace == 0) ? TEXT("nfW") : NULL; }
-
-LPCTSTR CBonTuner::EnumChannelName(const DWORD dwSpace, const DWORD dwChannel)
-{
-	if(dwSpace == 0) {
-		if(m_ChannelList != NULL) {
-			//# User-defined channels
-			const DWORD dwChannelLen    = m_ChannelList[0] >> 16;
-			const DWORD dwNumOfChannels = m_ChannelList[0] & 0xFFFF;
-			TCHAR* const ptrStr = (TCHAR*)(m_ChannelList + dwNumOfChannels + 1);
-			if(dwChannel < dwNumOfChannels)	return ptrStr + (dwChannelLen * dwChannel);
-		}else if(dwChannel < 40) {
-			static TCHAR buf[6];
-			_sntprintf_s(buf, sizeof(buf)/sizeof(TCHAR), _TRUNCATE, TEXT("%u"), dwChannel + 13);
-			return buf;    //# The caller must copy data from this buffer.
-		}
-	}
-	return NULL;
-}
-
 const BOOL CBonTuner::SetChannel(const DWORD dwSpace, const DWORD dwChannel)
 {
 	if(NULL == pDev) return FALSE;
 	if(NULL == tsthr) return FALSE;
 
-	DWORD dwFreq = 0;
+	DWORD dwFreq = GetChannel(dwSpace,dwChannel).Freq ;
 
-	if(dwSpace == 0) {
-		if(m_ChannelList != NULL) {  //# User-defined channels
-			const DWORD dwNumOfChannels = m_ChannelList[0] & 0xFFFF;
-			if(dwChannel < dwNumOfChannels)
-				dwFreq = m_ChannelList[dwChannel + 1];
-		}else{  //# UHF standard channels
-			if(dwChannel < 40)
-				dwFreq = dwChannel * 6000 + 473143;
-		}
-	}else if(dwSpace == 114514) {  //# dwChannel as freq/kHz
-		dwFreq = dwChannel;
-	}
 	if(dwFreq < 61000 || dwFreq > 874000 ) return FALSE;
 
 	//# change channel
-	tsthread_stop(tsthr);
+	FifoStop();
 
 	int ret;
-	if(it9175_setFreq(pDev, dwFreq) != 0) return FALSE;
+	int cnt=0 ;
+	do {
+	  if(it9175_setFreq(pDev, dwFreq) != 0) {
+		if(++cnt==FSUSB2I_SETFREQ_TIMES) return FALSE;
+		continue ;
+	  }
+	  break ;
+	}while(1) ;
 	//# set variables
 	m_dwCurSpace = dwSpace;
 	m_dwCurChannel = dwChannel;
 	::Sleep( 80 );
 
-	tsthread_start(tsthr);
+	FifoStart();
 
-	if((ret = it9175_waitTuning(pDev, 1500)) < 0) return FALSE;
+	if((ret = it9175_waitTuning(pDev, FSUSB2I_TUNING_WAIT)) < 0) return FALSE;
 	//# ignore check empty channel
 	//# ignore check TS sync lock
 
@@ -242,62 +155,16 @@
 { return m_dwCurChannel; }
 
 
-bool CBonTuner::LoadData ()
+void CBonTuner::LoadValues(const IValueLoader *Loader)
 {
-	HKEY hKey;
-
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, g_RegKey, 0, KEY_READ, &hKey)) {
-		//ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, g_RegKey, 0, KEY_READ, &hKey)) {
-		//ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-
-	return true;
+	CBonFSHybrid::LoadValues (Loader) ;
+	#define LOADDW(val) do { val = Loader->ReadDWORD(L#val,val); } while(0)
+	LOADDW(FSUSB2I_SETFREQ_TIMES);
+	LOADDW(FSUSB2I_TUNING_WAIT);
+    LOADDW(FSUSB2I_LOCK_ON_SIGNAL);
+	#undef LOADDW
 }
 
-void CBonTuner::ReadRegMode (HKEY hPKey)
-{ return; }
-
-void CBonTuner::ReadRegChannels (HKEY hPKey)
-{
-	if(m_ChannelList != NULL) return;
-
-	HKEY hKey;
-	DWORD NumOfValues;
-	TCHAR szValueName[32];
-	DWORD dwValue, dwLen, dwType, dwByte, dwMaxValueName;
-	if(ERROR_SUCCESS != RegOpenKeyEx( hPKey, TEXT("Channels"), 0, KEY_READ, &hKey)) {
-		return;
-	}
-	if(ERROR_SUCCESS != RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumOfValues, &dwMaxValueName, NULL, NULL, NULL)) {
-		RegCloseKey(hKey);
-		return;
-	}
-	dwMaxValueName++;
-	m_ChannelList = (DWORD*) ::GlobalAlloc(GMEM_FIXED, NumOfValues * (dwMaxValueName * sizeof(TCHAR) + sizeof(DWORD)) + sizeof(DWORD) );
-	m_ChannelList[0] = dwMaxValueName << 16 | NumOfValues;
-	ZeroMemory( m_ChannelList + 1, sizeof(DWORD) * NumOfValues );
-	TCHAR *ptrStr;
-	for(DWORD dwIdx = 0; dwIdx < NumOfValues; dwIdx++ ) {
-		dwLen = 32;
-		dwByte = sizeof(dwValue);
-		if(ERROR_SUCCESS != RegEnumValue( hKey, dwIdx, szValueName, &dwLen, NULL, &dwType, (BYTE*)&dwValue, &dwByte)
-			|| dwByte != sizeof(DWORD)) {
-			break;
-		}
-		dwByte = dwValue >> 24; //# Index
-		if( dwByte >= NumOfValues ) continue;
-		m_ChannelList[dwByte + 1] = dwValue & 0x00ffffff;
-		ptrStr = (TCHAR*)(m_ChannelList + NumOfValues + 1);
-		ptrStr += dwMaxValueName * dwByte;
-		lstrcpyn( ptrStr, szValueName, dwMaxValueName );
-	}
-	RegCloseKey(hKey);
-}
+} // End of namespace FSUSB2i
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.h BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.h	2016-02-02 20:43:16.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/BonTuner_FSUSB2i.h	2020-05-19 23:37:08.000000000 +0900
@@ -9,10 +9,20 @@
 extern "C" {
 #include "../it9175.h"
 #include "../tsthread.h"
+#include "../tsbuff.h"
 }
 
-class CBonTuner : public IBonDriver2
+#include "../bonhybrid.h"
+
+namespace FSUSB2i {
+
+class CBonTuner : public CBonFSHybrid
 {
+protected:
+	const TCHAR *RegName() ;
+	int UserDecidedDeviceIdx() ;
+	void LoadValues(const IValueLoader *Loader) ;
+
 public:
 	CBonTuner();
 	virtual ~CBonTuner();
@@ -21,47 +31,30 @@
 	const BOOL OpenTuner(void);
 	void CloseTuner(void);
 
-	const BOOL SetChannel(const BYTE bCh);
 	const float GetSignalLevel(void);
 
-	const DWORD WaitTsStream(const DWORD dwTimeOut = 0);
-	const DWORD GetReadyCount(void);
-
-	const BOOL GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain);
-	const BOOL GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain);
-
-	void PurgeTsStream(void);
-
 //# IBonDriver2
 	LPCTSTR GetTunerName(void);
 
 	const BOOL IsTunerOpening(void);
-	
-	LPCTSTR EnumTuningSpace(const DWORD dwSpace);
-	LPCTSTR EnumChannelName(const DWORD dwSpace, const DWORD dwChannel);
 
 	const BOOL SetChannel(const DWORD dwSpace, const DWORD dwChannel);
-	
+
 	const DWORD GetCurSpace(void);
 	const DWORD GetCurChannel(void);
 
 	void Release(void);
 
-	static CBonTuner * m_pThis;
-	static HINSTANCE m_hModule;
-
 protected:
 	DWORD m_dwCurSpace;
 	DWORD m_dwCurChannel;
-	DWORD *m_ChannelList;
 
 	HANDLE m_hDev;
 	HANDLE m_hUsbDev;
 	struct usb_endpoint_st  m_USBEP;
 	it9175_state pDev;
-	tsthread_ptr tsthr;
 
-	bool LoadData ();
-	void ReadRegMode (HKEY hPKey);
-	void ReadRegChannels (HKEY hPKey);
 };
+
+} // End of namespace FSUSB2i
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/dllmain.cpp BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/dllmain.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/dllmain.cpp	2015-12-09 05:06:04.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/dllmain.cpp	2020-01-07 03:20:04.000000000 +0900
@@ -1,5 +1,7 @@
 #include "stdafx.h"
-#include "BonTuner.h"
+#include "BonTuner_FSUSB2i.h"
+
+using namespace FSUSB2i;
 
 BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )
 {
@@ -13,3 +15,9 @@
 	}
 	return TRUE;
 }
+
+#pragma warning( disable : 4273 )
+extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
+{return BonFSCreate<CBonTuner>();}
+#pragma warning( default : 4273 )
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/stdafx.h BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/stdafx.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_FSUSB2i/stdafx.h	2015-12-30 16:04:20.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_FSUSB2i/stdafx.h	2018-02-05 00:52:30.000000000 +0900
@@ -4,3 +4,6 @@
 #include <windows.h>
 
 #include "../message.h"
+
+#include "../twindbg.h"
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver.rc BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver.rc
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver.rc	2016-02-18 20:22:18.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver.rc	2020-10-12 00:45:18.000000000 +0900
@@ -2,8 +2,8 @@
 
 LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT
 1 VERSIONINFO
- FILEVERSION 0,1,3,1
- PRODUCTVERSION 0,1,3,1
+ FILEVERSION 0,2020,10,12
+ PRODUCTVERSION 0,2020,10,12
  FILEFLAGSMASK 0x17L
 #ifdef _DEBUG
  FILEFLAGS 0x1L
@@ -18,15 +18,21 @@
     BEGIN
         BLOCK "041104b0"
         BEGIN
-            VALUE "CompanyName", "trinity19683"
+            VALUE "CompanyName", "hyrolean-dtv inspired by trinity19683"
+            VALUE "FileVersion", "0,2020,10,12"
+#ifdef INCLUDE_ISOCH_XFER
+            VALUE "FileDescription", "BonDriver for uSUNpTV (isoch support)"
+            VALUE "InternalName", "BonDriver_uSUNpTV_isoch.dll"
+            VALUE "OriginalFilename", "BonDriver_uSUNpTV_isoch.dll"
+            VALUE "ProductName", "BonDriver_uSUNpTV_isoch"
+#else
             VALUE "FileDescription", "BonDriver for uSUNpTV"
-//            VALUE "FileDescription", "BonDriver for uSUNpTV (isoch support)"
-            VALUE "FileVersion", "0,1,3,1"
             VALUE "InternalName", "BonDriver_uSUNpTV.dll"
-            VALUE "LegalCopyright", "trinity19683 2016"
             VALUE "OriginalFilename", "BonDriver_uSUNpTV.dll"
             VALUE "ProductName", "BonDriver_uSUNpTV"
-            VALUE "ProductVersion", "0,1,3,1"
+#endif
+            VALUE "LegalCopyright", "hyrolean-dtv 2019-2020 inspired by trinity19683 2016"
+            VALUE "ProductVersion", "0,2020,10,12"
         END
     END
     BLOCK "VarFileInfo"
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcproj BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcproj	2020-10-02 05:27:42.000000000 +0900
@@ -0,0 +1,1045 @@
+<?xml version="1.0" encoding="shift_jis"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="9.00"
+	Name="BonDriver_uSUNpTV"
+	ProjectGUID="{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}"
+	RootNamespace="BonDriver_uSUNpTV"
+	Keyword="Win32Proj"
+	TargetFrameworkVersion="196613"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+		<Platform
+			Name="x64"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_uSUNpTV.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="3"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_uSUNpTV_x64.dll"
+				LinkIncremental="2"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="true"
+				SubSystem="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_uSUNpTV.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|x64"
+			OutputDirectory="$(SolutionDir)..\vs2008"
+			IntermediateDirectory="$(SolutionDir)..\_intermediate_\vs2008\$(ProjectName)\$(PlatformName)\$(ConfigurationName)"
+			ConfigurationType="2"
+			CharacterSet="1"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TargetEnvironment="3"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				EnableIntrinsicFunctions="true"
+				AdditionalIncludeDirectories="../inc;../inc/legacy"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;BONDRIVER_EXPORTS;LEGACY_STDINT"
+				RuntimeLibrary="2"
+				BufferSecurityCheck="false"
+				EnableFunctionLevelLinking="true"
+				UsePrecompiledHeader="2"
+				WarningLevel="3"
+				DebugInformationFormat="3"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winusb.lib setupapi.lib"
+				OutputFile="$(OutDir)\BonDriver_uSUNpTV_x64.dll"
+				LinkIncremental="1"
+				AdditionalLibraryDirectories="../lib64"
+				GenerateDebugInformation="false"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="17"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="\[X t@C"
+			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
+			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
+			>
+			<File
+				RelativePath="..\bonhybrid.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\BonTuner_uSUNpTV.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\dllmain.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+						CompileAsManaged="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\em287x.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\em287x_usb.c"
+				>
+			</File>
+			<File
+				RelativePath="..\message.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\mxl136.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\osdepend.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\pryutil.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath=".\stdafx2.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="1"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tc90522.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tda20142.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="0"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\tsthread.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.cpp"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderFile="$(IntDir)\$(TargetName)2.pch"
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="..\usbops.c"
+				>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+						PrecompiledHeaderThrough="StdAfx.h"
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Release|x64"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						UsePrecompiledHeader="2"
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="wb_[ t@C"
+			Filter="h;hpp;hxx;hm;inl;inc;xsd"
+			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
+			>
+			<File
+				RelativePath="..\bonhybrid.h"
+				>
+			</File>
+			<File
+				RelativePath=".\BonTuner_uSUNpTV.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x_priv.h"
+				>
+			</File>
+			<File
+				RelativePath="..\em287x_usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\IBonDriver2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\message.h"
+				>
+			</File>
+			<File
+				RelativePath="..\mxl136.h"
+				>
+			</File>
+			<File
+				RelativePath="..\osdepend.h"
+				>
+			</File>
+			<File
+				RelativePath="..\pryutil.h"
+				>
+			</File>
+			<File
+				RelativePath=".\stdafx.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\stdint_.h"
+				>
+			</File>
+			<File
+				RelativePath="..\targetver.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tc90522.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tda20142.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsbuff.h"
+				>
+			</File>
+			<File
+				RelativePath="..\tsthread.h"
+				>
+			</File>
+			<File
+				RelativePath="..\twindbg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\types_u.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb100.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\usb200.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbdevfile.h"
+				>
+			</File>
+			<File
+				RelativePath="..\usbops.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusb.h"
+				>
+			</File>
+			<File
+				RelativePath="..\inc\winusbio.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="\[X t@C"
+			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
+			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
+			>
+			<File
+				RelativePath=".\BonDriver.rc"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj	2016-02-02 02:27:20.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj	2020-10-02 03:36:48.000000000 +0900
@@ -1,5 +1,5 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Debug|Win32">
       <Configuration>Debug</Configuration>
@@ -22,6 +22,8 @@
     <ProjectGuid>{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>uSUNpTV</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+    <ProjectName>BonDriver_uSUNpTV</ProjectName>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Label="Configuration">
@@ -36,7 +38,13 @@
     <WholeProgramOptimization>true</WholeProgramOptimization>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='x64'" Label="Configuration">
-    <PlatformToolset>Windows7.1SDK</PlatformToolset>
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
@@ -65,10 +73,28 @@
     <LinkIncremental>false</LinkIncremental>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='Win32'">
-    <LibraryPath>..\lib;$(LibraryPath)</LibraryPath>
+    <LibraryPath>$(LibraryPath)</LibraryPath>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Platform)'=='x64'">
-    <LibraryPath>..\lib64;$(LibraryPath)</LibraryPath>
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
   </PropertyGroup>
   <ItemDefinitionGroup>
     <ClCompile>
@@ -123,6 +149,7 @@
     </ClCompile>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClInclude Include="..\bonhybrid.h" />
     <ClInclude Include="..\em287x.h" />
     <ClInclude Include="..\em287x_priv.h" />
     <ClInclude Include="..\em287x_usb.h" />
@@ -134,13 +161,21 @@
     <ClInclude Include="..\tda20142.h" />
     <ClInclude Include="..\tsbuff.h" />
     <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
     <ClInclude Include="..\types_u.h" />
     <ClInclude Include="..\usbdevfile.h" />
     <ClInclude Include="..\usbops.h" />
-    <ClInclude Include="BonTuner.h" />
+    <ClInclude Include="BonTuner_uSUNpTV.h" />
+    <ClInclude Include="..\pryutil.h" />
     <ClInclude Include="stdafx.h" />
   </ItemGroup>
   <ItemGroup>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="..\em287x.c">
       <PrecompiledHeader>NotUsing</PrecompiledHeader>
     </ClCompile>
@@ -161,12 +196,15 @@
       <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
     <ClCompile Include="..\usbops.c" />
-    <ClCompile Include="BonTuner.cpp">
+    <ClCompile Include="BonTuner_uSUNpTV.cpp">
       <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
     <ClCompile Include="dllmain.cpp">
       <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
     </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
     <ClCompile Include="stdafx.c">
       <PrecompiledHeader>Create</PrecompiledHeader>
     </ClCompile>
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj.filters BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj.filters
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj.filters	2016-02-02 02:27:14.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV.vcxproj.filters	2019-12-31 18:11:54.000000000 +0900
@@ -21,9 +21,6 @@
     <ClInclude Include="..\targetver.h">
       <Filter>ヘッダー ファイル</Filter>
     </ClInclude>
-    <ClInclude Include="BonTuner.h">
-      <Filter>ヘッダー ファイル</Filter>
-    </ClInclude>
     <ClInclude Include="..\tsthread.h">
       <Filter>ヘッダー ファイル</Filter>
     </ClInclude>
@@ -63,11 +60,20 @@
     <ClInclude Include="..\mxl136.h">
       <Filter>ヘッダー ファイル</Filter>
     </ClInclude>
+    <ClInclude Include="..\twindbg.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="BonTuner_uSUNpTV.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\pryutil.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\bonhybrid.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
-    <ClCompile Include="BonTuner.cpp">
-      <Filter>ソース ファイル</Filter>
-    </ClCompile>
     <ClCompile Include="..\tsthread.c">
       <Filter>ソース ファイル</Filter>
     </ClCompile>
@@ -107,6 +113,15 @@
     <ClCompile Include="..\mxl136.c">
       <Filter>ソース ファイル</Filter>
     </ClCompile>
+    <ClCompile Include="BonTuner_uSUNpTV.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="BonDriver.rc">
BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTVȯ: BonDriver_uSUNpTV.vcxproj.user
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj	2020-10-11 01:59:04.000000000 +0900
@@ -0,0 +1,234 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{264FED43-93BD-4D55-B545-DD16668B7BB7}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>uSUNpTV</RootNamespace>
+    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+    <ProjectName>BonDriver_uSUNpTV_isoch</ProjectName>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'" Label="Configuration">
+    <UseDebugLibraries>true</UseDebugLibraries>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'" Label="Configuration">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <PlatformToolset>v140</PlatformToolset>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <EmbedManifest>false</EmbedManifest>
+    <IncludePath>..\inc;$(IncludePath)</IncludePath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Debug'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)'=='Release'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='Win32'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Platform)'=='x64'">
+    <LibraryPath>$(LibraryPath)</LibraryPath>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\</OutDir>
+    <TargetName>$(ProjectName)_$(Platform)</TargetName>
+    <IntDir>$(SolutionDir)..\_intermediate_\$(ProjectName)\$(Platform)\$(Configuration)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <AdditionalDependencies>winusb.lib;setupapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
+    <ClCompile>
+      <Optimization>Disabled</Optimization>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
+    <ClCompile>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>false</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;_DEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PreprocessorDefinitions>WIN32;INCLUDE_ISOCH_XFER;NDEBUG;_WINDOWS;_USRDLL;FSUSB2N_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>INCLUDE_ISOCH_XFER;_UNICODE;UNICODE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="..\bonhybrid.h" />
+    <ClInclude Include="..\em287x.h" />
+    <ClInclude Include="..\em287x_priv.h" />
+    <ClInclude Include="..\em287x_usb.h" />
+    <ClInclude Include="..\message.h" />
+    <ClInclude Include="..\mxl136.h" />
+    <ClInclude Include="..\targetver.h" />
+    <ClInclude Include="..\osdepend.h" />
+    <ClInclude Include="..\tc90522.h" />
+    <ClInclude Include="..\tda20142.h" />
+    <ClInclude Include="..\tsbuff.h" />
+    <ClInclude Include="..\tsthread.h" />
+    <ClInclude Include="..\twindbg.h" />
+    <ClInclude Include="..\types_u.h" />
+    <ClInclude Include="..\usbdevfile.h" />
+    <ClInclude Include="..\usbops.h" />
+    <ClInclude Include="BonTuner_uSUNpTV.h" />
+    <ClInclude Include="..\pryutil.h" />
+    <ClInclude Include="stdafx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\em287x.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\em287x_usb.c" />
+    <ClCompile Include="..\message.c" />
+    <ClCompile Include="..\mxl136.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c" />
+    <ClCompile Include="..\tc90522.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tda20142.c">
+      <PrecompiledHeader>NotUsing</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="..\tsthread.c" />
+    <ClCompile Include="..\usbdevfile.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\usbops.c" />
+    <ClCompile Include="BonTuner_uSUNpTV.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="dllmain.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+    <ClCompile Include="stdafx.c">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="stdafx2.cpp">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+      <PrecompiledHeaderOutputFile>$(IntDir)$(TargetName)pp.pch</PrecompiledHeaderOutputFile>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj.filters BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj.filters
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj.filters	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonDriver_uSUNpTV_isoch.vcxproj.filters	2019-12-31 18:11:54.000000000 +0900
@@ -0,0 +1,131 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="ソース ファイル">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="ヘッダー ファイル">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="リソース ファイル">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="stdafx.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\targetver.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\tsthread.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\types_u.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\usbdevfile.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\usbops.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\message.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\osdepend.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\tsbuff.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\em287x_priv.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\em287x_usb.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\em287x.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\tc90522.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\tda20142.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\mxl136.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\twindbg.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="BonTuner_uSUNpTV.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\pryutil.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+    <ClInclude Include="..\bonhybrid.h">
+      <Filter>ヘッダー ファイル</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\tsthread.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\usbops.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\usbdevfile.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="stdafx2.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="stdafx.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\message.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\osdepend.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="dllmain.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\em287x.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\em287x_usb.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\tc90522.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\tda20142.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\mxl136.c">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="BonTuner_uSUNpTV.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\pryutil.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+    <ClCompile Include="..\bonhybrid.cpp">
+      <Filter>ソース ファイル</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="BonDriver.rc">
+      <Filter>リソース ファイル</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.cpp BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.cpp	2016-02-10 06:01:58.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.cpp	2020-10-04 01:12:18.000000000 +0900
@@ -3,10 +3,10 @@
   BonTuner.cpp
   2016-02-10
 */
-
 #include "stdafx.h"
+
 #include <tchar.h>
-#include "BonTuner.h"
+#include "BonTuner_uSUNpTV.h"
 #include "../usbdevfile.h"
 extern "C" {
 #include "../tc90522.h"
@@ -14,34 +14,45 @@
 #include "../mxl136.h"
 }
 
-#pragma warning( disable : 4273 )
-extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
-{ return (CBonTuner::m_pThis)? CBonTuner::m_pThis : ((IBonDriver *) new CBonTuner); }
-#pragma warning( default : 4273 )
-
-//# initialize static member variables
-CBonTuner * CBonTuner::m_pThis = NULL;
-HINSTANCE CBonTuner::m_hModule = NULL;
+using namespace std ;
+
+namespace uSUNpTV {
+
+DWORD USUNPTV_SETSFREQ_TIMES  = 1   ;
+DWORD USUNPTV_SETSTSID_TIMES  = 2   ;
+DWORD USUNPTV_SETTFREQ_TIMES  = 1   ;
+DWORD USUNPTV_SETSLOCK_WAIT   = 10  ;
+DWORD USUNPTV_SETSTSID_WAIT   = 800 ;
+DWORD USUNPTV_CHANNEL_WAIT    = 480 ;
+BOOL  USUNPTV_LOCK_ON_SIGNAL  = TRUE;
 
 const TCHAR* const g_RegKey = TEXT("Software\\trinity19683\\FSUSB2i");
 
 CBonTuner::CBonTuner()
-: m_dwCurSpace(123), m_dwCurChannel(0), m_hDev(NULL), m_hUsbDev(NULL), pDev(NULL), demodDev(NULL), m_selectedTuner(-1), tsthr(NULL),
- m_ChannelList(NULL)
+: CBonFSHybrid(true), m_dwCurSpace(123), m_dwCurChannel(0), m_hasStream(FALSE),
+ m_hDev(NULL), m_hUsbDev(NULL),pDev(NULL), demodDev(NULL), m_selectedTuner(-1),
+ m_chCur()
 {
-	int i;
-	m_pThis = this;
-	for(i = 0; i < 2; i++ ) {
-		tunerDev[i] = NULL;
-	}
+	fill_n(tunerDev, 2, (void*)NULL);
 }
 
 CBonTuner::~CBonTuner()
 {
 	CloseTuner();
+}
+
+const TCHAR *CBonTuner::RegName()
+{
+	return g_RegKey ;
+}
 
-	if(m_ChannelList != NULL) ::GlobalFree(m_ChannelList);
-	m_pThis = NULL;
+int CBonTuner::UserDecidedDeviceIdx()
+{
+	int idx=0 ;
+	if(sscanf_s( upper_case(file_prefix_of(ModuleFileName())).c_str() , "BONDRIVER_USUNPTV_DEV%d", &idx )==1)
+	  return idx ;
+
+	return -1 ;
 }
 
 const BOOL CBonTuner::OpenTuner()
@@ -52,66 +63,40 @@
 
 	try{
 		//# AllocTuner
-		for(unsigned int idx = 0; idx < 40;) {
-			HANDLE hDev;
-			if((hDev = usbdevfile_alloc(&idx) ) == NULL) {   //# not found
-				throw (const DWORD)__LINE__;
-			}
-			//# found
-			m_hDev = hDev;
-			if((hDev = usbdevfile_init(m_hDev) ) == NULL) {   //# failed
-				throw (const DWORD)__LINE__;
-			}
-			m_hUsbDev = hDev;
-			break;
+		if(!FindDevice(GUID_WINUSB_US3POUT_DRV,m_hDev,m_hUsbDev)) {
+		  if(m_hDev==NULL) throw (const DWORD)__LINE__;
+		  if(m_hUsbDev==NULL) throw (const DWORD)__LINE__;
 		}
 		//# device initialize
 		m_USBEP.fd = m_hUsbDev;
-		if( em287x_create(&pDev, &m_USBEP) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( em287x_create(&pDev, &m_USBEP) ) throw (const DWORD)__LINE__;
 		struct i2c_device_st* pI2C;
 		//# demod
-		if( tc90522_create(&demodDev) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( tc90522_create(&demodDev) ) throw (const DWORD)__LINE__;
 		pI2C = (struct i2c_device_st*)tc90522_i2c_ptr(demodDev);
 		pI2C->addr = 0x20;
 		em287x_attach(pDev, pI2C);
-		if( tc90522_init(demodDev) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( tc90522_init(demodDev) ) throw (const DWORD)__LINE__;
 		//# tuner 0 terra
-		if( mxl136_create(&tunerDev[0]) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( mxl136_create(&tunerDev[0]) ) throw (const DWORD)__LINE__;
 		pI2C = (struct i2c_device_st*)mxl136_i2c_ptr(tunerDev[0]);
 		pI2C->addr = 0xc0;
 		tc90522_attach(demodDev, 0, pI2C);
-		if( mxl136_init(tunerDev[0]) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( mxl136_init(tunerDev[0]) ) throw (const DWORD)__LINE__;
 		//# tuner 1 BS/CS
-		if( tda20142_create(&tunerDev[1]) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( tda20142_create(&tunerDev[1]) ) throw (const DWORD)__LINE__;
 		pI2C = (struct i2c_device_st*)tda20142_i2c_ptr(tunerDev[1]);
 		pI2C->addr = 0xa8;
 		tc90522_attach(demodDev, 1, pI2C);
-		if( tda20142_init(tunerDev[1]) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( tda20142_init(tunerDev[1]) ) throw (const DWORD)__LINE__;
 		//# demod set params
-		if( tc90522_selectDevice(demodDev, 1) ) {
-			throw (const DWORD)__LINE__;
-		}
-		//# TS receive thread
-		if( tsthread_create(&tsthr, &m_USBEP) ) {
-			throw (const DWORD)__LINE__;
-		}
+		if( tc90522_selectDevice(demodDev, 1) ) throw (const DWORD)__LINE__;
+		//# fifo
+		if(!FifoInitialize(&m_USBEP)) throw (const DWORD)__LINE__;
 
 		//# device has been ready.
-		LoadData();
+
+		DBGOUT("-*- device has been ready -*-\n") ;
 	}
 	catch (const DWORD dwErrorStep) {
 		//# Error
@@ -125,11 +110,7 @@
 
 void CBonTuner::CloseTuner()
 {
-	if(tsthr) {
-		tsthread_stop(tsthr);
-		tsthread_destroy(tsthr);
-		tsthr = NULL;
-	}
+	FifoFinalize() ;
 	if(tunerDev[0]) {
 		mxl136_destroy(tunerDev[0]);
 		tunerDev[0] = NULL;
@@ -146,153 +127,59 @@
 		em287x_destroy(pDev);
 		pDev = NULL;
 	}
-	if(m_hUsbDev) {
-		usbdevfile_free(m_hUsbDev);
-		m_hUsbDev = NULL;
-	}
-	if(m_hDev) {
-		::CloseHandle( m_hDev );
-		m_hDev = NULL;
-	}
-}
-
-const BOOL CBonTuner::SetChannel(const BYTE bCh)
-{
-	//# compatible with IBonDriver
-	if(bCh < 13 || bCh > 52) return FALSE;
-	else return SetChannel(0, bCh - 13);
+	FreeDevice(m_hDev,m_hUsbDev);
+	m_USBEP.dev=NULL;
+	m_chCur = CHANNEL();
 }
 
 const float CBonTuner::GetSignalLevel(void)
 {
 	if(0 > m_selectedTuner || (! demodDev) ) return -3.1f;
+	if(!m_hasStream) return 0.f ;
 	unsigned statData[4];
-	if(tc90522_readStatistic(demodDev, m_selectedTuner, statData) ) return -3.2f;
-	return statData[1] * 0.01f;
-}
-
-const DWORD CBonTuner::WaitTsStream(const DWORD dwTimeOut)
-{
-	const int remainTime = (dwTimeOut < 0x10000000) ? dwTimeOut : 0x10000000;
-	if(! tsthr) return WAIT_FAILED;
+	float lv ;
 
-	const int r = tsthread_wait(tsthr, remainTime);
-	if(0 > r)  return WAIT_FAILED;
-	else if(0 < r)  return WAIT_OBJECT_0;
-	else  return WAIT_TIMEOUT;
-}
+	const bool do_locking = USUNPTV_LOCK_ON_SIGNAL && m_USBEP.dev && m_USBEP.lockunlockFunc ;
 
-const DWORD CBonTuner::GetReadyCount()
-{//# number of call GetTsStream()
-	if(! tsthr) return 0;
-	const int ret = tsthread_readable(tsthr);
-	return (ret > 0) ? 1 : 0;
-}
+	if(do_locking) //# lock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,1);
 
-const BOOL CBonTuner::GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	BYTE *pSrc = NULL;
-	if(GetTsStream(&pSrc, pdwSize, pdwRemain)){
-		if(*pdwSize) ::CopyMemory(pDst, pSrc, *pdwSize);
-		return TRUE;
-	}
-	return FALSE;
-}
+	if(tc90522_readStatistic(demodDev, m_selectedTuner, statData) )
+		lv = -3.2f;
+	else
+		lv = statData[1] * 0.01f;
 
-const BOOL CBonTuner::GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain)
-{
-	if(! tsthr) return FALSE;
-	const int ret = tsthread_readable(tsthr);
-	if(ret <= 0) {
-		//# no readable data
-		*pdwSize = 0;
-		*pdwRemain = 0;
-		return TRUE;
-	}
-	*pdwSize = tsthread_read(tsthr, (void**)ppDst);
-	*pdwRemain = GetReadyCount();
-	//dmsg("GetTsStream(%p,%u,%u)", ppDst, *pdwSize, *pdwRemain);
-	return TRUE;
-}
+	if(do_locking) //# unlock
+		m_USBEP.lockunlockFunc(m_USBEP.dev,0);
 
-void CBonTuner::PurgeTsStream()
-{
-	if(! tsthr) return;
-	//# purge available data in TS buffer
-	tsthread_read(tsthr, NULL);
+	return lv ;
 }
 
 void CBonTuner::Release()  //# release the instance
 { delete this; }
 
 LPCTSTR CBonTuner::GetTunerName(void)
-{ return TEXT("U"); }
+{ return TEXT("uSUNpTV"); }
 
 const BOOL CBonTuner::IsTunerOpening(void)
 { return m_hUsbDev ? TRUE : FALSE; }
 
-LPCTSTR CBonTuner::EnumTuningSpace(const DWORD dwSpace)
-{
-	if(0 == dwSpace)  return TEXT("nfW");
-	else if(1 == dwSpace)  return TEXT("BS");
-	else if(2 == dwSpace)  return TEXT("CS");
-	return NULL;
-}
-
-LPCTSTR CBonTuner::EnumChannelName(const DWORD dwSpace, const DWORD dwChannel)
-{
-	static TCHAR buf[6];
-	if(0 == dwSpace) {
-		if(m_ChannelList != NULL) {
-			//# User-defined channels
-			const DWORD dwChannelLen    = m_ChannelList[0] >> 16;
-			const DWORD dwNumOfChannels = m_ChannelList[0] & 0xFFFF;
-			TCHAR* const ptrStr = (TCHAR*)(m_ChannelList + dwNumOfChannels + 1);
-			if(dwChannel < dwNumOfChannels)	return ptrStr + (dwChannelLen * dwChannel);
-		}else if(dwChannel < 40) {
-			_sntprintf_s(buf, sizeof(buf)/sizeof(TCHAR), _TRUNCATE, TEXT("%u"), dwChannel + 13);
-			return buf;    //# The caller must copy data from this buffer.
-		}
-	}else if(1 == dwSpace && dwChannel < 12 * 8) {
-		_sntprintf_s(buf, sizeof(buf)/sizeof(TCHAR), _TRUNCATE, TEXT("%02u.%u"), (dwChannel >> 3)*2 + 1, dwChannel & 0x7);
-		return buf;
-	}else if(2 == dwSpace && dwChannel < 12 * 8) {
-		_sntprintf_s(buf, sizeof(buf)/sizeof(TCHAR), _TRUNCATE, TEXT("%02u.%u"), (dwChannel >> 3)*2 + 2, dwChannel & 0x7);
-		return buf;
-	}
-	return NULL;
-}
-
 const BOOL CBonTuner::SetChannel(const DWORD dwSpace, const DWORD dwChannel)
 {
-	DWORD dwFreq = 0;
 	int tunerNum = 0;
-	bool hasStream = TRUE;
+	BOOL hasStream = TRUE;
 
-	if(0 == dwSpace) {
-		if(m_ChannelList != NULL) {  //# User-defined channels
-			const DWORD dwNumOfChannels = m_ChannelList[0] & 0xFFFF;
-			if(dwChannel < dwNumOfChannels)
-				dwFreq = m_ChannelList[dwChannel + 1];
-		}else{  //# UHF standard channels
-			if(dwChannel < 40)
-				dwFreq = dwChannel * 6000 + 473143;
-		}
-	}else if(1 == dwSpace && dwChannel < 12 * 8) {
-		dwFreq = (dwChannel >> 3) * 38360 + 1049480;
-	}else if(2 == dwSpace && dwChannel < 12 * 8) {
-		dwFreq = (dwChannel >> 3) * 40000 + 1613000;
-	}else if(dwSpace == 114514) {  //# dwChannel as freq/kHz
-		dwFreq = dwChannel;
-	}
-	if(dwFreq < 60000 || dwFreq > 2456123 ) {
+	CHANNEL ch = GetChannel(dwSpace,dwChannel) ;
+
+	if(ch.Band==BAND_na || ch.Freq < 60000 || ch.Freq > 2456123 ) {
 		warn_msg(0,"BonDriver_uSUNpTV:SetChannel(%u,%u) invalid!", dwSpace, dwChannel);
 		return FALSE;
 	}
-	if( dwFreq >= 900000 ) tunerNum = 1;
+	if( ch.Freq >= 900000 ) tunerNum = 1;
 
 	//# change channel
-	if(tsthr) tsthread_stop(tsthr);
+	m_hasStream=FALSE ;
+	FifoStop() ;
 
 	if(tunerNum != m_selectedTuner) {
 		if( tc90522_selectDevice(demodDev, tunerNum) ) return FALSE;
@@ -300,45 +187,68 @@
 			mxl136_sleep(tunerDev[0]);
 		}else{
 			mxl136_wakeup(tunerDev[0]);
+			::Sleep( 30 );
 		}
 	}
 	if(tunerNum & 0x1) {
-		if( m_selectedTuner != tunerNum || (m_dwCurChannel ^ dwChannel) >> 3 ) {
-			if( tda20142_setFreq(tunerDev[1], dwFreq) ) return FALSE;
+		for(DWORD n=USUNPTV_SETSFREQ_TIMES;n;n--)
+		if( m_chCur.Band!=ch.Band || m_chCur.Freq != ch.Freq ) {
+			unsigned fail=0 ;
+			if( tda20142_setFreq(tunerDev[1], ch.Freq) ) fail++ ;
 			::Sleep( 30 );
-			if( tc90522_resetDemod(demodDev, tunerNum ) ) return FALSE;
-			::Sleep( 50 );
-		}
-		DWORD dwTime = ::GetTickCount() + 800;
-		hasStream = FALSE;
-		do {
-			int ret = tc90522_selectStream(demodDev, tunerNum, dwChannel & 0x7 );
-			if(0 == ret) {
-				hasStream = TRUE;
-				break;
-			}else if(0 > ret)  return FALSE;
-			::Sleep( 40 );
-		} while( (int)(dwTime - ::GetTickCount()) > 0);
-	}else{
-		if( mxl136_setFreq(tunerDev[0], dwFreq) ) return FALSE;
+			if( !fail && tc90522_resetDemod(demodDev, tunerNum ) ) fail++ ;
+			if(n>1) ::Sleep( 50 );
+			if(fail&&n==1) return FALSE;
+		}
+		for(DWORD n=USUNPTV_SETSTSID_TIMES;n;n--) {
+			hasStream = FALSE;
+			unsigned fail=0, lock=0 ;
+			for(DWORD e=0,s=Elapsed();USUNPTV_SETSTSID_WAIT>e;e=Elapsed(s)) {
+				int ret ;
+				if(!lock) {
+					unsigned data[2] ;
+					ret =tc90522_readStatistic(demodDev, tunerNum, data);
+					if(0 == ret) {
+						lock = data[0]&0x10 ;  //# check lock bit
+						if(lock) ::Sleep(USUNPTV_SETSLOCK_WAIT) ;
+					}
+				}else {
+					if(ch.TSID>0)
+						ret = tc90522_setTSID(demodDev, tunerNum, ch.TSID );
+					else
+						ret = tc90522_selectStream(demodDev, tunerNum, ch.Stream );
+					if(0 == ret) { hasStream = TRUE; break; }
+					else if(0 > ret) fail++ ;
+				}
+				::Sleep( 40 );
+			}
+			if(n>1&&hasStream)
+				::Sleep( 40 );
+			if(fail&&n==1) return FALSE;
+		}
+	}else for(DWORD n=USUNPTV_SETTFREQ_TIMES;n;n--) {
+		unsigned fail=0 ;
+		if( mxl136_setFreq(tunerDev[0], ch.Freq) ) fail++ ;
 		::Sleep( 30 );
-		if( tc90522_resetDemod(demodDev, tunerNum ) ) return FALSE;
+		if( !fail && tc90522_resetDemod(demodDev, tunerNum ) ) fail++ ;
 		::Sleep( 50 );
+		if(fail&&n==1) return FALSE;
 	}
 	//# set variables
 	m_dwCurSpace = dwSpace;
 	m_dwCurChannel = dwChannel;
+	m_hasStream = hasStream ;
 	m_selectedTuner = tunerNum;
+	m_chCur = ch ;
 
-	if(tsthr && hasStream) tsthread_start(tsthr);
+	if(hasStream) FifoStart() ;
 
-	DWORD dwTime = ::GetTickCount() + 480;
-	do {
+	for(DWORD e=0,s=Elapsed();USUNPTV_CHANNEL_WAIT>e;e=Elapsed(s)) {
 		unsigned statData[4];
 		::Sleep( 40 );
 		if( tc90522_readStatistic(demodDev, tunerNum, statData) ) continue;
 		if( statData[0] & 0x10 ) break;
-	} while( (int)(dwTime - ::GetTickCount()) > 0);
+	}
 
 	PurgeTsStream();
 
@@ -351,63 +261,20 @@
 const DWORD CBonTuner::GetCurChannel(void)
 { return m_dwCurChannel; }
 
-
-bool CBonTuner::LoadData ()
+void CBonTuner::LoadValues(const IValueLoader *Loader)
 {
-	HKEY hKey;
-
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, g_RegKey, 0, KEY_READ, &hKey)) {
-		//ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, g_RegKey, 0, KEY_READ, &hKey)) {
-		//ReadRegMode(hKey);
-		ReadRegChannels(hKey);
-		RegCloseKey(hKey);
-	}
-
-	return true;
+	CBonFSHybrid::LoadValues (Loader) ;
+	#define LOADDW(val) do { val = Loader->ReadDWORD(L#val,val); } while(0)
+	LOADDW(USUNPTV_SETSFREQ_TIMES);
+	LOADDW(USUNPTV_SETSTSID_TIMES);
+	LOADDW(USUNPTV_SETTFREQ_TIMES);
+	LOADDW(USUNPTV_SETSLOCK_WAIT);
+	LOADDW(USUNPTV_SETSTSID_WAIT);
+	LOADDW(USUNPTV_CHANNEL_WAIT);
+    LOADDW(USUNPTV_LOCK_ON_SIGNAL);
+	#undef LOADDW
 }
 
-void CBonTuner::ReadRegMode (HKEY hPKey)
-{ return; }
-
-void CBonTuner::ReadRegChannels (HKEY hPKey)
-{
-	if(m_ChannelList != NULL) return;
-
-	HKEY hKey;
-	DWORD NumOfValues;
-	TCHAR szValueName[32];
-	DWORD dwValue, dwLen, dwType, dwByte, dwMaxValueName;
-	if(ERROR_SUCCESS != RegOpenKeyEx( hPKey, TEXT("Channels"), 0, KEY_READ, &hKey)) {
-		return;
-	}
-	if(ERROR_SUCCESS != RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumOfValues, &dwMaxValueName, NULL, NULL, NULL)) {
-		RegCloseKey(hKey);
-		return;
-	}
-	dwMaxValueName++;
-	m_ChannelList = (DWORD*) ::GlobalAlloc(GMEM_FIXED, NumOfValues * (dwMaxValueName * sizeof(TCHAR) + sizeof(DWORD)) + sizeof(DWORD) );
-	m_ChannelList[0] = dwMaxValueName << 16 | NumOfValues;
-	ZeroMemory( m_ChannelList + 1, sizeof(DWORD) * NumOfValues );
-	TCHAR *ptrStr;
-	for(DWORD dwIdx = 0; dwIdx < NumOfValues; dwIdx++ ) {
-		dwLen = 32;
-		dwByte = sizeof(dwValue);
-		if(ERROR_SUCCESS != RegEnumValue( hKey, dwIdx, szValueName, &dwLen, NULL, &dwType, (BYTE*)&dwValue, &dwByte)
-			|| dwByte != sizeof(DWORD)) {
-			break;
-		}
-		dwByte = dwValue >> 24; //# Index
-		if( dwByte >= NumOfValues ) continue;
-		m_ChannelList[dwByte + 1] = dwValue & 0x00ffffff;
-		ptrStr = (TCHAR*)(m_ChannelList + NumOfValues + 1);
-		ptrStr += dwMaxValueName * dwByte;
-		lstrcpyn( ptrStr, szValueName, dwMaxValueName );
-	}
-	RegCloseKey(hKey);
-}
+} // End of namespace uSUNpTV
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.h BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.h	2016-01-23 15:23:50.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/BonTuner_uSUNpTV.h	2020-01-10 18:47:22.000000000 +0900
@@ -9,10 +9,20 @@
 extern "C" {
 #include "../em287x.h"
 #include "../tsthread.h"
+#include "../tsbuff.h"
 }
 
-class CBonTuner : public IBonDriver2
+#include "../bonhybrid.h"
+
+namespace uSUNpTV {
+
+class CBonTuner : public CBonFSHybrid
 {
+protected:
+	const TCHAR *RegName() ;
+	int UserDecidedDeviceIdx() ;
+	virtual void LoadValues(const IValueLoader *Loader);
+
 public:
 	CBonTuner();
 	virtual ~CBonTuner();
@@ -21,39 +31,25 @@
 	const BOOL OpenTuner(void);
 	void CloseTuner(void);
 
-	const BOOL SetChannel(const BYTE bCh);
 	const float GetSignalLevel(void);
 
-	const DWORD WaitTsStream(const DWORD dwTimeOut = 0);
-	const DWORD GetReadyCount(void);
-
-	const BOOL GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain);
-	const BOOL GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain);
-
-	void PurgeTsStream(void);
-
 //# IBonDriver2
 	LPCTSTR GetTunerName(void);
 
 	const BOOL IsTunerOpening(void);
-	
-	LPCTSTR EnumTuningSpace(const DWORD dwSpace);
-	LPCTSTR EnumChannelName(const DWORD dwSpace, const DWORD dwChannel);
 
 	const BOOL SetChannel(const DWORD dwSpace, const DWORD dwChannel);
-	
+
 	const DWORD GetCurSpace(void);
 	const DWORD GetCurChannel(void);
 
 	void Release(void);
 
-	static CBonTuner * m_pThis;
-	static HINSTANCE m_hModule;
-
 protected:
 	DWORD m_dwCurSpace;
 	DWORD m_dwCurChannel;
-	DWORD *m_ChannelList;
+    BOOL m_hasStream;
+	CHANNEL m_chCur ;
 
 	HANDLE m_hDev;
 	HANDLE m_hUsbDev;
@@ -62,9 +58,8 @@
 	void* demodDev;
 	void* tunerDev[2];
 	int m_selectedTuner;
-	tsthread_ptr tsthr;
 
-	bool LoadData ();
-	void ReadRegMode (HKEY hPKey);
-	void ReadRegChannels (HKEY hPKey);
 };
+
+} // End of namespace uSUNpTV
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/dllmain.cpp BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/dllmain.cpp
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/dllmain.cpp	2015-12-09 05:06:04.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/dllmain.cpp	2020-01-07 03:20:04.000000000 +0900
@@ -1,5 +1,7 @@
 #include "stdafx.h"
-#include "BonTuner.h"
+#include "BonTuner_uSUNpTV.h"
+
+using namespace uSUNpTV;
 
 BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved )
 {
@@ -13,3 +15,9 @@
 	}
 	return TRUE;
 }
+
+#pragma warning( disable : 4273 )
+extern "C" __declspec(dllexport) IBonDriver * CreateBonDriver()
+{return BonFSCreate<CBonTuner>();}
+#pragma warning( default : 4273 )
+
diff -uPr BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/stdafx.h BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/stdafx.h
--- BonD_FSHybrid-20201009_org/src/BonDriver_uSUNpTV/stdafx.h	2015-12-30 16:04:20.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/BonDriver_uSUNpTV/stdafx.h	2019-11-29 03:00:46.000000000 +0900
@@ -4,3 +4,5 @@
 #include <windows.h>
 
 #include "../message.h"
+
+#include "../twindbg.h"
diff -uPr BonD_FSHybrid-20201009_org/src/FSHybrid.sln BonD_FSHybrid-20201009_mod2/src/FSHybrid.sln
--- BonD_FSHybrid-20201009_org/src/FSHybrid.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/FSHybrid.sln	2019-12-20 14:56:02.000000000 +0900
@@ -0,0 +1,28 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.24720.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSHybrid", "BonDriver_FSHybrid\BonDriver_FSHybrid.vcxproj", "{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x64.ActiveCfg = Debug|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x64.Build.0 = Debug|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x86.ActiveCfg = Debug|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x86.Build.0 = Debug|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x64.ActiveCfg = Release|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x64.Build.0 = Release|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x86.ActiveCfg = Release|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSHybrid_VS2008.sln BonD_FSHybrid-20201009_mod2/src/FSHybrid_VS2008.sln
--- BonD_FSHybrid-20201009_org/src/FSHybrid_VS2008.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/FSHybrid_VS2008.sln	2019-12-20 14:50:42.000000000 +0900
@@ -0,0 +1,26 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSHybrid", "BonDriver_FSHybrid\BonDriver_FSHybrid.vcproj", "{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|Win32.ActiveCfg = Debug|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|Win32.Build.0 = Debug|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x64.ActiveCfg = Debug|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Debug|x64.Build.0 = Debug|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|Win32.ActiveCfg = Release|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|Win32.Build.0 = Release|Win32
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x64.ActiveCfg = Release|x64
+		{D71E8052-FEF4-48F1-8CC7-89CBF13A85DB}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSHybrid_isoch.sln BonD_FSHybrid-20201009_mod2/src/FSHybrid_isoch.sln
--- BonD_FSHybrid-20201009_org/src/FSHybrid_isoch.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/FSHybrid_isoch.sln	2020-10-03 19:38:34.000000000 +0900
@@ -0,0 +1,28 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.25420.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSHybrid_isoch", "BonDriver_FSHybrid\BonDriver_FSHybrid_isoch.vcxproj", "{58814608-686F-46B4-9061-B647F45A1151}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{58814608-686F-46B4-9061-B647F45A1151}.Debug|x64.ActiveCfg = Debug|x64
+		{58814608-686F-46B4-9061-B647F45A1151}.Debug|x64.Build.0 = Debug|x64
+		{58814608-686F-46B4-9061-B647F45A1151}.Debug|x86.ActiveCfg = Debug|Win32
+		{58814608-686F-46B4-9061-B647F45A1151}.Debug|x86.Build.0 = Debug|Win32
+		{58814608-686F-46B4-9061-B647F45A1151}.Release|x64.ActiveCfg = Release|x64
+		{58814608-686F-46B4-9061-B647F45A1151}.Release|x64.Build.0 = Release|x64
+		{58814608-686F-46B4-9061-B647F45A1151}.Release|x86.ActiveCfg = Release|Win32
+		{58814608-686F-46B4-9061-B647F45A1151}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSUSB2N.sln BonD_FSHybrid-20201009_mod2/src/FSUSB2N.sln
--- BonD_FSHybrid-20201009_org/src/FSUSB2N.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/FSUSB2N.sln	2019-12-16 05:04:18.000000000 +0900
@@ -0,0 +1,28 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.24720.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2N", "BonDriver_FSUSB2N\BonDriver_FSUSB2N.vcxproj", "{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x64.ActiveCfg = Debug|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x64.Build.0 = Debug|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x86.ActiveCfg = Debug|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x86.Build.0 = Debug|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x64.ActiveCfg = Release|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x64.Build.0 = Release|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x86.ActiveCfg = Release|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSUSB2N_VS2008.sln BonD_FSHybrid-20201009_mod2/src/FSUSB2N_VS2008.sln
--- BonD_FSHybrid-20201009_org/src/FSUSB2N_VS2008.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/FSUSB2N_VS2008.sln	2019-12-15 10:44:10.000000000 +0900
@@ -0,0 +1,26 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2N", "BonDriver_FSUSB2N\BonDriver_FSUSB2N.vcproj", "{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|Win32.ActiveCfg = Debug|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|Win32.Build.0 = Debug|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x64.ActiveCfg = Debug|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Debug|x64.Build.0 = Debug|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|Win32.ActiveCfg = Release|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|Win32.Build.0 = Release|Win32
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x64.ActiveCfg = Release|x64
+		{F3E364ED-5E46-4FF0-ADD1-50A4CDCA3257}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSUSB2N_isoch.sln BonD_FSHybrid-20201009_mod2/src/FSUSB2N_isoch.sln
--- BonD_FSHybrid-20201009_org/src/FSUSB2N_isoch.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/FSUSB2N_isoch.sln	2020-10-06 07:00:56.000000000 +0900
@@ -0,0 +1,28 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.25420.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2N_isoch", "BonDriver_FSUSB2N\BonDriver_FSUSB2N_isoch.vcxproj", "{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Debug|x64.ActiveCfg = Debug|x64
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Debug|x64.Build.0 = Debug|x64
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Debug|x86.ActiveCfg = Debug|Win32
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Debug|x86.Build.0 = Debug|Win32
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Release|x64.ActiveCfg = Release|x64
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Release|x64.Build.0 = Release|x64
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Release|x86.ActiveCfg = Release|Win32
+		{E58D93E0-08ED-4EAA-90E1-53A35C5BB633}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/FSUSB2i.sln BonD_FSHybrid-20201009_mod2/src/FSUSB2i.sln
--- BonD_FSHybrid-20201009_org/src/FSUSB2i.sln	2015-12-20 04:16:10.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/FSUSB2i.sln	2019-12-16 05:10:14.000000000 +0900
@@ -1,24 +1,26 @@
 ﻿
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual C++ Express 2010
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2i", "BonDriver\BonDriver_FSUSB2i.vcxproj", "{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.24720.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2i", "BonDriver_FSUSB2i\BonDriver_FSUSB2i.vcxproj", "{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Win32 = Debug|Win32
 		Debug|x64 = Debug|x64
-		Release|Win32 = Release|Win32
+		Debug|x86 = Debug|x86
 		Release|x64 = Release|x64
+		Release|x86 = Release|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|Win32.ActiveCfg = Debug|Win32
-		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|Win32.Build.0 = Debug|Win32
 		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x64.ActiveCfg = Debug|x64
 		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x64.Build.0 = Debug|x64
-		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|Win32.ActiveCfg = Release|Win32
-		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|Win32.Build.0 = Release|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x86.ActiveCfg = Debug|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x86.Build.0 = Debug|Win32
 		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x64.ActiveCfg = Release|x64
 		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x64.Build.0 = Release|x64
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x86.ActiveCfg = Release|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x86.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff -uPr BonD_FSHybrid-20201009_org/src/FSUSB2i_VS2008.sln BonD_FSHybrid-20201009_mod2/src/FSUSB2i_VS2008.sln
--- BonD_FSHybrid-20201009_org/src/FSUSB2i_VS2008.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/FSUSB2i_VS2008.sln	2019-12-20 14:08:42.000000000 +0900
@@ -0,0 +1,26 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_FSUSB2i", "BonDriver_FSUSB2i\BonDriver_FSUSB2i.vcproj", "{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|Win32.ActiveCfg = Debug|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|Win32.Build.0 = Debug|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x64.ActiveCfg = Debug|x64
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Debug|x64.Build.0 = Debug|x64
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|Win32.ActiveCfg = Release|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|Win32.Build.0 = Release|Win32
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x64.ActiveCfg = Release|x64
+		{CA568A68-986B-4AE3-8BEC-B9C5680AAC88}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/bonhybrid.cpp BonD_FSHybrid-20201009_mod2/src/bonhybrid.cpp
--- BonD_FSHybrid-20201009_org/src/bonhybrid.cpp	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/bonhybrid.cpp	2020-10-11 23:28:36.000000000 +0900
@@ -0,0 +1,876 @@
+//===========================================================================
+#include "stdafx.h"
+//---------------------------------------------------------------------------
+
+#include <string>
+#include <iterator>
+#include "bonhybrid.h"
+#include "usbdevfile.h"
+//---------------------------------------------------------------------------
+
+using namespace std;
+
+//===========================================================================
+namespace BonHybrid {
+//---------------------------------------------------------------------------
+
+#define UNITEDINIFILENAME "BonDriver_FSHybrid.ini"
+#define INIVALUELOADER_SECTION "BonTuner"
+#define INICHANNELS_SECTION "Channels"
+
+extern "C" {
+
+// Lɂtrinity19683񒼓`̃LbVɕύX
+BOOL TSCACHING_LEGACY = FALSE ;
+// LbV𐮍邩ǂi肷邪ׂj
+BOOL TSCACHING_DEFRAGMENT = FALSE ;
+// LbV𐮍ꍇ̃pPbgTCY
+DWORD TSCACHING_DEFRAGSIZE = 128*1024 ; // 128K(SpinelɍœK)
+// oN][h̃I[o[ChpPbgTCY
+int TSCACHING_BULKPACKETSIZE = 0 ; // 1ȏŗL
+// NULLpPbgVbgAEg邩ǂ[1: / 0:Ȃ]
+int TSCACHING_DROPNULLPACKETS = 1;
+
+// 񓯊LbV̐ݒ
+DWORD ASYNCTS_QUEUENUM     = 66  ; // Default 3M (47K*66) bytes
+DWORD ASYNCTS_QUEUEMAX     = 660 ; // Maximum growth 30M (47K*660) bytes
+DWORD ASYNCTS_EMPTYBORDER  = 22  ; // Empty border at least 1M (47K*22) bytes
+DWORD ASYNCTS_EMPTYLIMIT   = 11  ; // Empty limit at least 0.5M (47K*11) bytes
+const DWORD TSTHREADWAIT   = TS_PollTimeout ;
+const bool TSALLOCWAITING  = false ;
+const bool TSALLOCMODERATE = true ;
+
+// ̃`lVHF܂߂邩ǂ
+BOOL DEFSPACE_VHF = FALSE ;
+// ̃`lUHF܂߂邩ǂ
+BOOL DEFSPACE_UHF = TRUE ;
+// ̃`lCATV܂߂邩ǂ
+BOOL DEFSPACE_CATV = FALSE ;
+// ̃`lɃWXg̃`l܂߂邩ǂ
+BOOL DEFSPACE_AUX = TRUE ;
+// ̎Og`[i[`lBS܂߂邩ǂ
+BOOL DEFSPACE_BS = TRUE ;
+// ̎Og`[i[BS`l̊eXg[(0-8)
+DWORD DEFSPACE_BS_STREAMS = 8 ;
+// ̎Og`[i[`lCS110܂߂邩ǂ
+BOOL DEFSPACE_CS110 = TRUE ;
+// ̎Og`[i[CS110`l̊eXg[(0-8)
+DWORD DEFSPACE_CS110_STREAMS = 8 ;
+// IBonDriverSetChannelɃ[U[`lgp邩ǂ
+BOOL BYTETUNING_USER = FALSE ;
+
+// foCXɎsꍇɍĎső
+DWORD DEVICE_RETRY_TIMES = 3 ;
+
+}
+
+// Instance
+CBonFSHybrid* CBonFSHybrid::m_pThis = NULL;
+HINSTANCE CBonFSHybrid::m_hModule = NULL;
+
+
+//#define ES_PREVIEW
+
+// GWjAOTvp̎ݒR[h
+#ifdef ES_PREVIEW
+#define ES_LIMIT (60*60*1000) // 1Ԍo߂Xg[~
+static DWORD ES_Past = 0 ;
+static bool ES_Elapsed() {
+	if(!ES_Past) ES_Past = Elapsed() ;
+	return Elapsed(ES_Past)>ES_LIMIT ;
+}
+#endif
+
+
+//===========================================================================
+// Value Loaders
+//---------------------------------------------------------------------------
+class CRegValueLoader : public IValueLoader
+{
+	HKEY HKey ;
+public:
+	CRegValueLoader(HKEY hKey): HKey(hKey) {}
+	virtual DWORD ReadDWORD(const wstring name,DWORD defVal=0) const {
+		BYTE buf[sizeof DWORD] ;
+		DWORD rdSize = sizeof DWORD ;
+		DWORD type = 0 ;
+		if(ERROR_SUCCESS==RegQueryValueEx(
+		  HKey, name.c_str(), 0, &type, buf, &rdSize )) {
+			if(type==REG_DWORD) {
+				DWORD result = *(DWORD*)(&buf[0]) ;
+				DBGOUT("Mode: %s=%d\n",wcs2mbcs(name).c_str(),result);
+				return result ;
+			}
+		}
+		return defVal ;
+	}
+	virtual wstring ReadString(const wstring name,const wstring defStr) const {
+		const size_t MAX_BYTES = 1024 ;
+		BYTE buf[MAX_BYTES] ;
+		DWORD rdSize = sizeof buf ;
+		DWORD type = 0 ;
+		if(ERROR_SUCCESS==RegQueryValueEx(
+		  HKey, name.c_str(), 0, &type, buf, &rdSize )) {
+			if(type==REG_SZ) {
+				wstring result((LPCTSTR)(&buf[0])) ;
+				DBGOUT("Mode: %s=%s\n",wcs2mbcs(name).c_str(),wcs2mbcs(result).c_str());
+				return result ;
+			}
+		}
+		return defStr ;
+	}
+};
+//---------------------------------------------------------------------------
+class CIniValueLoader : public IValueLoader
+{
+	string Section, Filename ;
+public:
+	CIniValueLoader(const string section,const string filename)
+	{ Section=section; Filename=filename; }
+	virtual DWORD ReadDWORD(const wstring name,DWORD defVal=0) const {
+		return (DWORD) GetPrivateProfileIntA(
+			Section.c_str(),wcs2mbcs(name).c_str(),(int)defVal,Filename.c_str()) ;
+	}
+	virtual wstring ReadString(const wstring name,const wstring defStr) const {
+		const size_t MAX_CHARS = 1024 ;
+		char buf[MAX_CHARS] ;
+		DWORD num = GetPrivateProfileStringA(
+			Section.c_str(),wcs2mbcs(name).c_str(),wcs2mbcs(defStr).c_str(),
+			buf,MAX_CHARS,Filename.c_str());
+		return num>0 ? mbcs2wcs(string(buf,num)) : defStr ;
+	}
+};
+
+//===========================================================================
+// CBonFSHybrid
+//---------------------------------------------------------------------------
+CBonFSHybrid::CBonFSHybrid(bool hasSatellite)
+{
+	m_pThis = this;
+	m_hasSatellite=hasSatellite ;
+	tsthr=NULL ;
+	m_fifo=NULL ;
+	FifoFinalize() ;
+}
+//---------------------------------------------------------------------------
+CBonFSHybrid::~CBonFSHybrid()
+{
+	FifoFinalize() ;
+	m_pThis = NULL;
+}
+//---------------------------------------------------------------------------
+string CBonFSHybrid::ModuleFileName()
+{
+	char path[_MAX_PATH] ;
+	GetModuleFileNameA( m_hModule, path, _MAX_PATH ) ;
+	return path ;
+}
+//---------------------------------------------------------------------------
+bool CBonFSHybrid::FindDevice(const GUID &drvGUID, HANDLE &hDev, HANDLE &hUsbDev)
+{
+	bool result = false ;
+	DWORD counter = 0;
+	hDev=hUsbDev=NULL;
+	do {
+		int idx = UserDecidedDeviceIdx();
+		if(counter>0){
+			Sleep(50);
+			FreeDevice(hDev,hUsbDev);
+			Sleep(1000) ; //# take a breath before retrying...
+		}
+		if((hDev = usbdevfile_alloc(&idx,&drvGUID) ) == NULL) {
+			continue; //# not found
+		}
+		if((hUsbDev = usbdevfile_init(hDev) ) == NULL) {
+			continue; //# failed
+		}
+		result = true ;
+	}while(!result&&++counter<=DEVICE_RETRY_TIMES);
+	return result ;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::FreeDevice(HANDLE &hDev, HANDLE &hUsbDev)
+{
+	if(hUsbDev) {
+		usbdevfile_free(hUsbDev);
+		hUsbDev = NULL;
+	}
+	if(hDev) {
+		::CloseHandle( hDev );
+		hDev = NULL;
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::LoadUserChannels()
+{
+	string chFName = file_path_of(ModuleFileName()) + file_prefix_of(ModuleFileName()) + ".ch.txt" ;
+
+	FILE *st = NULL ;
+	fopen_s(&st, chFName.c_str(), "rt") ;
+	if (!st)
+		return ;
+	char s[512] ;
+
+	CHANNELS channels ;
+	SPACEINDICES indices ;
+
+	std::wstring space_name = L"" ;
+	while (!feof(st)) {
+		s[0] = '\0' ;
+		fgets(s, 512, st) ;
+		string strLine = trim(string(s)) ;
+		if (strLine.empty())
+			continue ;
+		wstring wstrLine = mbcs2wcs(strLine) ;
+		int t = 0 ;
+		vector<wstring> params ;
+		split(params, wstrLine, L';') ;
+		wstrLine = params[0] ;
+		params.clear() ;
+		split(params, wstrLine, L',') ;
+		if (params.size() >= 2 && !params[0].empty()) {
+			BAND band = BAND_na ;
+			int channel = 0 ;
+			DWORD freq = 0 ;
+			int stream = 0 ;
+			int tsid = 0 ;
+			wstring &space = params[0] ;
+			wstring name = params.size() >= 3 ? params[2] : wstring(L"") ;
+			wstring subname = params[1] ;
+			vector<wstring> phyChDiv ;
+			split(phyChDiv, params[1], '/') ;
+			for (size_t i = 0;i < phyChDiv.size();i++) {
+				wstring phyCh = phyChDiv[i] ;
+				if ( phyCh.length() > 3 &&
+						phyCh.substr(phyCh.length() - 3) == L"MHz" ) {
+					float megaHz = 0.f ;
+					if (swscanf_s(phyCh.c_str(), L"%fMHz", &megaHz) == 1) {
+						freq = DWORD(megaHz * 1000.f) ;
+						channel = CHANNEL::BandFromFreq(freq) != BAND_na ? -1 : 0 ;
+					}
+				} else {
+					if (m_hasSatellite && swscanf_s(phyCh.c_str(), L"TS%d", &stream) == 1)
+						;
+					else if (m_hasSatellite && swscanf_s(phyCh.c_str(), L"ID%i", &tsid) == 1)
+						;
+					else if (band == BAND_na) {
+						if (m_hasSatellite && swscanf_s(phyCh.c_str(), L"BS%d", &channel) == 1)
+							band = BAND_BS ;
+						else if (m_hasSatellite && swscanf_s(phyCh.c_str(), L"ND%d", &channel) == 1)
+							band = BAND_ND ;
+						else if (swscanf_s(phyCh.c_str(), L"C%d", &channel) == 1)
+							band = BAND_VU, subname = L"C" + itows(channel) + L"ch", channel += 100 ;
+						else if (swscanf_s(phyCh.c_str(), L"%d", &channel) == 1)
+							band = BAND_VU, subname = itows(channel) + L"ch" ;
+					}
+				}
+			}
+			if (name == L"")
+				name = subname ;
+			if (freq > 0 && channel < 0)
+				channels.push_back(
+					CHANNEL(space, freq, name, stream, tsid)) ;
+			else if (band != BAND_na && channel > 0)
+				channels.push_back(
+					CHANNEL(space, band, channel, name, stream, tsid)) ;
+			else
+				continue ;
+			if (space_name != space) {
+				indices.push_back(channels.size() - 1) ;
+				space_name = space ;
+			}
+		}
+	}
+
+	if (!channels.empty() && !indices.empty()) {
+		m_UserChannels.swap(channels) ;
+		m_UserSpaceIndices.swap(indices) ;
+	}
+
+	fclose(st) ;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::BuildTChannels()
+{
+	if(DEFSPACE_VHF) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		for(int i=1;i<=12;i++) {
+			m_UserChannels.push_back(CHANNEL(L"VHF",BAND_VU,i,itows(i)+L"ch"));
+		}
+	}
+	if(DEFSPACE_UHF) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		for(int i=13;i<=62;i++) {
+			m_UserChannels.push_back(CHANNEL(L"UHF",BAND_VU,i,itows(i)+L"ch"));
+		}
+	}
+	if(DEFSPACE_CATV) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		for(int i=13;i<=63;i++) {
+			m_UserChannels.push_back(CHANNEL(L"CATV",BAND_VU,i+100,L"C"+itows(i)+L"ch"));
+		}
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::BuildSChannels()
+{
+	if(DEFSPACE_BS) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		for(int i=1;i<=23;i+=2) {
+			if(DEFSPACE_BS_STREAMS) for(DWORD j=0;j<DEFSPACE_BS_STREAMS;j++) {
+				m_UserChannels.push_back(CHANNEL(L"BS",BAND_BS,i,L"BS"+itows(i)+L"/TS"+itows(j),j));
+			}else {
+				m_UserChannels.push_back(CHANNEL(L"BS",BAND_BS,i,L"BS"+itows(i),0));
+			}
+		}
+	}
+	if(DEFSPACE_CS110) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		for(int i=2;i<=24;i+=2) {
+			if(DEFSPACE_CS110_STREAMS) for(DWORD j=0;j<DEFSPACE_CS110_STREAMS;j++) {
+				m_UserChannels.push_back(CHANNEL(L"CS110",BAND_ND,i,L"ND"+itows(i)+L"/TS"+itows(j),j));
+			}else {
+				m_UserChannels.push_back(CHANNEL(L"CS110",BAND_ND,i,L"ND"+itows(i),0));
+			}
+		}
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::BuildAuxChannels()
+{
+	if(!DEFSPACE_AUX) return ;
+	CHANNELS channels ;
+
+	string path = file_path_of(ModuleFileName()) ;
+	string dllIniFileName = path + file_prefix_of(ModuleFileName()) + ".ini" ;
+	ReadIniChannels(dllIniFileName,channels);
+	if(channels.empty()) {
+		string unitedIniFileName = path + UNITEDINIFILENAME ;
+		ReadIniChannels(unitedIniFileName,channels);
+		if(channels.empty()) {
+			HKEY hKey;
+			if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, RegName(), 0, KEY_READ, &hKey)) {
+				ReadRegChannels(hKey,channels);
+				RegCloseKey(hKey);
+			}
+			if(channels.empty()) {
+				if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, RegName(), 0, KEY_READ, &hKey)) {
+					ReadRegChannels(hKey,channels);
+					RegCloseKey(hKey);
+				}
+			}
+		}
+	}
+	if(!channels.empty()) {
+		m_UserSpaceIndices.push_back(m_UserChannels.size()) ;
+		copy(channels.begin(),channels.end(),back_inserter(m_UserChannels)) ;
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::ArrangeChannels()
+{
+	struct space_finder : public std::unary_function<CHANNEL, bool> {
+		std::wstring space ;
+		space_finder(std::wstring space_) {
+			space = space_ ;
+		}
+		bool operator ()(const CHANNEL &ch) const {
+			return space == ch.Space;
+		}
+	};
+	if (!m_InvisibleSpaces.empty() || !m_SpaceArrangement.empty()) {
+		CHANNELS newChannels ;
+		//CHANNELS oldChannels(m_UserChannels) ;
+		CHANNELS &oldChannels = m_UserChannels ;
+		CHANNELS::iterator beg = oldChannels.begin() ;
+		CHANNELS::iterator end = oldChannels.end() ;
+		for (CHANNELS::size_type i = 0; i < m_InvisibleSpaces.size(); i++) {
+			end = remove_if(beg, end, space_finder(m_InvisibleSpaces[i]));
+		}
+		for (CHANNELS::size_type i = 0; i < m_SpaceArrangement.size(); i++) {
+			space_finder finder(m_SpaceArrangement[i]) ;
+			remove_copy_if(beg, end, back_inserter(newChannels), not1(finder)) ;
+			end = remove_if(beg, end, finder) ;
+		}
+		copy(beg, end, back_inserter(newChannels)) ;
+		SPACEINDICES newSpaceIndices ;
+		wstring space = L"" ;
+		for (CHANNELS::size_type i = 0;i < newChannels.size();i++) {
+			if (newChannels[i].Space != space) {
+				space = newChannels[i].Space ;
+				newSpaceIndices.push_back(size_t(i)) ;
+			}
+		}
+		m_UserChannels.swap(newChannels) ;
+		m_UserSpaceIndices.swap(newSpaceIndices) ;
+	}
+}
+//---------------------------------------------------------------------------
+CBonFSHybrid::CHANNEL *CBonFSHybrid::GetUserChannel(DWORD dwSpace, DWORD dwChannel)
+{
+	if(dwSpace<m_UserSpaceIndices.size()) {
+		DWORD begin = (DWORD)m_UserSpaceIndices[dwSpace] ;
+		DWORD end = DWORD(dwSpace+1 < m_UserSpaceIndices.size()
+			? m_UserSpaceIndices[dwSpace+1] : m_UserChannels.size()) ;
+		if(dwChannel<end-begin) {
+			DWORD index = begin + dwChannel ;
+			return &m_UserChannels[index] ;
+		}
+	}
+	return NULL ;
+}
+//---------------------------------------------------------------------------
+CBonFSHybrid::CHANNEL CBonFSHybrid::GetChannel(DWORD dwSpace, DWORD dwChannel)
+{
+	if(dwSpace == SPACE_CHASFREQ) {  //# dwChannel as freq/kHz
+		return CHANNEL(L"CHASFREQ",dwChannel,itows(dwChannel)+L"kHz") ;
+	}else if(CHANNEL *userChannel = GetUserChannel(dwSpace,dwChannel)) {
+		return *userChannel ;
+	}
+	return CHANNEL() ;
+}
+//---------------------------------------------------------------------------
+bool CBonFSHybrid::FifoInitialize(usb_endpoint_st *usbep)
+{
+	tsfifo_t *ptsfifo = NULL ;
+	tsfifo_t tsfifo={0} ;
+	FifoFinalize();
+	if(!TSCACHING_LEGACY) {
+		if(m_eoCaching.is_valid()) {
+			size_t TSDATASIZE = ((usbep->xfer_size+TS_DeltaSize+0x1FFUL)&~0x1FFUL) ;
+			if(usbep->endpoint&0x100) {  // Isochronous
+				// AC\NiX]̏ꍇ́AIɐ
+				if(!TSCACHING_DEFRAGMENT) {
+					//t[pPbgɃTCYg
+					TSCACHING_DEFRAGSIZE = TSCACHING_BULKPACKETSIZE>0 ?
+						TSCACHING_BULKPACKETSIZE : TS_PacketSize ;
+					TSCACHING_DEFRAGMENT = TRUE ; //
+				}
+			}
+			if(TSCACHING_DEFRAGMENT)
+				TSDATASIZE = max(TSCACHING_DEFRAGSIZE,TSDATASIZE);
+			DBGOUT("TSDATASIZE=%d\n",TSDATASIZE) ;
+			m_fifo = new CAsyncFifo(
+				ASYNCTS_QUEUENUM,ASYNCTS_QUEUEMAX,ASYNCTS_EMPTYBORDER,
+				TSDATASIZE,TSTHREADWAIT ) ;
+			if(m_fifo) {
+				m_fifo->SetEmptyLimit(ASYNCTS_EMPTYLIMIT) ;
+				m_fifo->SetModerateAllocating(TSALLOCMODERATE);
+				if(TSCACHING_DEFRAGMENT) {
+					tsfifo.writeThrough = &OnTSFifoWriteThrough ;
+				}else {
+					tsfifo.writeBackBegin = &OnTSFifoWriteBackBegin ;
+					tsfifo.writeBackFinish = &OnTSFifoWriteBackFinish ;
+				}
+				tsfifo.purge = &OnTSFifoPurge ;
+				tsfifo.arg = this ;
+				ptsfifo = &tsfifo ;
+			}
+		}
+	}
+	//# TS receive thread
+	if( tsthread_create(&tsthr, usbep, ptsfifo) ) {
+		return false;
+	}
+	return true;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::FifoFinalize()
+{
+	if(tsthr) {
+		tsthread_stop(tsthr);
+		tsthread_destroy(tsthr);
+		tsthr = NULL;
+	}
+	if(m_fifo) {
+		delete m_fifo;
+		m_fifo = NULL;
+	}
+	ZeroMemory(m_mapCache,sizeof(m_mapCache)) ;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::FifoStart()
+{
+	if(tsthr) tsthread_start(tsthr);
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::FifoStop()
+{
+	if(tsthr) tsthread_stop(tsthr);
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::ReadRegChannels(HKEY hPKey, CHANNELS &regChannels)
+{
+	HKEY hKey;
+	DWORD NumOfValues;
+	TCHAR szValueName[32];
+	DWORD dwValue, dwLen, dwType, dwByte, dwMaxValueName;
+	if(ERROR_SUCCESS != RegOpenKeyEx( hPKey, TEXT("Channels"), 0, KEY_READ, &hKey)) {
+		return;
+	}
+	if(ERROR_SUCCESS != RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL, &NumOfValues, &dwMaxValueName, NULL, NULL, NULL)) {
+		RegCloseKey(hKey);
+		return;
+	}
+	regChannels.resize(NumOfValues) ;
+	for(DWORD dwIdx = 0; dwIdx < NumOfValues; dwIdx++ ) {
+		dwLen = 32;
+		dwByte = sizeof(dwValue);
+		if(ERROR_SUCCESS != RegEnumValue( hKey, dwIdx, szValueName, &dwLen, NULL, &dwType, (BYTE*)&dwValue, &dwByte)
+			|| dwByte != sizeof(DWORD)) {
+			break;
+		}
+		dwByte = dwValue >> 24; //# Index
+		if( dwByte >= NumOfValues ) continue;
+		regChannels[dwByte] = CHANNEL(L"AUX",dwValue & 0x00ffffff,szValueName) ;
+	}
+	RegCloseKey(hKey);
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::ReadIniChannels (const std::string iniFilename, CHANNELS &iniChannels)
+{
+	BUFFER<char> buf(256) ;
+	DWORD n = 0;
+	do {
+		if (n) buf.resize(buf.size()*2) ;
+		n = GetPrivateProfileSectionA(INICHANNELS_SECTION, buf.data(), (DWORD)buf.size(), iniFilename.c_str());
+	} while (n == buf.size() - 2);
+	if (!n)
+		return ;
+	size_t numChannel = 0 ;
+	for (size_t i = 0;i < n;i++) {
+		char *p = buf.data() ;
+		p = &p[i] ;
+		if (!*p)
+			break ;
+		numChannel++ ;
+		i += strlen(p);
+	}
+	if (!numChannel)
+		return ;
+	iniChannels.resize(numChannel) ;
+	for (size_t i = 0;i < n;i++) {
+		char *p = buf.data() ;
+		p = &p[i] ;
+		if (!*p)
+			break ;
+		vector<string> item ;
+		split(item, string(p), '=') ;
+		if (item.size() == 2) {
+			int val = 0 ;
+			if (sscanf_s(item[1].c_str(), "%i", &val) == 1) {
+				size_t idx = size_t(val) >> 24;
+				if(idx < numChannel)
+					iniChannels[idx] = CHANNEL(L"AUX", val & 0x00ffffff, mbcs2wcs(item[0])) ;
+			}
+		}
+		i += strlen(p);
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::LoadReg()
+{
+	HKEY hKey;
+	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE, RegName(), 0, KEY_READ, &hKey)) {
+		CRegValueLoader Loader(hKey) ;
+		LoadValues(&Loader);
+		RegCloseKey(hKey);
+	}
+	if(ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER, RegName(), 0, KEY_READ, &hKey)) {
+		CRegValueLoader Loader(hKey) ;
+		LoadValues(&Loader);
+		RegCloseKey(hKey);
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::LoadIni()
+{
+	string path = file_path_of(ModuleFileName()) ;
+	string unitedIniFileName = path + UNITEDINIFILENAME ;
+	CIniValueLoader unitedIniLoader(INIVALUELOADER_SECTION, unitedIniFileName) ;
+	LoadValues(&unitedIniLoader);
+	string dllIniFileName = path + file_prefix_of(ModuleFileName()) + ".ini" ;
+	CIniValueLoader dllIniLoader(INIVALUELOADER_SECTION, dllIniFileName) ;
+	LoadValues(&dllIniLoader);
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::LoadValues(const IValueLoader *Loader)
+{
+	#define LOADDW(val) do { val = Loader->ReadDWORD(L#val,val); } while(0)
+	#define LOADMSTRLIST(name) do { \
+		wstring s = Loader->ReadString(L#name); \
+		if(!s.empty()) { \
+			m_##name.clear(); split(m_##name,s,','); \
+		} }while(0)
+	LOADDW(TSCACHING_LEGACY);
+	LOADDW(TSCACHING_DEFRAGMENT);
+	LOADDW(TSCACHING_DEFRAGSIZE);
+	LOADDW(TSCACHING_BULKPACKETSIZE);
+	LOADDW(TSCACHING_DROPNULLPACKETS);
+	LOADDW(ASYNCTS_QUEUENUM);
+	LOADDW(ASYNCTS_QUEUEMAX);
+	LOADDW(ASYNCTS_EMPTYBORDER);
+	LOADDW(ASYNCTS_EMPTYLIMIT);
+	LOADDW(DEFSPACE_VHF);
+	LOADDW(DEFSPACE_UHF);
+	LOADDW(DEFSPACE_CATV);
+	LOADDW(DEFSPACE_AUX);
+	LOADDW(DEFSPACE_BS);
+	LOADDW(DEFSPACE_BS_STREAMS);
+	LOADDW(DEFSPACE_CS110);
+	LOADDW(DEFSPACE_CS110_STREAMS);
+	LOADDW(BYTETUNING_USER);
+	LOADDW(DEVICE_RETRY_TIMES);
+	LOADMSTRLIST(SpaceArrangement);
+	LOADMSTRLIST(InvisibleSpaces);
+	LOADDW(USBPIPEPOLICY_RAW_IO);
+	LOADDW(USBPIPEPOLICY_AUTO_CLEAR_STALL);
+	LOADDW(USBPIPEPOLICY_ALLOW_PARTIAL_READS);
+	LOADDW(USBPIPEPOLICY_AUTO_FLUSH);
+	LOADDW(USBPIPEPOLICY_IGNORE_SHORT_PACKETS);
+	LOADDW(USBPIPEPOLICY_SHORT_PACKET_TERMINATE);
+	LOADDW(USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT);
+	LOADDW(USBPIPEPOLICY_RESET_PIPE_ON_RESUME);
+	#undef LOADMSTRLIST
+	#undef LOADDW
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::Initialize()
+{
+	LoadReg();
+	LoadIni();
+	BuildTChannels();
+	BuildAuxChannels();
+	if(m_hasSatellite)
+		BuildSChannels();
+	LoadUserChannels();
+	ArrangeChannels();
+}
+//---------------------------------------------------------------------------
+const BOOL CBonFSHybrid::SetChannel(const BYTE bCh)
+{
+	if(BYTETUNING_USER) {
+		if(size_t(bCh)<m_UserChannels.size()) {
+			DWORD space = 0 ;
+			for(;space<m_UserSpaceIndices.size();space++) {
+				if(bCh<m_UserSpaceIndices[space]) {
+					break ;
+				}
+			}
+			if(--space<m_UserSpaceIndices.size()) {
+				DWORD ch = DWORD(bCh)-DWORD(m_UserSpaceIndices[space]) ;
+				return SetChannel(space,ch) ;
+			}
+		}
+	}else {
+		if( (DEFSPACE_VHF&&bCh>=1&&bCh<=12) ||
+			(DEFSPACE_UHF&&bCh>=13&&bCh<=62) ||
+			(DEFSPACE_CATV&&bCh>=113&&bCh<=163) ) {
+			return SetChannel(SPACE_CHASFREQ, CHANNEL::FreqFromBandCh(BAND_VU,bCh));
+		}
+	}
+	return FALSE ;
+}
+//---------------------------------------------------------------------------
+const DWORD CBonFSHybrid::WaitTsStream(const DWORD dwTimeOut)
+{
+	const int remainTime = (dwTimeOut < 0x10000000) ? dwTimeOut : 0x10000000;
+	if(! tsthr) return WAIT_ABANDONED;
+	if(m_fifo) {
+		if(m_fifo->Size()>0) return WAIT_OBJECT_0 ;
+		DWORD res = m_eoCaching.wait(remainTime) ;
+		if(m_fifo->Empty()) return WAIT_TIMEOUT ;
+		return res ;
+	}
+	const int r = tsthread_wait(tsthr, remainTime);
+	if(0 > r)  return WAIT_ABANDONED;
+	else if(0 < r)  return WAIT_OBJECT_0;
+	else  return WAIT_TIMEOUT;
+}
+//---------------------------------------------------------------------------
+const DWORD CBonFSHybrid::GetReadyCount()
+{//# number of call GetTsStream()
+	if(! tsthr) return 0;
+	if(m_fifo) return static_cast<DWORD>(m_fifo->Size());
+	const int ret = tsthread_readable(tsthr);
+	return (ret > 0) ? 1 : 0;
+}
+//---------------------------------------------------------------------------
+const BOOL CBonFSHybrid::GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain)
+{
+#ifdef ES_PREVIEW
+	if(ES_Elapsed()) { if(m_fifo) m_fifo->Purge(false) ; return FALSE ; }
+#endif
+	BYTE *pSrc = NULL;
+	if(GetTsStream(&pSrc, pdwSize, pdwRemain)){
+		if(*pdwSize) ::CopyMemory(pDst, pSrc, *pdwSize);
+		return TRUE;
+	}
+	return FALSE;
+}
+//---------------------------------------------------------------------------
+const BOOL CBonFSHybrid::GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain)
+{
+#ifdef ES_PREVIEW
+	if(ES_Elapsed()) { if(m_fifo) m_fifo->Purge(false) ; return FALSE ; }
+#endif
+	if(! tsthr) return FALSE;
+	if(m_fifo) {
+		m_fifo->Pop(ppDst,pdwSize,pdwRemain);
+		return TRUE ;
+	}
+	const int ret = tsthread_readable(tsthr);
+	if(ret <= 0) {
+		//# no readable data
+		*pdwSize = 0;
+		*pdwRemain = 0;
+		return TRUE;
+	}
+	*pdwSize = tsthread_read(tsthr, (void**)ppDst);
+	*pdwRemain = GetReadyCount();
+	//dmsg("GetTsStream(%p,%u,%u)", ppDst, *pdwSize, *pdwRemain);
+	return TRUE;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::PurgeTsStream()
+{
+	if(! tsthr) return;
+	//# purge available data in TS buffer
+	tsthread_read(tsthr, NULL);
+}
+//---------------------------------------------------------------------------
+LPCTSTR CBonFSHybrid::EnumTuningSpace(const DWORD dwSpace)
+{
+	if(dwSpace<m_UserSpaceIndices.size())
+		return m_UserChannels[m_UserSpaceIndices[dwSpace]].Space.c_str() ;
+	return NULL ;
+}
+//---------------------------------------------------------------------------
+LPCTSTR CBonFSHybrid::EnumChannelName(const DWORD dwSpace, const DWORD dwChannel)
+{
+	static TCHAR buf[8];
+	if(dwSpace<m_UserSpaceIndices.size()) {
+		DWORD begin = (DWORD)m_UserSpaceIndices[dwSpace] ;
+		DWORD end = DWORD(dwSpace+1 < m_UserSpaceIndices.size() ?
+			m_UserSpaceIndices[dwSpace+1] : m_UserChannels.size()) ;
+		if(dwChannel<end-begin)
+			return m_UserChannels[begin+dwChannel].Name.c_str() ;
+	}
+	return NULL ;
+}
+//---------------------------------------------------------------------------
+void *CBonFSHybrid::OnTSFifoWriteBackBegin(int id, size_t max_size, void *arg)
+{
+	if(id<0||id>=TS_MaxNumIO) return NULL ;
+	CBonFSHybrid *tuner = static_cast<CBonFSHybrid*>(arg) ;
+	CAsyncFifo::CACHE *cache = tuner->m_fifo->BeginWriteBack(TSALLOCWAITING) ;
+	if(!cache) return NULL ;
+	else cache->resize(max_size) ;
+	tuner->m_coPurge.lock() ;
+	tuner->m_mapCache[id] = cache ;
+	tuner->m_coPurge.unlock() ;
+	return cache->data() ;
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::OnTSFifoWriteBackFinish(int id, size_t wrote_size, void *arg)
+{
+	CBonFSHybrid *tuner = static_cast<CBonFSHybrid*>(arg) ;
+	exclusive_lock purgeLock(&tuner->m_coPurge);
+	CAsyncFifo::CACHE *cache = tuner->m_mapCache[id] ;
+	if(cache) {
+		tuner->m_mapCache[id]=NULL ;
+		purgeLock.unlock();
+		cache->resize(wrote_size) ;
+		if(tuner->m_fifo->FinishWriteBack(cache))
+			tuner->m_eoCaching.set() ;
+	}
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::OnTSFifoWriteThrough(const void *buffer, size_t size, void *arg)
+{
+	CBonFSHybrid *tuner = static_cast<CBonFSHybrid*>(arg) ;
+	exclusive_lock purgeLock(&tuner->m_coPurge);
+	if ( tuner->m_fifo->Push(static_cast<const BYTE*>(buffer),
+		 static_cast<DWORD>(size), false, TSALLOCWAITING) > 0)
+			tuner->m_eoCaching.set();
+}
+//---------------------------------------------------------------------------
+void CBonFSHybrid::OnTSFifoPurge(void *arg)
+{
+	CBonFSHybrid *tuner = static_cast<CBonFSHybrid*>(arg) ;
+	exclusive_lock purgeLock(&tuner->m_coPurge);
+	ZeroMemory(tuner->m_mapCache,sizeof(tuner->m_mapCache));
+	tuner->m_fifo->Purge(true) ;
+}
+//---------------------------------------------------------------------------
+// CBonFSHybrid::CHANNEL
+//-----
+CBonFSHybrid::CHANNEL::CHANNEL()
+ : Space(L""),Band(BAND_na),Name(L""),Freq(0),Stream(0),TSID(0) {}
+//-----
+CBonFSHybrid::CHANNEL::CHANNEL(wstring space, BAND band, int channel,
+  wstring name, unsigned stream, unsigned tsid) {
+	Space = space ;
+	Band = band ;
+	Name = name ;
+	Freq = FreqFromBandCh(band,channel) ;
+	Stream = stream ;
+	TSID = tsid ;
+}
+//-----
+CBonFSHybrid::CHANNEL::CHANNEL(wstring space, DWORD freq, wstring name,
+  unsigned stream, unsigned tsid){
+	Space = space ;
+	Band = BandFromFreq(freq) ;
+	Name = name ;
+	Freq = freq ;
+	Stream = stream ;
+	TSID = tsid ;
+}
+//-----
+CBonFSHybrid::CHANNEL::CHANNEL(const CHANNEL &src) {
+	Space = src.Space ;
+	Band = src.Band ;
+	Name = src.Name ;
+	Freq = src.Freq ;
+	Stream = src.Stream ;
+	TSID = src.TSID;
+}
+//-----
+DWORD CBonFSHybrid::CHANNEL::FreqFromBandCh(BAND band,int ch) {
+	DWORD freq =0 ;
+	switch(band) {
+		case BAND_VU:
+			if(ch < 4)          freq =  93UL + (ch - 1)   * 6UL ;
+			else if(ch < 8)     freq = 173UL + (ch - 4)   * 6UL ;
+			else if(ch < 13)    freq = 195UL + (ch - 8)   * 6UL ;
+			else if(ch < 63)    freq = 473UL + (ch - 13)  * 6UL ;
+			else if(ch < 122)   freq = 111UL + (ch - 113) * 6UL ;
+			else if(ch ==122)   freq = 167UL ; // C22
+			else if(ch < 136)   freq = 225UL + (ch - 123) * 6UL ;
+			else                freq = 303UL + (ch - 136) * 6UL ;
+			freq *= 1000UL ; // kHz
+			freq +=  143UL ; // + 1000/7 kHz
+			break ;
+		case BAND_BS:
+			freq = ch * 19180UL + 1030300UL ;
+			break ;
+		case BAND_ND:
+			freq = ch * 20000UL + 1573000UL ;
+			break ;
+	}
+	return freq ;
+}
+//-----
+CBonFSHybrid::BAND CBonFSHybrid::CHANNEL::BandFromFreq(DWORD freq) {
+	if(freq < 60000UL || freq > 2456123UL )
+		return BAND_na ;
+	if(freq < 900000UL )
+		return BAND_VU ;
+	if(freq < 1573000UL )
+		return BAND_BS ;
+	return BAND_ND ;
+}
+//---------------------------------------------------------------------------
+} // End of namespace BonHybrid
+//===========================================================================
diff -uPr BonD_FSHybrid-20201009_org/src/bonhybrid.h BonD_FSHybrid-20201009_mod2/src/bonhybrid.h
--- BonD_FSHybrid-20201009_org/src/bonhybrid.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/bonhybrid.h	2020-10-03 07:43:46.000000000 +0900
@@ -0,0 +1,145 @@
+//===========================================================================
+#pragma once
+
+#ifndef _BONHYBRID_20191229125131957_H_INCLUDED_
+#define _BONHYBRID_20191229125131957_H_INCLUDED_
+//---------------------------------------------------------------------------
+
+#include <string>
+#include <vector>
+#include "pryutil.h"
+#include "IBonDriver2.h"
+
+extern "C" {
+#include "tsbuff.h"
+#include "tsthread.h"
+}
+
+#define SPACE_CHASFREQ  114514
+
+namespace BonHybrid {
+
+class IValueLoader
+{
+public:
+    virtual DWORD ReadDWORD(const std::wstring name,DWORD defVal=0) const =0 ;
+	virtual std::wstring ReadString(const std::wstring name,const std::wstring defStr=L"") const =0 ;
+};
+
+class CBonFSHybrid : public IBonDriver2
+{
+public:
+	// BAND
+	enum BAND {
+		BAND_na, // [n/a]
+		BAND_VU, // VHS, UHF or CATV
+		BAND_BS, // BS
+		BAND_ND  // CS110
+	};
+	// CHANNEL/CHANNELS
+	struct CHANNEL {
+		std::wstring	Space ;
+		std::wstring	Name ;
+		BAND			Band ;
+		DWORD			Freq ;
+		unsigned		Stream:3 ;
+		WORD			TSID ;
+		CHANNEL();
+		CHANNEL(std::wstring space, BAND band, int channel, std::wstring name,unsigned stream=0,unsigned tsid=0);
+		CHANNEL(std::wstring space, DWORD freq,std::wstring name,unsigned stream=0,unsigned tsid=0);
+		CHANNEL(const CHANNEL &src) ;
+		static DWORD FreqFromBandCh(BAND band,int ch);
+		static BAND BandFromFreq(DWORD freq);
+	} ;
+	typedef std::vector<CHANNEL> CHANNELS ;
+	typedef std::vector<size_t> SPACEINDICES ;
+	typedef std::vector<std::wstring> SPACENAMES ;
+protected:
+	std::string ModuleFileName() ;
+	// Device
+	virtual int UserDecidedDeviceIdx() { return -1 ; }
+	bool FindDevice(const GUID &drvGUID, HANDLE &hDev, HANDLE &hUsbDev) ;
+	void FreeDevice(HANDLE &hDev, HANDLE &hUsbDev) ;
+	// Channels
+	void LoadUserChannels() ;
+	void BuildTChannels() ;
+	void BuildSChannels() ;
+	void BuildAuxChannels() ;
+	void ArrangeChannels() ;
+	CHANNEL *GetUserChannel(DWORD dwSpace, DWORD dwChannel);
+	CHANNEL GetChannel(DWORD dwSpace, DWORD dwChannel);
+	// FIFO
+	bool FifoInitialize(usb_endpoint_st *usbep) ;
+	void FifoFinalize() ;
+	void FifoStart() ;
+	void FifoStop() ;
+	static void *OnTSFifoWriteBackBegin(int id, size_t max_size, void *arg) ;
+	static void OnTSFifoWriteBackFinish(int id, size_t wrote_size, void *arg) ;
+	static void OnTSFifoWriteThrough(const void *buffer, size_t size, void *arg) ;
+	static void OnTSFifoPurge(void *arg) ;
+
+protected:
+	// Registry
+	virtual const TCHAR *RegName() { return NULL ; }
+	// Channels
+	virtual void ReadRegChannels (HKEY hPKey, CHANNELS &regChannels);
+	virtual void ReadIniChannels (const std::string iniFilename, CHANNELS &iniChannels);
+	// Loader
+	virtual void LoadReg();
+	virtual void LoadIni();
+	virtual void LoadValues(const IValueLoader *Loader);
+
+public:
+	// Initializer
+	virtual void Initialize();
+
+public: // inherited
+	// IBonDriver
+	virtual const BOOL SetChannel(const BYTE bCh);
+	virtual const DWORD WaitTsStream(const DWORD dwTimeOut = 0);
+	virtual const DWORD GetReadyCount(void);
+	virtual const BOOL GetTsStream(BYTE *pDst, DWORD *pdwSize, DWORD *pdwRemain);
+	virtual const BOOL GetTsStream(BYTE **ppDst, DWORD *pdwSize, DWORD *pdwRemain);
+	virtual void PurgeTsStream(void);
+	// IBonDriver2
+	virtual LPCTSTR EnumTuningSpace(const DWORD dwSpace);
+	virtual LPCTSTR EnumChannelName(const DWORD dwSpace, const DWORD dwChannel);
+	virtual const BOOL SetChannel(const DWORD dwSpace, const DWORD dwChannel) {return FALSE;}
+
+protected:
+	CBonFSHybrid(bool hasSatellite=false);
+	virtual ~CBonFSHybrid();
+
+protected:
+	// User Channels
+	CHANNELS m_UserChannels ;
+	SPACEINDICES m_UserSpaceIndices;
+	SPACENAMES m_SpaceArrangement, m_InvisibleSpaces ;
+	bool m_hasSatellite ;
+	// tsthread
+	tsthread_ptr tsthr;
+	// FIFO
+	CAsyncFifo *m_fifo ;
+	CAsyncFifo::CACHE *m_mapCache[TS_MaxNumIO] ;
+	event_object m_eoCaching ;
+	exclusive_object m_coPurge ;
+
+public:
+	// Instance
+	static CBonFSHybrid *m_pThis;
+	static HINSTANCE m_hModule;
+
+};
+
+template<class T> IBonDriver *BonFSCreate() {
+	if(T::m_pThis) return static_cast<IBonDriver*>(T::m_pThis) ;
+	if(T *bon = new T) { bon->Initialize() ; return static_cast<IBonDriver*>(bon) ; }
+	return 0 ;
+}
+
+} // End of namespace BonHybrid
+
+using namespace BonHybrid ;
+
+//===========================================================================
+#endif // _BONHYBRID_20191229125131957_H_INCLUDED_
diff -uPr BonD_FSHybrid-20201009_org/src/em2874.cpp BonD_FSHybrid-20201009_mod2/src/em2874.cpp
--- BonD_FSHybrid-20201009_org/src/em2874.cpp	2012-09-28 01:43:05.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/em2874.cpp	2020-10-11 23:27:12.000000000 +0900
@@ -1,12 +1,9 @@
 #include "stdafx.h"
 #include "em2874.h"
-#include "../twindbg.h"
+#include "message.h"
 #include <setupapi.h>
 #include <strsafe.h>
 
-// hCoCX^XGUID
-DEFINE_GUID( GUID_WINUSB_DRIVER,	0xb35924d6L, 0x3e09, 0x4a9e, 0x97, 0x82, 0x55, 0x24, 0xa4, 0xb7, 0x9b, 0xa4 );
-
 inline uint8_t ICC_checkSum (const uint8_t* data, int len)
 {
 	uint8_t sum = 0;
@@ -16,35 +13,40 @@
 	return sum;
 }
 
-inline void miliWait( int s )
-{
-	::Sleep(s);
-}
-
 unsigned EM2874Device::UserSettings = 0x1;
 
 EM2874Device::EM2874Device ()
-: dev(NULL), usbHandle(NULL), isCardReady(false)
+: dev(NULL), usbHandle(NULL), isCardReady(false), pmutex(NULL)
 #ifdef EM2874_TS
 , hTsEvent(NULL), TsBuffSize(NULL)
 #endif
 {
+#ifdef EM2874_TS
+	ZeroMemory(&IoContext,sizeof(IoContext));
+	ZeroMemory(&TSFifo,sizeof(TSFifo)) ;
+#endif
 }
 
 EM2874Device::EM2874Device(HANDLE hDev)
-: dev(hDev), usbHandle(NULL), isCardReady(false)
+: dev(hDev), usbHandle(NULL), isCardReady(false), pmutex(NULL)
 #ifdef EM2874_TS
 , hTsEvent(NULL), TsBuffSize(NULL)
 #endif
 {
+#ifdef EM2874_TS
+	ZeroMemory(&IoContext,sizeof(IoContext));
+	ZeroMemory(&TSFifo,sizeof(TSFifo)) ;
+#endif
 }
 
 EM2874Device::~EM2874Device ()
 {
+#ifdef EM2874_TS
 	if (hTsEvent) {
 		::CloseHandle(hTsEvent);
 		hTsEvent = NULL;
 	}
+#endif
 	if ( usbHandle ) {
 		writeReg(EM2874_REG_TS_ENABLE, 0);
 		::WinUsb_SetCurrentAlternateSetting( usbHandle, 0 );
@@ -55,75 +57,39 @@
 			writeReg(EM2874_REG_CAS_MODE1, 0x0);
 			writeReg(0x0C, 0x0);
 		}
-		::WinUsb_Free( usbHandle );
 	}
-	if ( this->dev ) {
-		::CloseHandle( this->dev );
+	if(pmutex) {
+		uthread_mutex_destroy(pmutex);
+		pmutex=NULL;
 	}
 }
 
-EM2874Device* EM2874Device::AllocDevice(int &idx)
+EM2874Device* EM2874Device::AllocDevice(HANDLE hDev, HANDLE hUsbDev)
 {
-	DWORD dwRet;
-	ULONG length;
-	
-	HANDLE hDev = INVALID_HANDLE_VALUE;
-
-	// foCXZbg̃nh擾
-	HDEVINFO deviceInfo = SetupDiGetClassDevs((GUID *)&GUID_WINUSB_DRIVER, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
-	if(deviceInfo == INVALID_HANDLE_VALUE) return NULL;
-
-	SP_DEVICE_INTERFACE_DATA interfaceData;
-	interfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
-
-	for(; idx < 20; idx++ ) {
-		// foCXC^tF[X
-		if( FALSE == SetupDiEnumDeviceInterfaces(deviceInfo, NULL, (GUID *)&GUID_WINUSB_DRIVER, idx, &interfaceData) ) {
-			dwRet = ::GetLastError();
-			//if(dwRet == ERROR_NO_MORE_ITEMS) break;
-			break;
-		}
-
-		ULONG requiredLength = 0;
-		SetupDiGetDeviceInterfaceDetail(deviceInfo, &interfaceData, NULL, 0, &requiredLength, NULL);
-		// obt@m
-		requiredLength += sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + sizeof(TCHAR);
-		PSP_DEVICE_INTERFACE_DETAIL_DATA detailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)GlobalAlloc(GMEM_FIXED, requiredLength);
-		detailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
-		// foCX̃pX擾
-		length = requiredLength;
-		if(SetupDiGetDeviceInterfaceDetail(deviceInfo, &interfaceData, detailData, length, &requiredLength, NULL) ) {
-			// path擾
-			hDev = ::CreateFile(detailData->DevicePath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
-			if( hDev == INVALID_HANDLE_VALUE ) {
-				//dwRet = ::GetLastError();
-				//if (dwRet == ERROR_ACCESS_DENIED) gp
-			}else{
-				GlobalFree(detailData);
-				break;
-			}
-		}
-		GlobalFree(detailData);
-	}
-	SetupDiDestroyDeviceInfoList(deviceInfo);
-
-	if (hDev == INVALID_HANDLE_VALUE) return NULL;
+	if (!hDev) return NULL;
 
 	EM2874Device *pDev = new EM2874Device();
 	pDev->dev = hDev;
-	if(! pDev->initDevice()) {
+	if(! pDev->initDevice(hUsbDev)) {
 		delete pDev;
 		return NULL;
 	}
 	return pDev;
 }
 
-bool EM2874Device::initDevice ()
+bool EM2874Device::initDevice (HANDLE hUsbDev)
 {
 	uint8_t val;
 
-	if(FALSE == ::WinUsb_Initialize ( this->dev, &usbHandle ))
+	if (!hUsbDev) return false;
+
+	usbHandle = hUsbDev ;
+
+	if(int ret = uthread_mutex_init(&pmutex)) {
+		warn_info(ret,"failed");
 		return false;
+	}
+
 	if( readReg(EM28XX_REG_GPIO, &val) && writeReg(EM28XX_REG_GPIO, val & ~0x1U)
 	){
 		{
@@ -157,6 +123,7 @@
 		writeReg(0x1f, 0);
 		writeReg(0x1b, 0);
 		writeReg(0x5e, 128);
+
 		writeReg( EM2874_REG_TS_ENABLE, 0 );
 		return true;
 	}
@@ -169,7 +136,7 @@
 	uint8_t val;
 	readReg(EM28XX_REG_GPIO, &val);
 	writeReg( EM28XX_REG_GPIO, ~0xc1U & val );
-	
+
 	miliWait(70);
 	readReg(EM28XX_REG_GPIO, &val);
 	writeReg( EM28XX_REG_GPIO, 0x40U | val );
@@ -178,9 +145,99 @@
 	miliWait(3);
 	::WinUsb_SetCurrentAlternateSetting( usbHandle, 1 );
 
+
 	return true;
 }
 
+BOOL EM2874Device::DoUSBCtrlTransfer(
+  WINUSB_SETUP_PACKET     SetupPacket,
+  PUCHAR                  Buffer,
+  ULONG                   BufferLength,
+  PULONG                  LengthTransferred,
+  LPOVERLAPPED            Overlapped,
+  DWORD                   &LastError
+)
+{
+	if(int r = uthread_mutex_lock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_lock failed");
+		return FALSE;
+	}
+	BOOL res = WinUsb_ControlTransfer(
+		usbHandle,
+		SetupPacket,
+		Buffer,
+		BufferLength,
+		LengthTransferred,
+		Overlapped
+	);
+	LastError = GetLastError() ;
+	if(int r = uthread_mutex_unlock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_unlock failed");
+		return FALSE;
+	}
+	return res ;
+}
+
+#ifdef EM2874_TS
+BOOL EM2874Device::DoUSBReadPipe(
+  PUCHAR                  Buffer,
+  ULONG                   BufferLength,
+  PULONG                  LengthTransferred,
+  LPOVERLAPPED            Overlapped,
+  DWORD                   &LastError
+)
+{
+	if(int r = uthread_mutex_lock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_lock failed");
+		return FALSE;
+	}
+	BOOL res = WinUsb_ReadPipe(
+		usbHandle, EM2874_EP_TS1,
+		Buffer,
+		BufferLength,
+		LengthTransferred,
+		Overlapped
+	);
+	LastError = GetLastError() ;
+	if(int r = uthread_mutex_unlock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_unlock failed");
+		return FALSE;
+	}
+	return res ;
+}
+
+BOOL EM2874Device::DoUSBGetOverlappedResult(
+  LPOVERLAPPED            Overlapped,
+  LPDWORD                 NumberOfBytesTransferred,
+  BOOL                    Wait,
+  DWORD                   &LastError
+)
+{
+	if(int r = uthread_mutex_lock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_lock failed");
+		return FALSE;
+	}
+	BOOL res = WinUsb_GetOverlappedResult(
+		usbHandle,
+		Overlapped,
+		NumberOfBytesTransferred,
+		Wait
+	);
+	LastError = GetLastError() ;
+	if(int r = uthread_mutex_unlock(pmutex)) {
+		LastError = GetLastError() ;
+		warn_info(r,"mutex_unlock failed");
+		return FALSE;
+	}
+	return res ;
+}
+#endif
+
 uint8_t EM2874Device::readReg (const uint8_t idx)
 {
 	uint8_t val;
@@ -196,10 +253,10 @@
 	spkt.Index = idx;
 	spkt.Length = 1;
 
-	ULONG ret;
-	BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)val, 1, &ret, NULL );
+	ULONG ret; DWORD err ;
+	BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)val, 1, &ret, NULL , err );
 	if( !bRet ) {
-		DBG_INFO ( "readReg LastError=%08x\n", GetLastError() );
+		DBG_INFO ( "readReg LastError=%08x\n", err );
 	}
 	return (ret == 1) && bRet;
 }
@@ -212,14 +269,32 @@
 	spkt.Index = idx;
 	spkt.Length = 1;
 
-	ULONG ret;
-	BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)&val, 1, &ret, NULL );
+	ULONG ret; DWORD err ;
+	BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)&val, 1, &ret, NULL , err );
 	if( !bRet ) {
-		DBG_INFO ( "writeReg LastError=%08x\n", GetLastError() );
+		DBG_INFO ( "writeReg LastError=%08x\n", err );
 	}
 	return (ret == 1) && bRet;
 }
 
+int EM2874Device::ctrlReg(const uint16_t reg, const uint16_t size, uint8_t* const data, const unsigned mode)
+{
+	WINUSB_SETUP_PACKET spkt;
+
+	ZeroMemory ( &spkt, sizeof(spkt) );
+	spkt.RequestType = (mode & 0x1) ? 0x40 : 0xc0;
+	spkt.Request = (mode >> 8) & 0xFF;
+	spkt.Index = reg;
+	spkt.Length = size;
+
+	ULONG ret; DWORD err;
+	if(! DoUSBCtrlTransfer ( spkt, (PUCHAR)data, size, (PULONG)&ret, NULL , err ) ) {
+		warn_info(err,"%02X_%02X", (mode >> 8) & 0xFF, reg);
+		return err;
+	}
+	return 0;
+}
+
 bool EM2874Device::readI2C (const uint8_t addr, const uint16_t size, uint8_t *data, const bool isStop)
 {
 	WINUSB_SETUP_PACKET spkt;
@@ -229,10 +304,10 @@
 	spkt.Index = addr;
 	spkt.Length = size;
 
-	ULONG ret;
-	BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)data, spkt.Length, &ret, NULL );
+	ULONG ret; DWORD err ;
+	BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)data, spkt.Length, &ret, NULL , err );
 	if( !bRet ) {
-		DBG_INFO ( "readI2C LastError=%08x\n", GetLastError() );
+		DBG_INFO ( "readI2C LastError=%08x\n", err );
 		return false;
 	}
 	readReg( 0x05, (uint8_t*)&ret );
@@ -252,10 +327,10 @@
 	spkt.Index = addr;
 	spkt.Length = size;
 
-	ULONG ret;
-	BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)data, spkt.Length, &ret, NULL );
+	ULONG ret; DWORD err;
+	BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)data, spkt.Length, &ret, NULL, err );
 	if( !bRet ) {
-		DBG_INFO ( "writeI2C LastError=%08x\n", GetLastError() );
+		DBG_INFO ( "writeI2C LastError=%08x\n", err );
 		return false;
 	}
 	readReg( 0x05, (uint8_t*)&ret );
@@ -293,11 +368,11 @@
 	spkt.Index = 0x200;
 
 	static UCHAR cmd[] = { 0x00, 0xc1, 0x01, 0xfe, 0x3e };
-	ULONG ret;
+	ULONG ret; DWORD err;
 	spkt.Length = sizeof(cmd);
-	BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, cmd, sizeof(cmd), &ret, NULL );
+	BOOL bRet = DoUSBCtrlTransfer ( spkt, cmd, sizeof(cmd), &ret, NULL, err );
 	if( !bRet ) {
-		DBG_INFO ( "writeICC LastError=%08x\n", GetLastError() );
+		DBG_INFO ( "writeICC LastError=%08x\n", err );
 		return false;
 	}
 
@@ -310,7 +385,8 @@
 
 	spkt.RequestType = 0xc0;
 	spkt.Index = 0;
-	bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, rbuff, 4, &ret, NULL );
+	DWORD err;
+	bRet = DoUSBCtrlTransfer ( spkt, rbuff, 4, &ret, NULL, err );
 	if( !bRet || rbuff[1] != 0xe1 || rbuff[3] != 0xfe )
 		return false;
 	cardPCB = 0;
@@ -355,10 +431,11 @@
 		spkt.Index = 0x200 + i;
 		spkt.Length = (val - i) > 64 ? 64 : (val - i);
 
-		BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)(cardBuf+i)
-			, spkt.Length, &ret, NULL );
+		DWORD err;
+		BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)(cardBuf+i)
+			, spkt.Length, &ret, NULL, err );
 		if( !bRet ) {
-			DBG_INFO ( "writeICC LastError=%08x\n", GetLastError() );
+			DBG_INFO ( "writeICC LastError=%08x\n", err );
 			return false;
 		}
 	}
@@ -391,10 +468,11 @@
 		spkt.Index = i;
 		spkt.Length = (val - i) > 64 ? 64 : (val - i);
 
-		BOOL bRet = ::WinUsb_ControlTransfer ( usbHandle, spkt, (PUCHAR)(cardBuf+i)
-			, spkt.Length, &ret, NULL );
+		DWORD err;
+		BOOL bRet = DoUSBCtrlTransfer ( spkt, (PUCHAR)(cardBuf+i)
+			, spkt.Length, &ret, NULL, err );
 		if( !bRet ) {
-			DBG_INFO ( "readICC LastError=%08x\n", GetLastError() );
+			DBG_INFO ( "readICC LastError=%08x\n", err );
 			return false;
 		}
 	}
@@ -413,9 +491,9 @@
 		if( val == 5 ) {
 			return i;
 		}
-		if( val == 0 ) return -1;	// card error
+		if( val == 0 ) return -1;   // card error
 	}
-	return -2;	// timeout
+	return -2;  // timeout
 }
 
 int EM2874Device::getCardStatus()
@@ -434,7 +512,7 @@
 	unsigned val;
 	// ROMŔf
 	writeReg(EM28XX_REG_I2C_CLK, 0x42);
-	buf[0] = 0; buf[1] = 0x6a;	writeI2C(EEPROM_ADDR, 2, buf, false);
+	buf[0] = 0; buf[1] = 0x6a;  writeI2C(EEPROM_ADDR, 2, buf, false);
 	if(!readI2C (EEPROM_ADDR, 2, buf, true))
 		return -1;
 	val = *(uint16_t*)buf;
@@ -444,14 +522,14 @@
 
 	// Tuner RegŔf
 	writeReg(EM28XX_REG_I2C_CLK, 0x44);
-	val = 0x00fe;	writeI2C(DEMOD_ADDR, 2, (uint8_t*)&val, true);
+	val = 0x00fe;   writeI2C(DEMOD_ADDR, 2, (uint8_t*)&val, true);
 	tuner_reg = 0x0;
 	writeI2C(TUNER_ADDR, 1, &tuner_reg, false);
 	readI2C (TUNER_ADDR, 1, &tuner_reg, true);
 	DBG_INFO ("Tuner=%02X ",tuner_reg);
-	val = 0x01fe;	writeI2C(DEMOD_ADDR, 2, (uint8_t*)&val, true);
+	val = 0x01fe;   writeI2C(DEMOD_ADDR, 2, (uint8_t*)&val, true);
 
-	if(tuner_reg == 0x84)	// TDA18271HD
+	if(tuner_reg == 0x84)   // TDA18271HD
 		return 1;
 
 	return 2;
@@ -459,7 +537,12 @@
 
 #ifdef EM2874_TS
 
-void EM2874Device::SetBuffer(void *pBuf)
+bool EM2874Device::WriteBackEnabled()
+{
+	return TSFifo.begin_func && TSFifo.finish_func ;
+}
+
+void EM2874Device::SetBuffer(void *pBuf, const struct tsfifo_t * const pTSFifo)
 {
 	TsBuffSize = (int32_t*)pBuf;
 	if(pBuf) {
@@ -467,13 +550,17 @@
 
 		TsBuffSize[RINGBUFF_SIZE] = -2;
 		TsBuffSize[0x3ff] = -USBBULK_XFERSIZE;
+	}else TsBuff = NULL ;
+	ZeroMemory(&TSFifo,sizeof(TSFifo)) ;
+	if(pTSFifo) {
+	  CopyMemory(&TSFifo,pTSFifo,sizeof(TSFifo)) ;
 	}
 }
 
 bool EM2874Device::TransferStart()
 {
-	if(TsBuffSize == NULL)	return false;
-	if(hTsEvent)	return true;
+	if(TsBuffSize == NULL&&!WriteBackEnabled()) return false;
+	if(hTsEvent)    return true;
 
 	if( readReg(0x0B) & 0x2 ) {
 		// Isochronous]ݒȂ  (Ŏ~߂ȂƁA낢뎀ʁB)
@@ -510,12 +597,14 @@
 {
 	writeReg( EM2874_REG_TS_ENABLE, 0 );
 	if(hTsEvent == NULL) return;
-	::WinUsb_AbortPipe( usbHandle, EM2874_EP_TS1 );
+	if(!(readReg(0x0B)&0x2))
+		::WinUsb_AbortPipe( usbHandle, EM2874_EP_TS1 );
 }
 
 void EM2874Device::TransferResume()
 {
-	writeReg( EM2874_REG_TS_ENABLE, EM2874_TS1_CAPTURE_ENABLE | EM2874_TS1_NULL_DISCARD );
+	writeReg( EM2874_REG_TS_ENABLE,
+		EM2874_TS1_CAPTURE_ENABLE | EM2874_TS1_NULL_DISCARD );
 	if(hTsEvent != NULL) {
 		::SetEvent(hTsEvent);
 	}
@@ -525,16 +614,20 @@
 {
 	int nRet;
 	int cnt;
-	for(cnt = 0; ; cnt++) {
+	for(cnt = 0; cnt<NUM_IOHANDLE ; cnt++) {
 		nRet = GetOverlappedResult();
 		if(nRet == -1) {
 			// TS] ҂
 			break;
 		}else if(nRet >= 0) {
 			// TS] ̓]v
-			BeginAsyncRead();
-			if(OverlappedIoIndex < (NUM_IOHANDLE-1)) OverlappedIoIndex++;
-			else OverlappedIoIndex = 0;
+			if(BeginAsyncRead()) {
+				if(OverlappedIoIndex < (NUM_IOHANDLE-1)) OverlappedIoIndex++;
+				else OverlappedIoIndex = 0;
+			}else {
+				// obt@s
+				break ;
+			}
 		}else{
 			// TS] I
 			return -1;
@@ -544,20 +637,28 @@
 	return cnt;
 }
 
-int EM2874Device::BeginAsyncRead()
+bool EM2874Device::BeginAsyncRead()
 {
-	DWORD dRet = TsBuffIndex;
-	TsBuffIndex = (dRet < (RINGBUFF_SIZE-1)) ? dRet + 1 : 0;
-
-	TsBuffSize[dRet] = -1;
-	IoContext[OverlappedIoIndex].index = dRet;
+	DWORD dRet ;
 
 	::ZeroMemory(&IoContext[OverlappedIoIndex].ol, sizeof(OVERLAPPED));
 	IoContext[OverlappedIoIndex].ol.hEvent = hTsEvent;
 
-	BOOL bRet = ::WinUsb_ReadPipe ( usbHandle, EM2874_EP_TS1, TsBuff + dRet*USBBULK_XFERSIZE, USBBULK_XFERSIZE, NULL, &IoContext[OverlappedIoIndex].ol );
+	BOOL bRet ; DWORD err ;
+	if(WriteBackEnabled()) {
+		IoContext[OverlappedIoIndex].index = OverlappedIoIndex ;
+		void *buffer = TSFifo.begin_func(OverlappedIoIndex, USBBULK_XFERSIZE, TSFifo.arg) ;
+		if(!buffer) return false ;
+		bRet = DoUSBReadPipe ( (BYTE*)buffer, USBBULK_XFERSIZE, NULL, &IoContext[OverlappedIoIndex].ol, err );
+	}else if(TsBuff) {
+		dRet = TsBuffIndex ;
+		TsBuffIndex = (dRet < (RINGBUFF_SIZE-1)) ? dRet + 1 : 0;
+		TsBuffSize[dRet] = -1;
+		IoContext[OverlappedIoIndex].index = dRet;
+		bRet = DoUSBReadPipe ( TsBuff + dRet*USBBULK_XFERSIZE, USBBULK_XFERSIZE, NULL, &IoContext[OverlappedIoIndex].ol, err );
+	}else return false ;
 #if 0
-	dRet = ::GetLastError();
+	dRet = err ;
 	if( bRet == FALSE && dRet != ERROR_IO_PENDING ) DBG_INFO ("ReadP=%u ",dRet);
 	if( bRet ) {
 		DBG_INFO ("ReadPs=%u ",dRet);
@@ -567,16 +668,15 @@
 		// NOWAITŊ
 		::SetEvent(hTsEvent);
 	}
-	return 0;
+	return true;
 }
 
 int EM2874Device::GetOverlappedResult()
 {
 	if(hTsEvent == NULL) return -2;
-	ULONG bytesRead = 0;
-	if(FALSE == ::WinUsb_GetOverlappedResult ( usbHandle, &IoContext[OverlappedIoIndex].ol, &bytesRead, FALSE )) {
-		DWORD dwRet = ::GetLastError();
-		switch(dwRet) {
+	ULONG bytesRead = 0; DWORD err ;
+	if(FALSE == DoUSBGetOverlappedResult ( &IoContext[OverlappedIoIndex].ol, &bytesRead, FALSE, err )) {
+		switch(err) {
 			case ERROR_SEM_TIMEOUT:
 			case ERROR_OPERATION_ABORTED:
 				DBG_INFO ("RdAbort%u ",bytesRead);
@@ -589,13 +689,106 @@
 				break;
 		}
 	}
-	if(TsBuffSize == NULL) return -2;
-	const unsigned idx = IoContext[OverlappedIoIndex].index;
-	TsBuffSize[idx] = bytesRead;
+	if(WriteBackEnabled()) {
+		TSFifo.finish_func(OverlappedIoIndex,bytesRead,TSFifo.arg) ;
+	}else {
+		if(TsBuffSize == NULL) return -2;
+		const unsigned idx = IoContext[OverlappedIoIndex].index;
+		TsBuffSize[idx] = bytesRead;
+	}
+
 	return bytesRead;
 }
 
 HANDLE EM2874Device::GetHandle()
 { return hTsEvent; }
 
+int EM2874Device::GetTsBuffIndex()
+{ return TsBuffIndex; }
+
+#endif
+
+#ifdef EM2874_USBEP
+
+extern "C" int TSCACHING_DROPNULLPACKETS ;
+int EM2874Device::USBEndPointStartStopFunc(void * const  dev, const int start)
+{
+	EM2874Device *this_ = static_cast<EM2874Device*>(dev) ;
+	if(start) {
+		this_->writeReg( EM2874_REG_TS_ENABLE, EM2874_TS1_CAPTURE_ENABLE |
+			( TSCACHING_DROPNULLPACKETS ? EM2874_TS1_NULL_DISCARD : 0 ) );
+	}else {
+		this_->writeReg( EM2874_REG_TS_ENABLE, 0 );
+	}
+	return 0 ;
+}
+
+int EM2874Device::USBEndPointLockUnlockFunc(void * const  dev, const int lock)
+{
+	EM2874Device *this_ = static_cast<EM2874Device*>(dev) ;
+	int r ;
+	if(lock) {
+		r = uthread_mutex_lock(this_->pmutex) ;
+	}else {
+		r = uthread_mutex_unlock(this_->pmutex) ;
+	}
+	if(r) warn_info(r,"failed");
+	return r;
+}
+
+extern "C" int TSCACHING_BULKPACKETSIZE;
+void EM2874Device::SetupUSBEndPoint(usb_endpoint_st *usb_ep)
+{
+	usb_ep->dev=this ;
+	usb_ep->fd=usbHandle ;
+	usb_ep->endpoint = EM2874_EP_TS1 ;
+	if( readReg(0x0B)&0x2 ) usb_ep->endpoint |= 0x100 /*ISOCH*/ ;
+#if 1
+	if( usb_ep->endpoint&0x100 ) { /* Isochronous (ύXK0905) */
+		int n=
+		#ifdef INCLUDE_ISOCH_XFER
+		ISOCH_FrameSize/188
+		#else
+		5
+		#endif
+		;
+		//# set Isochronous transfer size (unit: packet)
+		writeReg(0x5e, (uint8_t)(n) );
+		usb_ep->xfer_size = n * 188UL ;
+	}else { /* BULK (PatchV2Kp) */
+		int packet_size = TSCACHING_BULKPACKETSIZE>0 ?
+			TSCACHING_BULKPACKETSIZE : TS_PacketSize ;
+		int n = packet_size/188 ;
+		if(n>=256) n=256 ; else if(n<=0) n=1 ;
+		//# set BULK transfer size (unit: packet)
+		writeReg(0x5d, (uint8_t)(n - 1) );
+		usb_ep->xfer_size = n>=256 ? packet_size : n * 188UL ;
+	}
+#else
+	#ifdef INCLUDE_ISOCH_XFER
+		usb_ep->xfer_size = usb_ep->endpoint&0x100 ?
+			ISOCH_FrameSize/*ύXK0905*/: TS_PacketSize/*PatchV2Kp*/;
+	#else
+		usb_ep->xfer_size = TS_PacketSize ;
+	#endif
 #endif
+	usb_ep->startstopFunc = USBEndPointStartStopFunc;
+	usb_ep->lockunlockFunc = USBEndPointLockUnlockFunc;
+}
+
+void EM2874Device::CleanupUSBEndPoint(usb_endpoint_st *usb_ep)
+{
+	if (usb_ep&&usb_ep->dev == this) {
+		if(usb_ep->startstopFunc==USBEndPointStartStopFunc)
+			USBEndPointStartStopFunc(this, 0);
+		usb_ep->dev = NULL;
+		usb_ep->fd = NULL;
+		usb_ep->endpoint = 0;
+		usb_ep->xfer_size = 0;
+		usb_ep->startstopFunc = NULL;
+		usb_ep->lockunlockFunc = NULL ;
+	}
+}
+
+#endif
+
diff -uPr BonD_FSHybrid-20201009_org/src/em2874.h BonD_FSHybrid-20201009_mod2/src/em2874.h
--- BonD_FSHybrid-20201009_org/src/em2874.h	2012-09-28 01:32:17.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/em2874.h	2020-10-06 04:54:40.000000000 +0900
@@ -1,6 +1,9 @@
 #pragma once
 
 #include <WinUSB.h>
+extern "C" {
+#include "osdepend.h"
+}
 
 typedef unsigned char	uint8_t;
 typedef unsigned short	uint16_t;
@@ -28,34 +31,80 @@
 #define EM2874_TS1_FILTER_ENABLE  0x02
 #define EM2874_TS1_NULL_DISCARD   0x04
 
-#define EM2874_TS
+//#define EM2874_TS
 
 #ifdef EM2874_TS
-#define USBBULK_XFERSIZE	(0xBC00)
-#define RINGBUFF_SIZE	60
-#define NUM_IOHANDLE	16
+	#define USBBULK_XFERSIZE	(0xBC00)
+	#define RINGBUFF_SIZE	48
+	#define NUM_IOHANDLE	36
 #endif
 
+#define EM2874_USBEP
+
+#ifdef EM2874_USBEP
+extern "C" {
+#include "types_u.h"
+#include "tsbuff.h"
+}
+#endif
+
+
 typedef struct _TSIO_CONTEXT {
 
-    OVERLAPPED ol;
+	OVERLAPPED ol;
 	unsigned index;
 
 } TSIO_CONTEXT;
 
 class EM2874Device
 {
+#ifdef EM2874_TS
+public:
+	typedef void *(*write_back_begin_func_t)(int id, size_t max_size, void *arg) ;
+	typedef void (*write_back_finish_func_t)(int id, size_t wrote_size, void *arg) ;
+	struct tsfifo_t {
+		write_back_begin_func_t begin_func;
+		write_back_finish_func_t finish_func;
+		void *arg;
+	};
+#endif
 private:
 	EM2874Device ();
 	bool resetICC_1 ();
 	bool resetICC_2 ();
-	
+
 	HANDLE dev;
 	WINUSB_INTERFACE_HANDLE usbHandle;
 	uint8_t cardPCB;
 
+	PMUTEX pmutex;
+
+	BOOL DoUSBCtrlTransfer(
+	  WINUSB_SETUP_PACKET     SetupPacket,
+	  PUCHAR                  Buffer,
+	  ULONG                   BufferLength,
+	  PULONG                  LengthTransferred,
+	  LPOVERLAPPED            Overlapped,
+	  DWORD                   &LastError
+	);
+
 #ifdef EM2874_TS
-	int BeginAsyncRead();
+	BOOL DoUSBReadPipe(
+	  PUCHAR                  Buffer,
+	  ULONG                   BufferLength,
+	  PULONG                  LengthTransferred,
+	  LPOVERLAPPED            Overlapped,
+	  DWORD                   &LastError
+	);
+
+	BOOL DoUSBGetOverlappedResult(
+	  LPOVERLAPPED            Overlapped,
+	  LPDWORD                 NumberOfBytesTransferred,
+	  BOOL                    Wait,
+	  DWORD                   &LastError
+	);
+
+	bool BeginAsyncRead();
 	int GetOverlappedResult();
 
 	uint8_t *TsBuff;
@@ -64,19 +113,21 @@
 	int OverlappedIoIndex;
 	HANDLE hTsEvent;
 	TSIO_CONTEXT IoContext[NUM_IOHANDLE];
+	tsfifo_t TSFifo ;
 	DWORD dwtLastRead;
 #endif
 
 public:
 	EM2874Device (HANDLE hDev);
 	~EM2874Device ();
-	static EM2874Device* AllocDevice(int &idx);
-	bool initDevice ();
+	static EM2874Device* AllocDevice(HANDLE hDev,HANDLE hUsbDev);
+	bool initDevice (HANDLE hUsbDev);
 	bool initDevice2 ();
 
 	uint8_t readReg (const uint8_t idx);
 	bool readReg (const uint8_t idx, uint8_t *val);
 	bool writeReg (const uint8_t idx, const uint8_t val);
+	int ctrlReg(const uint16_t reg, const uint16_t size, uint8_t* const data, const unsigned mode);
 	bool readI2C (const uint8_t addr, const uint16_t size, uint8_t *data, const bool isStop);
 	bool writeI2C (const uint8_t addr, const uint16_t size, uint8_t *data, const bool isStop);
 
@@ -93,12 +144,21 @@
 	static unsigned UserSettings;
 
 #ifdef EM2874_TS
-	void SetBuffer(void *pBuf);
+	bool WriteBackEnabled() ;
+	void SetBuffer(void *pBuf, const struct tsfifo_t * const pTSFifo=NULL);
 	bool TransferStart();
 	void TransferStop();
 	void TransferPause();
 	void TransferResume();
 	int DispatchTSRead();
 	HANDLE GetHandle();
+	int GetTsBuffIndex();
+#endif
+
+#ifdef EM2874_USBEP
+	static int USBEndPointStartStopFunc(void * const  dev, const int start);
+	static int USBEndPointLockUnlockFunc(void * const  dev, const int lock);
+	void SetupUSBEndPoint(usb_endpoint_st *usb_ep) ;
+	void CleanupUSBEndPoint(usb_endpoint_st *usb_ep) ;
 #endif
 };
diff -uPr BonD_FSHybrid-20201009_org/src/em287x.c BonD_FSHybrid-20201009_mod2/src/em287x.c
--- BonD_FSHybrid-20201009_org/src/em287x.c	2016-02-10 04:35:36.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/em287x.c	2020-10-11 23:26:56.000000000 +0900
@@ -14,6 +14,7 @@
 #include "em287x_usb.h"
 #include "em287x_priv.h"
 #include "message.h"
+#include "tsbuff.h"
 
 #define ARRAY_SIZE(x)  (sizeof(x)/(sizeof(x[0])))
 
@@ -240,6 +241,7 @@
 
 /* public function */
 
+extern int TSCACHING_BULKPACKETSIZE;
 int em287x_create(em287x_state* const  state, struct usb_endpoint_st * const pusbep)
 {
 	int ret;
@@ -263,6 +265,7 @@
 	pusbep->endpoint = EP_TS1;
 	pusbep->dev = st;
 	pusbep->startstopFunc = em287x_startstopStream;
+	pusbep->lockunlockFunc = em287x_lockunlockMutex;
 	st->chip_id = 0;
 	st->fd = pusbep->fd;
 	if(( ret = usb_claim(st->fd, 0) )) {
@@ -281,14 +284,25 @@
 	//# TS endpoint
 	if(( ret = readReg(st, 0x0b, &utmp) ))  { warn_info(ret,"failed"); return -8; }
 	if( utmp & 0x02 ) {
+		int n=
+		#ifdef INCLUDE_ISOCH_XFER
+		ISOCH_FrameSize/188
+		#else
+		5
+		#endif
+		;
 		//# set Isochronous transfer size (unit: packet)
-		if(( ret = writeReg(st, 0x5e, 5 ) ))  { warn_info(ret,"failed"); return -8; }
+		if(( ret = writeReg(st, 0x5e, (uint8_t)(n) ) ))  { warn_info(ret,"failed"); return -8; }
 		pusbep->endpoint |= 0x100;
-		pusbep->xfer_size = 188 * 5;
+		pusbep->xfer_size = n * 188UL ;
 	}else{
+		int packet_size = TSCACHING_BULKPACKETSIZE>0 ?
+			TSCACHING_BULKPACKETSIZE : TS_PacketSize ;
+		int n = packet_size/188 ;
+		if(n>=256) n=256 ; else if(n<=0) n=1 ;
 		//# set BULK transfer size (unit: packet)
-		if(( ret = writeReg(st, 0x5d, 245 - 1 ) ))  { warn_info(ret,"failed"); return -8; }
-		pusbep->xfer_size = 188 * 245;
+		if(( ret = writeReg(st, 0x5d, (uint8_t)(n - 1) ) ))  { warn_info(ret,"failed"); return -8; }
+		pusbep->xfer_size = n>=256 ? packet_size : n * 188UL ;
 	}
 
 	dmsg(" em287x init done!");
@@ -328,6 +342,7 @@
 	i2c_dev->i2c_comm = (void*)em287x_I2C;
 }
 
+extern int TSCACHING_DROPNULLPACKETS ;
 int em287x_startstopStream(const em287x_state state, const int start)
 {
 	int r;
@@ -337,7 +352,7 @@
 		r = readReg(s, 0x5f, &utmp);
 		if( r ) { warn_info(r,"failed");  return -5; }
 		if(utmp & 0x08) { warn_msg(0,"TS encrypt detected!"); }
-		utmp = (utmp & 0xF0) | 0x05;
+		utmp = (utmp & 0xF0) | 0x01 | (TSCACHING_DROPNULLPACKETS?0x04:0) ;
 		r = em287x_ctrl(s->fd, 0x785f, 1, &utmp, 0x1401);
 		if( r ) { warn_info(r,"failed");  return -6; }
 	}else{  //# stop
@@ -347,6 +362,21 @@
 	return 0;
 }
 
+int em287x_lockunlockMutex(const em287x_state state, const int lock)
+{
+	int r = 0;
+	struct state_st* const s = state;
+
+	if(lock) {
+		if((r = uthread_mutex_lock(s->pmutex))) goto err1 ;
+	}else {
+		if((r = uthread_mutex_unlock(s->pmutex))) goto err1 ;
+	}
 
+	return 0;
+err1:
+	warn_info(r,"failed");
+	return r;
+}
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/em287x.h BonD_FSHybrid-20201009_mod2/src/em287x.h
--- BonD_FSHybrid-20201009_org/src/em287x.h	2016-01-18 20:58:56.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/em287x.h	2020-04-27 00:44:36.000000000 +0900
@@ -4,7 +4,16 @@
   2016-01-18
 */
 #pragma once
+#ifdef LEGACY_STDINT
+
+#include "stdint_.h"
+
+#else
+
 #include <stdint.h>
+
+#endif
+
 #include "types_u.h"
 
 typedef void* em287x_state;
@@ -13,5 +22,6 @@
 int em287x_destroy(const em287x_state);
 void em287x_attach(const em287x_state, struct i2c_device_st* const);
 int em287x_startstopStream(const em287x_state, const int start);
+int em287x_lockunlockMutex(const em287x_state state, const int lock);
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/em287x_usb.h BonD_FSHybrid-20201009_mod2/src/em287x_usb.h
--- BonD_FSHybrid-20201009_org/src/em287x_usb.h	2016-01-22 08:51:48.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/em287x_usb.h	2019-12-16 06:15:18.000000000 +0900
@@ -4,8 +4,17 @@
   2016-01-22
 */
 #pragma once
+#ifdef LEGACY_STDINT
+
+#include "stdint_.h"
+
+#else
+
 #include <stdint.h>
 
+#endif
+
+
 #define USB_TIMEOUT 400   //# USB ctrl timeout (msec)
 
 int em287x_ctrl(HANDLE fd, const uint16_t reg, const uint16_t size, uint8_t* const data, const unsigned mode);
diff -uPr BonD_FSHybrid-20201009_org/src/inc/legacy/stdint_.h BonD_FSHybrid-20201009_mod2/src/inc/legacy/stdint_.h
--- BonD_FSHybrid-20201009_org/src/inc/legacy/stdint_.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/inc/legacy/stdint_.h	2016-02-14 14:43:10.000000000 +0900
@@ -0,0 +1,11 @@
+#pragma once
+
+typedef __int8 int8_t ;
+typedef __int16 int16_t ;
+typedef __int32 int32_t ;
+typedef __int64 int64_t ;
+
+typedef unsigned __int8 uint8_t ;
+typedef unsigned __int16 uint16_t ;
+typedef unsigned __int32 uint32_t ;
+typedef unsigned __int64 uint64_t ;
diff -uPr BonD_FSHybrid-20201009_org/src/it9175.c BonD_FSHybrid-20201009_mod2/src/it9175.c
--- BonD_FSHybrid-20201009_org/src/it9175.c	2016-02-18 20:13:22.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/it9175.c	2020-10-11 23:37:28.000000000 +0900
@@ -14,8 +14,7 @@
 #include "it9175_usb.h"
 #include "it9175_priv.h"
 #include "message.h"
-
-#define TS_BulkSize  305
+#include "tsbuff.h"
 
 #define ARRAY_SIZE(x)  (sizeof(x)/(sizeof(x[0])))
 
@@ -371,6 +370,8 @@
 }
 
 /* initialize tuner, demod, USB interface */
+extern int TSCACHING_BULKPACKETSIZE;
+extern int TSCACHING_DROPNULLPACKETS;
 static int it9175_tuner_init(struct state_st* const st)
 {
 	int ret;
@@ -501,7 +502,9 @@
 		if((ret = writeRegTable(st, init3_mtab, ARRAY_SIZE(init3_mtab)))) goto err1;
 	}
 	{//# frame size, packet size= 512 /4 = 128
-		const unsigned TS_FrameSize = TS_BulkSize * 188 / 4;
+		unsigned TS_FrameSize = (TSCACHING_BULKPACKETSIZE>0 ?
+			TSCACHING_BULKPACKETSIZE : TS_PacketSize) / 4;
+		if(TS_FrameSize>=65536) TS_FrameSize=65535;
 		rbuf[0] = TS_FrameSize & 0xFF;
 		rbuf[1] = (TS_FrameSize >> 8) & 0xFF;
 		if((ret = writeRegs(st, 0xdd88, rbuf, 2))) goto err1;
@@ -511,8 +514,9 @@
 		const struct reg_val_mask init4_mtab[] = {
 			{0x80f985, 0x00, 0x01},   //# serial mode = F
 			{0x80f986, 0x00, 0x01},   //# parallel mode = F
+			// note: it9175 tuner init disables
 			{0x80f9a3, 0x00, 0x01},   //# stream2 disable
-			{0x80f9cd, 0x00, 0x01},   //# TS disable
+			//{0x80f9cd, 0x00, 0x01},   //# TS disable
 			{0x80f99d, 0x00, 0x01},   //# stream1 reset = F
 			{0x80f9a4, 0x00, 0x01},   //# stream2 reset = F
 			{0xd8fd, 0x01, 0},
@@ -531,7 +535,7 @@
 		};
 		if((ret = writeRegTable(st, init4_mtab, ARRAY_SIZE(init4_mtab)))) goto err1;
 	}
-	{//# PID filter
+	if(TSCACHING_DROPNULLPACKETS){//# PID filter
 		rbuf[0] = 0xFF;  rbuf[1] = 0x1F;
 		if((ret = writeRegs(st, 0x80f996, rbuf, 2))) goto err1;
 		if((ret = writeReg(st, 0x80f995, 0))) goto err1;
@@ -650,7 +654,7 @@
 	iqik_m_cal = (0 == st->clock_d) ? (ret * 9) >> 5 :  ret >> 1;
 
 	if((ret = writeReg(st, 0x800160, lna_band))) goto err1;
-	
+
 	{//# bandwidth
 		const uint8_t reg80ec56[4] = {2, 4, 6, 0};
 		if((ret = writeReg(st, 0x80ec56, reg80ec56[st->bw_mode]))) goto err1;
@@ -710,8 +714,11 @@
 		return -2;
 	}
 	pusbep->endpoint = EP_TS1;
+	pusbep->dev = st ;
 	pusbep->startstopFunc = NULL;
-	pusbep->xfer_size = TS_BulkSize * 188;
+	pusbep->lockunlockFunc = it9175_lockunlockMutex;
+	pusbep->xfer_size = TSCACHING_BULKPACKETSIZE>0 ?
+		TSCACHING_BULKPACKETSIZE: TS_PacketSize;
 	st->chip_id = 0;
 	st->fd = pusbep->fd;
 
@@ -872,11 +879,11 @@
 }
 
 /* Transmission and Multiplexing Configuration and Control (See ARIB STD-B31) */
-int it9175_readTMCC(const it9175_state state, void* const pData)
+int it9175_readTMCC(const it9175_state state, struct TMCC_data* const pData)
 {
 	int ret, j;
 	struct state_st* const s = state;
-	uint8_t rbuf[4], val, *ptr = pData, txmode;
+	uint8_t rbuf[4], val, *ptr = (uint8_t*) pData, txmode;
 	const uint8_t n_txmod[4] = {1,3,2,0};
 
 	if((ret = readRegs(s, 0x80f900, rbuf, 3))) goto err1;
@@ -946,4 +953,35 @@
 	return ret;
 }
 
+int it9175_readSNRatio(const it9175_state state, uint8_t* const dB)
+{
+	int ret = 0;
+	struct state_st* const st = state;
+	uint8_t rbuf[1];
+	//# S/N Ratio (dB)
+	if((ret = readRegs(st, 0x8001c9, rbuf, 1))) goto err1;
+	dB[0] = *rbuf;
+
+	return 0;
+err1:
+	return ret;
+}
+
+int it9175_lockunlockMutex(const it9175_state state, const int lock)
+{
+	int ret = 0;
+	struct state_st* const st = state;
+
+	if(lock) {
+		if((ret = uthread_mutex_lock(st->pmutex))) goto err1 ;
+	}else {
+		if((ret = uthread_mutex_unlock(st->pmutex))) goto err1 ;
+	}
+
+	return 0;
+err1:
+	warn_info(ret,"failed");
+	return ret;
+}
+
 /*EOF*/
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/it9175.h BonD_FSHybrid-20201009_mod2/src/it9175.h
--- BonD_FSHybrid-20201009_org/src/it9175.h	2015-12-09 15:31:26.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/it9175.h	2020-04-27 00:44:38.000000000 +0900
@@ -4,7 +4,11 @@
   2015-12-09
 */
 #pragma once
+#ifdef LEGACY_STDINT
+#include "stdint_.h"
+#else
 #include <stdint.h>
+#endif
 #include "types_u.h"
 
 typedef void* it9175_state;
@@ -22,5 +26,8 @@
 int it9175_readTMCC(const it9175_state, struct TMCC_data* const);
 
 int it9175_readStatistic(const it9175_state, uint8_t* const data);
+int it9175_readSNRatio(const it9175_state, uint8_t* const dB);
 
-/*EOF*/
\ ե˲Ԥޤ
+int it9175_lockunlockMutex(const it9175_state, const int lock);
+
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/it9175_usb.h BonD_FSHybrid-20201009_mod2/src/it9175_usb.h
--- BonD_FSHybrid-20201009_org/src/it9175_usb.h	2015-12-25 02:54:06.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/it9175_usb.h	2019-12-16 06:15:18.000000000 +0900
@@ -4,9 +4,13 @@
   2015-12-25
 */
 #pragma once
+#ifdef LEGACY_STDINT
+#include "stdint_.h"
+#else
 #include <stdint.h>
+#endif
 
 int it9175_ctrl_msg(void* const, const uint8_t cmd, const uint8_t mbox, const uint8_t wrlen, const uint8_t rdlen);
 int it9175_usbSetTimeout(void* const pst);
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/ktv.cpp BonD_FSHybrid-20201009_mod2/src/ktv.cpp
--- BonD_FSHybrid-20201009_org/src/ktv.cpp	2012-09-28 02:12:44.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/ktv.cpp	2020-05-07 13:28:34.000000000 +0900
@@ -1,6 +1,5 @@
 
 #include "stdafx.h"
-#include "../twindbg.h"
 
 #include "ktv.h"
 
@@ -29,7 +28,7 @@
 bool KtvDevice::DeMod_Write (const uint8_t idx, const uint8_t val)
 {
 	usbDev->writeReg(EM28XX_REG_I2C_CLK, 0x44);
-	uint8_t buf[] = {idx, val};
+    uint8_t buf[] = {idx, val};
 	return usbDev->writeI2C(DEMOD_ADDR, 2, buf, true);
 }
 
@@ -241,7 +240,7 @@
 		0x00, 0x00, 0x96, 0x33, 0xc1, 0x00, 0x8f, 0x00,
 		0x00, 0x8c, 0x00, 0x20, 0xb3, 0x48, 0xb0,
 	// Setup AGC1 gain
-	0x20, 0x01, 0x00, 
+	0x20, 0x01, 0x00,
 	0x20, 0x01, 0x03,
 	0x20, 0x01, 0x43,
 	0x20, 0x01, 0x4c,
@@ -415,7 +414,7 @@
 	};
 
 	tuner_r[0x07] ^= (::binarySearch( ir_measure, TBL_SZ( ir_measure ), freq_khz ) ^ tuner_r[0x07]) & 0x07;
-	
+
 	tuner_r[0x10] &= ~0x03;
 	Tuner_RegWrite(0x10, 1);
 
@@ -632,14 +631,13 @@
 
 Ktv2Device::~Ktv2Device()
 {
-	static uint8_t rData[] = { 0x01,0, 0x0f,0 };
 	if( usbDev != NULL ) {
-		Tuner_I2C_Write(rData, TBL_SZ(rData));	// enter standby mode
+		SleepTuner();
 	}
 }
 
 void Ktv2Device::InitTuner ()
-{	
+{
 	static uint8_t initData[] = {
 		0x02,0x00, 0x03,0x40, 0x05,0x04, 0x06,0x10,
 		0x2e,0x15, 0x30,0x10, 0x45,0x58, 0x48,0x19,
@@ -653,6 +651,13 @@
 	Tuner_InitDone = true;
 }
 
+bool Ktv2Device::SleepTuner ()
+{
+	static uint8_t rData[] = { 0x01,0, 0x0f,0 };
+	Tuner_I2C_Write(rData, TBL_SZ(rData));	// enter standby mode
+    return true ;
+}
+
 void Ktv2Device::SetFrequency (unsigned int freq_khz)
 {
 	static uint8_t tuneData[] = {
diff -uPr BonD_FSHybrid-20201009_org/src/ktv.h BonD_FSHybrid-20201009_mod2/src/ktv.h
--- BonD_FSHybrid-20201009_org/src/ktv.h	2012-09-28 01:39:22.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/ktv.h	2020-06-18 09:44:24.000000000 +0900
@@ -10,12 +10,13 @@
 class KtvDevice {
 public:
 	KtvDevice (EM2874Device *pDev);
-	~KtvDevice();
+	virtual ~KtvDevice();
 
 	virtual void InitTuner () = 0;
 	virtual void SetFrequency (unsigned int freq_khz) = 0;
 	virtual void InitDeMod () = 0;
 	virtual void ResetDeMod () = 0;
+    virtual bool SleepTuner () = 0;
 	uint8_t DeMod_GetSequenceState();
 	unsigned int DeMod_GetQuality();
 	unsigned DeMod_GetBER(int *pVal);
@@ -40,12 +41,13 @@
 {
 public:
 	Ktv1Device (EM2874Device *pDev);
-	~Ktv1Device();
+	virtual ~Ktv1Device();
 
 	void InitTuner ();
 	void SetFrequency (unsigned int freq_khz);
 	void InitDeMod ();
 	void ResetDeMod ();
+    bool SleepTuner () { return false ; }
 
 private:
 	void Tuner_RegWrite (const uint8_t offset, const int len);
@@ -61,9 +63,10 @@
 {
 public:
 	Ktv2Device (EM2874Device *pDev);
-	~Ktv2Device();
+	virtual ~Ktv2Device();
 
 	void InitTuner ();
+    bool SleepTuner();
 	void SetFrequency (unsigned int freq_khz);
 	void InitDeMod ();
 	void ResetDeMod ();
diff -uPr BonD_FSHybrid-20201009_org/src/mxl136.c BonD_FSHybrid-20201009_mod2/src/mxl136.c
--- BonD_FSHybrid-20201009_org/src/mxl136.c	2016-01-27 14:53:38.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/mxl136.c	2019-12-16 06:15:18.000000000 +0900
@@ -4,7 +4,16 @@
   2016-01-27
 */
 
+#ifdef LEGACY_STDINT
+
+#include "stdint_.h"
+
+#else
+
 #include <stdint.h>
+
+#endif
+
 #include <errno.h>
 #include <string.h>
 #include <malloc.h>
@@ -183,4 +192,4 @@
 }
 
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/osdepend.c BonD_FSHybrid-20201009_mod2/src/osdepend.c
--- BonD_FSHybrid-20201009_org/src/osdepend.c	2015-12-12 02:20:38.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/osdepend.c	2020-05-16 08:28:04.000000000 +0900
@@ -7,6 +7,8 @@
 #include "stdafx.h"
 #include "osdepend.h"
 
+#define UTHREAD_MUTEX_AS_CRITICAL_SECTION
+
 void miliWait(unsigned msec)
 {
 	Sleep(msec);
@@ -24,6 +26,17 @@
 
 int uthread_mutex_init(PMUTEX *p)
 {
+#ifdef UTHREAD_MUTEX_AS_CRITICAL_SECTION
+	if(NULL == p)
+		return -1;
+	if(NULL == *p) {
+		CRITICAL_SECTION *sec_p=uHeapAlloc(sizeof(CRITICAL_SECTION));
+		if(sec_p==NULL) return ERROR_NOT_ENOUGH_MEMORY;
+		InitializeCriticalSection(sec_p);
+		*p=(PMUTEX)sec_p;
+	}
+	return 0;
+#else
 	if(NULL == p)
 		return -1;
 	if(NULL == *p) {
@@ -31,25 +44,45 @@
 		if(NULL == *p) return GetLastError();
 	}
 	return 0;
+#endif
 }
 
 int uthread_mutex_lock(PMUTEX p)
 {
+#ifdef UTHREAD_MUTEX_AS_CRITICAL_SECTION
+	if(p==NULL) return ERROR_INVALID_HANDLE;
+	EnterCriticalSection((CRITICAL_SECTION*)p) ;
+	return 0;
+#else
 	const DWORD dRet = WaitForSingleObject(p, 10000);
 	if(WAIT_FAILED == dRet) return GetLastError();
 	return dRet;
+#endif
 }
 
 int uthread_mutex_unlock(PMUTEX p)
 {
+#ifdef UTHREAD_MUTEX_AS_CRITICAL_SECTION
+	if(p==NULL) return ERROR_INVALID_HANDLE;
+	LeaveCriticalSection((CRITICAL_SECTION*)p) ;
+	return 0;
+#else
 	if(ReleaseMutex(p) == 0) return GetLastError();
 	return 0;
+#endif
 }
 
 int uthread_mutex_destroy(PMUTEX p)
 {
+#ifdef UTHREAD_MUTEX_AS_CRITICAL_SECTION
+	if(p==NULL) return ERROR_INVALID_HANDLE;
+	DeleteCriticalSection((CRITICAL_SECTION*)p);
+	uHeapFree(p);
+	return 0;
+#else
 	if(CloseHandle(p) == 0) return GetLastError();
 	return 0;
+#endif
 }
 
 /*EOF*/
\ ե˲Ԥޤ
diff -uPr BonD_FSHybrid-20201009_org/src/pryutil.cpp BonD_FSHybrid-20201009_mod2/src/pryutil.cpp
--- BonD_FSHybrid-20201009_org/src/pryutil.cpp	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/pryutil.cpp	2020-02-09 18:20:40.000000000 +0900
@@ -0,0 +1,562 @@
+//===========================================================================
+#include "stdafx.h"
+#include <process.h>
+
+#include "pryutil.h"
+//---------------------------------------------------------------------------
+using namespace std ;
+
+//===========================================================================
+namespace PRY8EAlByw {
+//---------------------------------------------------------------------------
+
+//===========================================================================
+// Functions
+//---------------------------------------------------------------------------
+DWORD Elapsed(DWORD start, DWORD end)
+{
+  DWORD result = (end>=start) ? end-start : MAXDWORD-end+1+start ;
+  return result ;
+}
+//---------------------------------------------------------------------------
+DWORD PastSleep(DWORD wait,DWORD start)
+{
+  if(!wait) return start ;
+  DWORD past = Elapsed(start,GetTickCount()) ;
+  if(wait>past) Sleep(wait-past) ;
+  return start+wait ;
+}
+//---------------------------------------------------------------------------
+wstring mbcs2wcs(string src)
+{
+    if(src.empty()) return wstring(L"") ;
+    BUFFER<wchar_t> wcs(src.length()*3 + 3);
+    size_t wLen = 0;
+    setlocale(LC_ALL,"japanese");
+    mbstowcs_s(&wLen, wcs.data(), src.length()*3+1 , src.c_str(), _TRUNCATE);
+    wstring result = wcs.data() ;
+    return result ;
+}
+//---------------------------------------------------------------------------
+string wcs2mbcs(wstring src)
+{
+    if(src.empty()) return string("") ;
+    BUFFER<char> mbcs(src.length()*3 + 3) ;
+    size_t mbLen = 0 ;
+    setlocale(LC_ALL,"japanese");
+    wcstombs_s(&mbLen, mbcs.data(), src.length()*3+1 , src.c_str(), _TRUNCATE);
+    string result = mbcs.data() ;
+    return result ;
+}
+//---------------------------------------------------------------------------
+string itos(int val,int radix)
+{
+  BUFFER<char> str(72) ;
+  if(!_itoa_s(val,str.data(),70,radix))
+    return static_cast<string>(str.data()) ;
+  return "NAN" ;
+}
+//---------------------------------------------------------------------------
+wstring itows(int val,int radix)
+{
+  BUFFER<wchar_t> str(72) ;
+  if(!_itow_s(val,str.data(),70,radix))
+    return static_cast<wstring>(str.data()) ;
+  return L"NAN" ;
+}
+//---------------------------------------------------------------------------
+string upper_case(string str)
+{
+  BUFFER<char> temp(str.length()+1) ;
+  CopyMemory(temp.data(),str.c_str(),(str.length()+1)*sizeof(char)) ;
+  _strupr_s(temp.data(),str.length()+1) ;
+  return static_cast<string>(temp.data()) ;
+}
+//---------------------------------------------------------------------------
+string lower_case(string str)
+{
+  BUFFER<char> temp(str.length()+1) ;
+  CopyMemory(temp.data(),str.c_str(),(str.length()+1)*sizeof(char)) ;
+  _strlwr_s(temp.data(),str.length()+1) ;
+  return static_cast<string>(temp.data()) ;
+}
+//---------------------------------------------------------------------------
+string file_path_of(string filename)
+{
+  char szDrive[_MAX_FNAME] ;
+  char szDir[_MAX_FNAME] ;
+  _splitpath_s( filename.c_str(), szDrive, _MAX_FNAME, szDir, _MAX_FNAME
+    , NULL, 0, NULL, 0 ) ;
+  return string(szDrive)+string(szDir) ;
+}
+//---------------------------------------------------------------------------
+string file_prefix_of(string filename)
+{
+  char szName[_MAX_FNAME] ;
+  _splitpath_s( filename.c_str(), NULL, 0, NULL, 0
+    , szName, _MAX_FNAME, NULL, 0 ) ;
+  return string(szName) ;
+}
+//===========================================================================
+// event_object
+//---------------------------------------------------------------------------
+static int event_create_count = 0 ;
+//---------------------------------------------------------------------------
+event_object::event_object(BOOL _InitialState,wstring _name)
+{
+  if(_name.empty()) _name = L"event"+itows(event_create_count++) ;
+  name = _name ;
+  event = CreateEvent(NULL,FALSE,_InitialState,name.c_str()) ;
+#ifdef _DEBUG
+  if(is_valid()) {
+    TRACE(L"event_object created. [name=%s]\r\n",name.c_str()) ;
+  }else {
+    TRACE(L"event_object failed to create. [name=%s]\r\n",name.c_str()) ;
+  }
+#endif
+}
+//---------------------------------------------------------------------------
+event_object::event_object(const event_object &clone_source)
+{
+  name = clone_source.name ;
+  event = clone_source.open() ;
+#ifdef _DEBUG
+  if(is_valid()) {
+    TRACE(L"event_object cloned. [name=%s]\r\n",name.c_str()) ;
+  }else {
+    TRACE(L"event_object failed to clone. [name=%s]\r\n",name.c_str()) ;
+  }
+#endif
+}
+//---------------------------------------------------------------------------
+event_object::~event_object()
+{
+#ifdef _DEBUG
+  if(is_valid()) {
+    TRACE(L"event_object finished. [name=%s]\r\n",name.c_str()) ;
+  }else {
+    TRACE(L"event_object finished. (failure) [name=%s]\r\n",name.c_str()) ;
+  }
+#endif
+  if(is_valid()) CloseHandle(event) ;
+}
+//---------------------------------------------------------------------------
+HANDLE event_object::open() const
+{
+  if(!is_valid()) return NULL ;
+  HANDLE open_event = OpenEvent(EVENT_ALL_ACCESS, FALSE, name.c_str());
+  return open_event ;
+}
+//---------------------------------------------------------------------------
+DWORD event_object::wait(DWORD timeout)
+{
+  return is_valid() ? WaitForSingleObject(event,timeout) : WAIT_FAILED ;
+}
+//---------------------------------------------------------------------------
+BOOL event_object::set()
+{
+  return is_valid() ? SetEvent(event) : FALSE ;
+}
+//---------------------------------------------------------------------------
+BOOL event_object::reset()
+{
+  return is_valid() ? ResetEvent(event) : FALSE ;
+}
+//---------------------------------------------------------------------------
+BOOL event_object::pulse()
+{
+  return is_valid() ? PulseEvent(event) : FALSE ;
+}
+//===========================================================================
+// critical_object
+//---------------------------------------------------------------------------
+critical_object::critical_object()
+{
+  ref = new critical_ref_t ;
+  InitializeCriticalSection(&ref->critical) ;
+}
+//---------------------------------------------------------------------------
+critical_object::critical_object(const critical_object &clone_source)
+{
+  ref = clone_source.ref ;
+  assert(ref!=NULL);
+  enter();
+  ref->ref_count++ ;
+  leave();
+}
+//---------------------------------------------------------------------------
+critical_object::~critical_object()
+{
+  enter();
+  bool empty = !--ref->ref_count ;
+  leave();
+  if(empty) {
+    DeleteCriticalSection(&ref->critical) ;
+    delete ref ;
+  }
+}
+//---------------------------------------------------------------------------
+void critical_object::enter()
+{
+  EnterCriticalSection(&ref->critical) ;
+}
+//---------------------------------------------------------------------------
+BOOL critical_object::try_enter()
+{
+  return TryEnterCriticalSection(&ref->critical) ;
+}
+//---------------------------------------------------------------------------
+void critical_object::leave()
+{
+  LeaveCriticalSection(&ref->critical) ;
+}
+//===========================================================================
+// CAsyncFifo
+//---------------------------------------------------------------------------
+CAsyncFifo::CAsyncFifo(
+  size_t initialPool, size_t maximumPool, size_t emptyBorder,
+  size_t packetSize, DWORD threadWait,int threadPriority)
+  : MaximumPool(max(1,max(initialPool,maximumPool))),
+    TotalPool(min(max(1,initialPool),MaximumPool)),
+	Writing(WRITING_NONE),
+    Indices(MaximumPool),
+    EmptyIndices(MaximumPool),
+    EmptyBorder(emptyBorder),
+	EmptyLimit(0),
+    PacketSize(packetSize),
+    THREADWAIT(threadWait),
+    AllocThread(NULL),
+    AllocOrderEvent(FALSE),
+    AllocatedEvent(FALSE),
+	ModerateAllocating(true),
+    Terminated(false)
+{
+    DWORD flag = HEAP_NO_SERIALIZE ;
+    // obt@
+    PacketSize = packetSize ;
+    BufferPool.resize(MaximumPool);
+#ifdef ASYNCFIFO_HEAPBUFFERPOOL
+    // q[v쐬
+    Heap = HeapCreate(flag, 0, 0);
+    BufferPool.set_heap(Heap) ;
+    BufferPool.set_heap_flag(flag) ;
+#endif
+    for(size_t i = 0UL ; i < TotalPool ; i++){
+        BufferPool[i].resize(PacketSize);
+        EmptyIndices.push(i) ;
+    }
+#ifdef ASYNCFIFO_HEAPBUFFERPOOL
+    //HeapCompact(Heap, flag) ;
+#endif
+    // AP[VXbh쐬
+    if(MaximumPool>TotalPool) {
+      AllocThread = (HANDLE)_beginthreadex(NULL, 0, AllocThreadProc, this, CREATE_SUSPENDED, NULL) ;
+      if(AllocThread == INVALID_HANDLE_VALUE) {
+          AllocThread = NULL;
+      }else{
+          SetThreadPriority(AllocThread,threadPriority);
+		  ::ResumeThread(AllocThread) ;
+      }
+    }
+}
+//---------------------------------------------------------------------------
+CAsyncFifo::~CAsyncFifo()
+{
+    // AP[VXbhj
+    Terminated=true ;
+    bool abnormal=false ;
+    if(AllocThread) {
+      AllocOrderEvent.set() ;
+      if(::WaitForSingleObject(AllocThread,30000) != WAIT_OBJECT_0) {
+        ::TerminateThread(AllocThread, 0);
+        abnormal=true ;
+      }
+      ::CloseHandle(AllocThread) ;
+    }
+
+#ifdef ASYNCFIFO_HEAPBUFFERPOOL
+    // obt@iɃq[v̂ĵŃ[N͔Ȃj
+    BufferPool.abandon_erase(Heap) ;
+    // q[vj
+    if(!abnormal) HeapDestroy(Heap) ;
+#endif
+}
+//---------------------------------------------------------------------------
+CAsyncFifo::CACHE *CAsyncFifo::BeginWriteBack(bool allocWaiting)
+{
+  exclusive_lock plock(&PurgeExclusive,false) ;
+  exclusive_lock elock(&Exclusive,false) ;
+
+  if(!allocWaiting&&EmptyIndices.size()<=EmptyLimit) {
+    AllocOrderEvent.set() ;
+    return NULL ;
+  }
+
+  plock.lock();
+
+  if(EmptyIndices.size()<=EmptyBorder) {
+    if(allocWaiting) {
+      if(!WaitForAllocation()&&EmptyIndices.empty())
+        return NULL ;
+    }else {
+      // Allocation ordering...
+      AllocOrderEvent.set() ;
+    }
+  }
+
+  elock.lock();
+
+  if(EmptyIndices.empty()) return NULL ;
+  size_t index = EmptyIndices.front() ;
+  EmptyIndices.pop() ;
+  CACHE *cache = &BufferPool[index] ;
+  WriteBackMap[cache] = index ;
+  return cache;
+}
+//---------------------------------------------------------------------------
+bool CAsyncFifo::FinishWriteBack(CAsyncFifo::CACHE *cache,bool fragment)
+{
+  exclusive_lock lock(&Exclusive) ;
+
+  WRITEBACKMAP::iterator pos = WriteBackMap.find(cache) ;
+  if(pos==WriteBackMap.end()) return false ;
+
+  bool result = true ;
+
+  size_t index = pos->second ;
+  if(cache->size()>0) {
+    if(fragment) {
+      exclusive_lock plock(&Exclusive) ;
+      if(Writing==WRITING_FRAGMENT) {
+        Indices.push(WritingIndex) ;
+        Writing=WRITING_NONE ;
+      }
+    }
+    Indices.push(index) ;
+  }else {
+    EmptyIndices.push_front(index) ;
+    result = false ;
+  }
+  WriteBackMap.erase(pos) ;
+
+  return result ;
+}
+//---------------------------------------------------------------------------
+size_t CAsyncFifo::Push(const BYTE *data, DWORD len, bool ignoreFragment,bool allocWaiting)
+{
+  if(!data||!len)
+    return 0 ;
+
+  exclusive_lock plock(&PurgeExclusive,false) ;
+  exclusive_lock elock(&Exclusive,false) ;
+
+
+  if(!allocWaiting&&EmptyIndices.size()<=EmptyLimit) {
+    AllocOrderEvent.set() ;
+    return 0 ;
+  }
+
+  plock.lock();
+
+  size_t sz, n=0 ;
+  for(BYTE *p = const_cast<BYTE*>(data) ; len ; len-=(DWORD)sz, p+=sz) {
+
+    sz=min(len,PacketSize) ;
+
+    if(Writing!=WRITING_FRAGMENT) {
+
+      if(EmptyIndices.size()<=EmptyBorder) {
+        if(allocWaiting) {
+          if(!WaitForAllocation()&&EmptyIndices.empty())
+            return n ;
+        }else {
+          // allocation ordering...
+          AllocOrderEvent.set() ;
+          if(EmptyIndices.size()<=EmptyLimit)
+            return n ;
+        }
+      }
+
+      elock.lock();
+
+	  if(EmptyIndices.empty()) return n ;
+      // get the empty index
+      WritingIndex = EmptyIndices.front() ;
+      EmptyIndices.pop() ;
+      Writing = WRITING_PACKET ;
+
+      elock.unlock();
+    }
+
+    // resize and data writing (no lock)
+    switch(Writing) {
+      case WRITING_FRAGMENT: { // fragmentation occurred
+        size_t buf_sz = BufferPool[WritingIndex].size();
+        sz = min(sz, PacketSize - buf_sz);
+        BufferPool[WritingIndex].resize(buf_sz + sz);
+        CopyMemory(BufferPool[WritingIndex].data() + buf_sz, p, sz);
+        break;
+      }
+      case WRITING_PACKET:
+        BufferPool[WritingIndex].resize(sz) ;
+        CopyMemory(BufferPool[WritingIndex].data(), p, sz );
+        break;
+    }
+
+        if (ignoreFragment || BufferPool[WritingIndex].size() == PacketSize) {
+            // push to FIFO buffer
+            elock.lock();
+            Writing = WRITING_NONE;
+            Indices.push(WritingIndex);
+            elock.unlock();
+            n++;
+        }
+        else
+            Writing = WRITING_FRAGMENT;
+
+  }
+  return n ;
+}
+//---------------------------------------------------------------------------
+bool CAsyncFifo::Pop(BYTE **data, DWORD *len,DWORD *remain)
+{
+    exclusive_lock lock(&Exclusive);
+    if(Empty()) {
+        if(len) *len = 0 ;
+        if(data) *data = 0 ;
+        if(remain) *remain = 0 ;
+        return false ;
+    }
+    size_t index = Indices.front() ;
+    if(len) *len = (DWORD)BufferPool[index].size() ;
+    if(data) *data = (BYTE*)BufferPool[index].data() ;
+    EmptyIndices.push(index) ;
+    Indices.pop();
+    if(remain) *remain = (DWORD)Size() ;
+    return true;
+}
+//---------------------------------------------------------------------------
+void CAsyncFifo::Purge(bool purgeWriteBack)
+{
+    // obt@o\f[^p[W
+    exclusive_lock plock(&PurgeExclusive) ;
+    exclusive_lock lock(&Exclusive);
+
+    // ̃f[^p[W
+    while(!Indices.empty()) {
+        EmptyIndices.push(Indices.front()) ;
+        Indices.pop() ;
+    }
+    if(Writing!=WRITING_NONE) {
+		EmptyIndices.push(WritingIndex) ;
+		Writing = WRITING_NONE ;
+	}
+
+    if(purgeWriteBack) {
+        for(WRITEBACKMAP::iterator pos = WriteBackMap.begin() ;
+         pos!= WriteBackMap.end() ; ++pos) {
+            EmptyIndices.push(pos->second) ;
+        }
+        WriteBackMap.clear() ;
+    }
+}
+//---------------------------------------------------------------------------
+unsigned int CAsyncFifo::AllocThreadProcMain ()
+{
+    exclusive_lock elock(&Exclusive,false) ;
+    for(;;) {
+        DWORD dwRet = AllocOrderEvent.wait(THREADWAIT);
+        if (Terminated) break;
+        bool doAllocate = false;
+        switch(dwRet) {
+          	case WAIT_OBJECT_0: // Allocation ordered
+            	elock.lock() ;
+				doAllocate = Growable() ;
+                if(EmptyIndices.size() > EmptyBorder)
+                  AllocatedEvent.set() ;
+            	elock.unlock() ;
+				break ;
+		  	case WAIT_TIMEOUT:
+				if(!ModerateAllocating) {
+            	  elock.lock() ;
+				  doAllocate = Growable() && EmptyIndices.size() <= EmptyBorder ;
+            	  elock.unlock() ;
+				}
+				break ;
+			case WAIT_FAILED:
+				return 1;
+		}
+		if(doAllocate) {
+            bool failed=false ;
+            do {
+                elock.unlock() ;
+				BufferPool[TotalPool].resize(PacketSize); // Allocating...
+                if(BufferPool[TotalPool].size()!=PacketSize) {
+                  failed = true ; break ;
+                }
+                elock.lock() ;
+                EmptyIndices.push_front(TotalPool++) ;
+				elock.unlock() ;
+				AllocatedEvent.set();
+                if (Terminated) break;
+				if (ModerateAllocating) break;
+				elock.lock() ;
+			} while (Growable() && EmptyIndices.size() <= EmptyBorder );
+            elock.unlock() ;
+            if(failed)
+              DBGOUT("Async FIFO allocation: allocation failed!\r\n") ;
+            else
+              DBGOUT("Async FIFO allocation: total %d bytes grown.\r\n",
+  				  int((TotalPool)*PacketSize)) ;
+        }
+        if (Terminated) break;
+    }
+    return 0 ;
+}
+//---------------------------------------------------------------------------
+unsigned int __stdcall CAsyncFifo::AllocThreadProc (PVOID pv)
+{
+    register CAsyncFifo *_this = static_cast<CAsyncFifo*>(pv) ;
+    unsigned int result = _this->AllocThreadProcMain() ;
+    _endthreadex(result) ;
+    return result;
+}
+
+//---------------------------------------------------------------------------
+bool CAsyncFifo::WaitForAllocation()
+{
+	exclusive_lock elock(&Exclusive) ;
+
+	size_t n=EmptyIndices.size() ;
+	if(n>EmptyBorder) {
+	  return true ;
+	}
+
+    DBGOUT("Async FIFO allocation: allocation waiting...\r\n") ;
+
+    bool result = false ;
+
+      do {
+		if (!Growable()) break ;
+		elock.unlock() ;
+		AllocOrderEvent.set();
+		DWORD res = AllocatedEvent.wait(THREADWAIT) ;
+		if(res==WAIT_FAILED) break ;
+		elock.lock() ;
+ 		size_t m = EmptyIndices.size();
+		if (n < m) {
+			if (ModerateAllocating&&m>EmptyLimit)
+				result = true;
+			n = m;
+		}
+		if (n > EmptyBorder) result = true ;
+        if(result) break ;
+	  }while(!Terminated) ;
+
+    DBGOUT("Async FIFO allocation: allocation waiting %s.\r\n",result?"completed":"failed") ;
+
+	return result ;
+}
+//---------------------------------------------------------------------------
+} // End of namespace PRY8EAlByw
+//===========================================================================
diff -uPr BonD_FSHybrid-20201009_org/src/pryutil.h BonD_FSHybrid-20201009_mod2/src/pryutil.h
--- BonD_FSHybrid-20201009_org/src/pryutil.h	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/pryutil.h	2019-12-26 14:09:38.000000000 +0900
@@ -0,0 +1,583 @@
+//===========================================================================
+#pragma once
+#ifndef _PRYUTIL_20141218222525309_H_INCLUDED_
+#define _PRYUTIL_20141218222525309_H_INCLUDED_
+//---------------------------------------------------------------------------
+
+#include <Windows.h>
+#include <assert.h>
+#include <string>
+#include <vector>
+#include <map>
+#include <cstdlib>
+#include <algorithm>
+#include <functional>
+#include <stdexcept>
+
+//===========================================================================
+namespace PRY8EAlByw {
+//===========================================================================
+// Functions
+//---------------------------------------------------------------------------
+DWORD Elapsed(DWORD start=0,DWORD end=GetTickCount()) ;
+DWORD PastSleep(DWORD wait=0,DWORD start=GetTickCount()) ;
+
+std::wstring mbcs2wcs(std::string src);
+std::string wcs2mbcs(std::wstring src);
+
+std::string itos(int val,int radix=10);
+std::wstring itows(int val,int radix=10);
+
+std::string upper_case(std::string str) ;
+std::string lower_case(std::string str) ;
+
+std::string file_path_of(std::string filename);
+std::string file_prefix_of(std::string filename);
+
+//===========================================================================
+// Inline Functions
+//---------------------------------------------------------------------------
+template<class String> String inline trim(const String &str)
+{
+  String str2 ; str2.clear() ;
+  for(typename String::size_type i=0;i<str.size();i++) {
+    if(unsigned(str[i])>0x20UL) {
+      str2 = str.substr(i,str.size()-i) ;
+      break ;
+    }
+  }
+  if(str2.empty()) return str2 ;
+  for(typename String::size_type i=str2.size();i>0;i--) {
+    if(unsigned(str2[i-1])>0x20UL) {
+      return str2.substr(0,i) ;
+    }
+  }
+  str2.clear() ;
+  return str2 ;
+}
+//---------------------------------------------------------------------------
+#if 0
+template<class Container> void inline split(
+	Container &DivStrings, const typename Container::value_type &Text,
+	typename Container::value_type::value_type Delimiter)
+#else
+template<class Container,class String> void inline split(
+	Container &DivStrings/*string container*/, const String &Text,
+	typename String::value_type Delimiter)
+#endif
+{
+  #ifdef _DEBUG
+  assert(typeid(typename Container::value_type)==typeid(Text));
+  #endif
+  typename Container::value_type temp; temp.clear() ;
+  for(typename Container::value_type::size_type i=0;i<Text.size();i++) {
+    if(Text[i]==Delimiter) {
+      DivStrings.push_back(trim(temp));
+      temp.clear();
+      continue;
+    }
+    temp+=Text[i];
+  }
+  if(!trim(temp).empty()) {
+     DivStrings.push_back(trim(temp));
+  }
+}
+//---------------------------------------------------------------------------
+//===========================================================================
+// Classes
+//---------------------------------------------------------------------------
+
+  // ȈՃCxgIuWFNg
+
+class event_object
+{
+private:
+  HANDLE event ;
+  std::wstring name ;
+public:
+  event_object(BOOL _InitialState=TRUE/*default:signalized*/,std::wstring _name=L"") ;
+  event_object(const event_object &clone_source) ; // XbhŃCxg𕡐
+  ~event_object() ;
+  std::wstring event_name() const { return name ; }
+  HANDLE handle() const { return event ; }
+  BOOL is_valid() const { return (event&&event!=INVALID_HANDLE_VALUE)?TRUE:FALSE; }
+  // Xbh̉ŕ̃CxgnhJ
+  HANDLE open() const ;
+  // XbhŃVOi܂ŃubNAꂽAIɍĂєVOi
+  DWORD wait(DWORD timeout=INFINITE) ;
+  // VOiiubNĂXbĥ͕̂̈j
+  BOOL set() ;
+  // }jAIȔVOi
+  BOOL reset() ;
+  // VOiiubNĂSXbḧꊇj
+  BOOL pulse() ;
+  // lock(wait) / unlock(set)
+  DWORD lock(DWORD timeout=INFINITE) { return wait(timeout) ; }
+  BOOL unlock() { return set() ; }
+
+};
+
+
+  // ȈՃNeBJIuWFNg
+
+class critical_object
+{
+private:
+  struct critical_ref_t {
+    CRITICAL_SECTION critical ;
+    int ref_count ;
+    critical_ref_t(): ref_count(1) {}
+  };
+  critical_ref_t *ref ;
+public:
+  critical_object() ;
+  critical_object(const critical_object &clone_source) ;
+  ~critical_object() ;
+  CRITICAL_SECTION *handle() const { return &ref->critical ; }
+  // wrapper
+  void enter() ;
+  BOOL try_enter() ;
+  void leave() ;
+  // lock / unlock
+  void lock() { enter() ; }
+  void unlock() { leave() ; }
+};
+
+
+  // XR[vx̎bN^AbN(IuWFNgQƃx)
+
+template <typename locker_t>
+class basic_lock
+{
+private:
+  bool unlocked ;
+  locker_t *locker_ref ;
+public:
+  basic_lock(locker_t *source_ref,bool initial_locking=true)
+    : locker_ref(source_ref) {
+	unlocked = !initial_locking;
+    // VOiԂ܂ŌXbhubN
+    if(initial_locking) locker_ref->lock() ;
+  }
+  ~basic_lock() {
+    // XR[vI_ŃVOiԂ
+    unlock() ;
+  }
+  void unlock() {
+    // XR[v̓rł̃\bhĂяoƂ̎_ŔVOiԂ
+    if(!unlocked) {
+      // VOiԂɃZbg
+      locker_ref->unlock() ;
+      unlocked = true ;
+    }
+  }
+  void lock() {
+    // XR[v̓rł̃\bhĂяoƂ̎_ŔVOiԂɂ
+    if(unlocked) {
+      locker_ref->lock() ;
+      unlocked = false ;
+	}
+  }
+};
+typedef basic_lock<event_object> event_lock ;
+typedef basic_lock<critical_object> critical_lock ;
+
+
+  // XR[vx̎bN^AbN(IuWFNgx)
+
+template <typename locker_t>
+class basic_lock_object
+{
+private:
+  locker_t locker ;
+  bool unlocked ;
+public:
+  basic_lock_object(const locker_t &source_object, bool initial_locking = true)
+    : locker(source_object) {
+    // VOiԂ܂ŌXbhubN
+    unlocked = !initial_locking;
+    // VOiԂ܂ŌXbhubN
+    if (initial_locking) locker.lock();
+  }
+  ~basic_lock_object() {
+    // XR[vI_ŔVOiԂ
+    unlock() ;
+  }
+  void unlock() {
+    // XR[v̓rł̃\bhĂяoƂ̎_ŔVOiԂ
+    if(!unlocked) {
+      // VOiԂɃZbg
+      locker.unlock() ;
+      unlocked = true ;
+    }
+  }
+  void lock() {
+    // XR[v̓rł̃\bhĂяoƂ̎_ŔVOiԂɂ
+    if (unlocked) {
+      locker.lock();
+      unlocked = false;
+    }
+  }
+};
+typedef basic_lock_object<event_object> event_lock_object ;
+typedef basic_lock_object<critical_object> critical_lock_object ;
+
+
+  // exclusive
+
+  #if 0  // 
+  typedef event_object exclusive_object ;
+  #else  // è 
+  typedef critical_object exclusive_object ;
+  #endif
+  typedef basic_lock<exclusive_object> exclusive_lock ;
+  typedef basic_lock_object<exclusive_object> exclusive_lock_object ;
+
+
+  //BUFFER/BUFFERPOOL
+
+template<typename T>
+struct BUFFER {
+    typedef size_t size_type ;
+    typedef T  value_type ;
+    typedef T& reference_type ;
+    typedef T* pointer_type ;
+    BUFFER(size_type size=0) : buff_(NULL), size_(0UL), grow_(0UL) {
+      if(size>0) resize(size) ;
+    }
+    BUFFER(const BUFFER<T> &src)
+     : buff_(NULL), size_(0UL), grow_(0UL) {
+      *this = src ;
+    }
+    BUFFER(const void *buffer, size_type size)
+     : buff_(NULL), size_(0UL), grow_(0UL) {
+      if(size>0) resize(size) ;
+      if(buff_&&size_==size)
+        CopyMemory(buff_,buffer,size*sizeof(value_type)) ;
+    }
+    ~BUFFER() {
+      clear() ;
+    }
+    BUFFER &operator =(const BUFFER<T> &src) {
+      resize(src.size_) ;
+      if(buff_&&size_==src.size_)
+        CopyMemory(buff_,src.buff_,src.size_*sizeof(value_type)) ;
+      return *this ;
+    }
+    void clear() {
+      if(buff_) {
+        std::free(buff_) ;
+        buff_=NULL ; grow_=0UL ; size_=0UL ;
+      }
+    }
+    void resize(size_type size) {
+      if(size_!=size) {
+        if(buff_) {
+          if(size>grow_) {
+            buff_ = (pointer_type)std::realloc(buff_,size*sizeof(value_type)) ;
+            if(buff_) grow_ = size ;
+            else grow_ = 0UL ;
+          }
+        }else {
+          buff_ = (pointer_type)std::malloc(size*sizeof(value_type)) ;
+          if(buff_) grow_ = size ;
+          else grow_ = 0UL ;
+        }
+        if(buff_) size_ = size ;
+        else size_ = 0UL ;
+      }
+    }
+    reference_type operator[](size_type index) { return buff_[index] ; }
+    pointer_type data() { return buff_ ; }
+    size_type size() const { return size_ ; }
+private:
+    pointer_type buff_ ;
+    size_type size_ ;
+    size_type grow_ ;
+};
+
+template<typename T,class Container=std::vector< BUFFER<T> > >
+struct BUFFERPOOL {
+  typedef BUFFER<T> value_type ;
+  typedef BUFFER<T>* pointer_type ;
+  typedef BUFFER<T>& reference_type ;
+  typedef size_t size_type ;
+  void resize(size_type size) {
+    cont_.resize(size) ;
+  }
+  void clear() {
+    cont_.clear() ;
+  }
+  size_type size() {
+    return cont_.size() ;
+  }
+  reference_type operator[](size_t index) {
+    return cont_[index] ;
+  }
+  Container &container() { return cont_ ; }
+private:
+  Container cont_ ;
+};
+
+
+  // HEAPBUFFER/HEAPBUFFERPOOL
+
+template<typename T>
+struct HEAPBUFFER {
+    typedef size_t size_type ;
+    typedef T  value_type ;
+    typedef T& reference_type ;
+    typedef T* pointer_type ;
+    HEAPBUFFER(size_type size=0,HANDLE heap=NULL,DWORD heap_flag=0) : buff_(NULL), size_(0UL), grow_(0UL) {
+      heap_ = heap ? heap : GetProcessHeap() ;
+      heap_flag_ = heap_flag ;
+      if(size>0) resize(size) ;
+    }
+    HEAPBUFFER(const HEAPBUFFER<T> &src)
+     : buff_(NULL), size_(0UL), grow_(0UL), heap_(src.heap_), heap_flag_(src.heap_flag_) {
+      *this = src ;
+    }
+    HEAPBUFFER(const void *buffer, size_type size,HANDLE heap=NULL)
+     : buff_(NULL), size_(0UL), grow_(0UL) {
+      heap_ = heap ? heap : GetProcessHeap() ;
+      if(size>0) resize(size) ;
+      if(buff_&&size_==size)
+        CopyMemory(buff_,buffer,size*sizeof(value_type)) ;
+    }
+    ~HEAPBUFFER() {
+      clear() ;
+    }
+    HEAPBUFFER &operator =(const HEAPBUFFER<T> &src) {
+      if(heap_!=src.heap_) {
+        clear() ;
+        heap_ = src.heap_ ;
+      }
+      heap_flag_ = src.heap_flag_ ;
+      resize(src.size_) ;
+      if(buff_&&size_==src.size_)
+        CopyMemory(buff_,src.buff_,src.size_*sizeof(value_type)) ;
+      return *this ;
+    }
+    void clear() {
+      if(buff_) {
+        HeapFree(heap_,heap_flag_&HEAP_NO_SERIALIZE,buff_) ;
+        buff_=NULL ; grow_=0UL ; size_=0UL ;
+      }
+    }
+    bool abandon(HANDLE heap) {
+      if(heap_==heap) {
+        if(buff_) { buff_=NULL ; grow_=0UL ; size_=0UL ; }
+        return true ;
+      }
+      return false ;
+    }
+    void resize(size_type size) {
+      if(size_!=size) {
+        if(buff_) {
+          if(size>grow_) {
+            buff_ = (pointer_type)HeapReAlloc(heap_,
+              heap_flag_&(HEAP_NO_SERIALIZE|HEAP_ZERO_MEMORY|HEAP_REALLOC_IN_PLACE_ONLY),
+              buff_,size*sizeof(value_type)) ;
+            if(buff_) grow_ = size ;
+            else grow_ = 0UL ;
+          }
+        }else {
+          buff_ = (pointer_type)HeapAlloc(heap_,
+            heap_flag_&(HEAP_NO_SERIALIZE|HEAP_ZERO_MEMORY),size*sizeof(value_type)) ;
+          if(buff_) grow_ = size ;
+          else grow_ = 0UL ;
+        }
+        if(buff_) size_ = size ;
+        else size_ = 0UL ;
+      }
+    }
+    reference_type operator[](size_type index) { return buff_[index] ; }
+    pointer_type data() { return buff_ ; }
+    size_type size() const { return size_ ; }
+    void set_heap_flag(DWORD flag) { heap_flag_ = flag ; }
+    void set_heap(HANDLE heap) {
+      if(!heap) heap=GetProcessHeap() ;
+      if(heap_!=heap) {
+        size_type sz = size() ;
+        if(sz) {
+          pointer_type buffer = (pointer_type)HeapAlloc(heap,
+            heap_flag_&(HEAP_NO_SERIALIZE|HEAP_ZERO_MEMORY),sz*sizeof(value_type)) ;
+          if(buffer) {
+            CopyMemory(buffer,buff_,sz*sizeof(value_type)) ;
+            clear() ;
+            buff_ = buffer ;
+            size_ = sz ; grow_ = sz ;
+          }else {
+            clear() ;
+          }
+        }
+        heap_ = heap ;
+      }
+    }
+private:
+    HANDLE heap_ ;
+    DWORD heap_flag_ ;
+    pointer_type buff_ ;
+    size_type size_ ;
+    size_type grow_ ;
+};
+
+template<typename T,class Container=std::vector< HEAPBUFFER<T> > >
+struct HEAPBUFFERPOOL {
+  typedef HEAPBUFFER<T> value_type ;
+  typedef HEAPBUFFER<T>* pointer_type ;
+  typedef HEAPBUFFER<T>& reference_type ;
+  typedef size_t size_type ;
+  void set_heap(HANDLE heap) {
+    std::for_each(cont_.begin(),cont_.end(),
+      std::bind2nd(std::mem_fun_ref(&value_type::set_heap),heap));
+  }
+  void set_heap_flag(DWORD flag) {
+    std::for_each(cont_.begin(),cont_.end(),
+      std::bind2nd(std::mem_fun_ref(&value_type::set_heap_flag),flag));
+  }
+  void abandon_erase(HANDLE heap) {
+    cont_.erase(std::remove_if(cont_.begin(),cont_.end(),
+      std::bind2nd(std::mem_fun_ref(&value_type::abandon),heap)),cont_.end());
+  }
+  void resize(size_type size) {
+    cont_.resize(size) ;
+  }
+  void clear() {
+    cont_.clear() ;
+  }
+  size_type size() {
+    return cont_.size() ;
+  }
+  reference_type operator[](size_t index) {
+    return cont_[index] ;
+  }
+  Container &container() { return cont_ ; }
+private:
+  Container cont_ ;
+};
+
+  // fixed_queue (AP[VȂ)
+
+template<typename T>
+class fixed_queue
+{
+public:
+  typedef T value_type ;
+  typedef T& reference_type ;
+  typedef T* pointer_type ;
+  typedef size_t size_type ;
+protected:
+  pointer_type buff_ ;
+  size_type cue_ ;
+  size_type size_ ;
+  size_type grew_ ;
+public:
+  fixed_queue(size_type fixed_size)
+    : grew_(fixed_size), cue_(0), size_(0) {
+    buff_ = new value_type[grew_] ;
+  }
+  ~fixed_queue() {
+    delete [] buff_ ;
+  }
+  size_type capacity() const { return grew_ ; }
+  size_type size() const { return size_ ; }
+  bool empty() const { return size_==0 ; }
+  bool full() const { return size_>=grew_ ; }
+  bool push(const value_type &val) {
+    if(full()) return false ;
+    buff_[cue_+size_-(cue_+size_<grew_?0:grew_)] = val ;
+    size_++ ;
+    return true ;
+  }
+  bool push_front(const value_type &val) {
+    if(full()) return false ;
+	buff_[cue_?--cue_:cue_=grew_-1] = val ;
+	size_++ ;
+	return true ;
+  }
+  bool pop() {
+    if(empty()) return false ;
+    if(++cue_>=grew_) cue_=0 ;
+    size_-- ;
+    return true ;
+  }
+  reference_type front() {
+  #ifdef _DEBUG
+    if(empty()) throw std::range_error("fixed_queue: front() range error.") ;
+  #endif
+    return buff_[cue_] ;
+  }
+  void clear() { cue_ = 0 ; size_ = 0 ; }
+};
+
+  // CAsyncFifo
+
+    #define ASYNCFIFO_HEAPBUFFERPOOL
+
+class CAsyncFifo
+{
+public:
+  #ifdef ASYNCFIFO_HEAPBUFFERPOOL
+  typedef HEAPBUFFER<BYTE> CACHE ;
+  #else
+  typedef BUFFER<BYTE> CACHE ;
+  #endif
+  typedef std::map<CACHE*,size_t/*index*/> WRITEBACKMAP ;
+  enum WRITING {
+	  WRITING_NONE,
+	  WRITING_PACKET,
+	  WRITING_FRAGMENT
+  };
+private:
+  size_t MaximumPool ;
+  size_t TotalPool ;
+  size_t EmptyBorder ;
+  size_t EmptyLimit ;
+  size_t PacketSize ;
+  DWORD THREADWAIT ;
+  exclusive_object Exclusive, PurgeExclusive ;
+  WRITING Writing ;
+  size_t WritingIndex ;
+  #ifdef ASYNCFIFO_HEAPBUFFERPOOL
+  HANDLE Heap ;
+  HEAPBUFFERPOOL<BYTE> BufferPool ;
+  #else
+  BUFFERPOOL<BYTE> BufferPool ;
+  #endif
+  fixed_queue<size_t> Indices;
+  fixed_queue<size_t> EmptyIndices;
+  WRITEBACKMAP WriteBackMap ;
+  HANDLE AllocThread ;
+  event_object AllocOrderEvent, AllocatedEvent ;
+  unsigned int AllocThreadProcMain () ;
+  static unsigned int __stdcall AllocThreadProc (PVOID pv) ;
+  bool ModerateAllocating ;
+  bool Terminated ;
+public:
+  CAsyncFifo(
+    size_t initialPool, size_t maximumPool, size_t emptyBorder,
+    size_t packetSize, DWORD threadWait=1000,
+	int threadPriority=THREAD_PRIORITY_HIGHEST ) ;
+  virtual ~CAsyncFifo() ;
+  size_t Size() const { return Indices.size() ; }
+  bool Empty() const { return Indices.empty() ; }
+  bool Full() const { return EmptyIndices.empty() ; }
+  bool Pushable() const { return EmptyIndices.size()>EmptyLimit ; }
+  bool Growable() const { return TotalPool<MaximumPool ; }
+  CACHE *BeginWriteBack(bool allocWaiting=false) ;
+  bool FinishWriteBack(CACHE *cache,bool fragment=false);
+  size_t Push(const BYTE *data, DWORD len, bool ignoreFragment=false, bool allocWaiting=false) ;
+  bool Pop(BYTE **data, DWORD *len, DWORD *remain) ;
+  void Purge(bool purgeWriteBack=false) ;
+  void SetModerateAllocating(bool Moderate) { ModerateAllocating=Moderate ; }
+  void SetEmptyLimit(size_t emptyLimit) { EmptyLimit = min(emptyLimit,EmptyBorder) ; }
+  bool WaitForAllocation() ;
+};
+
+//---------------------------------------------------------------------------
+} // End of namespace PRY8EAlByw
+//===========================================================================
+using namespace PRY8EAlByw ;
+//===========================================================================
+#endif // _PRYUTIL_20141218222525309_H_INCLUDED_
diff -uPr BonD_FSHybrid-20201009_org/src/tc90522.c BonD_FSHybrid-20201009_mod2/src/tc90522.c
--- BonD_FSHybrid-20201009_org/src/tc90522.c	2016-02-12 01:20:50.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/tc90522.c	2020-04-27 05:17:40.000000000 +0900
@@ -4,7 +4,16 @@
   2016-02-12
 */
 
+#ifdef LEGACY_STDINT
+
+#include "stdint_.h"
+
+#else
+
 #include <stdint.h>
+
+#endif
+
 #include <errno.h>
 #include <string.h>
 #include <malloc.h>
@@ -340,39 +349,72 @@
 static unsigned  get_ts_id(struct i2c_device_st* const  dev, const unsigned num)
 {
 	int r;
-	uint8_t utmp;
-	unsigned uval;
+	uint8_t utmp, high, low;
 	//if(num >= 8)  return 0;
 	if(( r = readReg(dev, 0xc3, &utmp ) ))  goto err1;
 	if(utmp & 0x10) {  //# TMCC error
 		goto err0;
 	}
-	if(( r = readReg(dev, 0xce + (num * 2), &utmp ) ))  goto err1;
-	uval = utmp << 8;
-	if(( r = readReg(dev, 0xcf + (num * 2), &utmp ) ))  goto err1;
-	uval |= utmp & 0xFF;
-	return uval;
+	low=high=0xFF;
+	if(( r = readReg(dev, 0xce + (num << 1), &high ) ))  goto err1;
+	if(( r = readReg(dev, 0xcf + (num << 1), &low ) ))  goto err1;
+	if(high==0xFF&&low!=0xFF) //# retry
+		if(( r = readReg(dev, 0xce + (num << 1), &high ) ))  goto err1;
+	return (unsigned) high<<8 | (unsigned) low;
 err1:
 	warn_info(r,"failed");
 err0:
 	return 0;
 }
 
+static unsigned  select_ts_id(struct i2c_device_st* const  dev, const unsigned tsSel)
+{
+	//# direct indexed
+	unsigned num,tsid = get_ts_id(dev,tsSel) ;
+	if(tsid!=0&&tsid!=0xFFFF&&(tsid&7)==tsSel) return tsid ;
+	//# binary search
+	for(num=0;num<=7;num++) {
+		if(num==tsSel) continue ;
+		tsid = get_ts_id(dev,num) ;
+		if(tsid!=0&&tsid!=0xFFFF&&(tsid&7)==tsSel) return tsid ;
+	}
+	return 0 ;
+}
+
+int tc90522_setTSID(void * const state, const unsigned devnum, const unsigned ts_id)
+{
+	int ret;
+	struct state_st* const s = state;
+	struct i2c_device_st* const  dev = &(s->i2c_dev[devnum]);
+
+	if(devnum & 1) { // sate
+		if(( ret = writeReg(dev, 0x8f, (ts_id >> 8) & 0xFF, 0) ))  goto err1;
+		if(( ret = writeReg(dev, 0x90, ts_id & 0xFF, 0) ))  goto err1;
+	}else {  // terra
+		//# select ignore layer (4:A, 2:B, 1:C)  e.g.(A+B= OneSeg + FullSeg  or  A= FullSeg)
+		if(( ret = writeReg(dev, 0x71, ts_id & 0x07, 0x07) ))  goto err1;
+	}
+	return 0;
+err1:
+	warn_info(ret,"failed");
+	return ret;
+}
+
 int tc90522_selectStream(void * const state, const unsigned devnum, const unsigned tsSel)
 {
 	int ret;
 	struct state_st* const s = state;
 	struct i2c_device_st* const  dev = &(s->i2c_dev[devnum]);
+	unsigned ts_id;
 
 	if(! dev->addr) {
 		warn_info(0,"invalid device %u", devnum);
 		return -2;
 	}
 	if(devnum & 1) {  //# sate
-		unsigned ts_id;
 		//# select TS ID
 		if(8 > tsSel) {
-			ts_id = get_ts_id(dev, tsSel);
+			ts_id = select_ts_id(dev, tsSel);
 			if(0 == ts_id || 0xFFFF == ts_id) {  //# empty
 				//warn_msg(0,"TS_ID(%u)= %04X invalid!", tsSel, ts_id);
 				ret = 1;
@@ -381,14 +423,10 @@
 		}else{
 			ts_id = tsSel;
 		}
-		if(( ret = writeReg(dev, 0x8f, (ts_id >> 8) & 0xFF, 0) ))  goto err1;
-		if(( ret = writeReg(dev, 0x90, ts_id & 0xFF, 0) ))  goto err1;
-
 	}else{  //# terra
-		//# select ignore layer (4:A, 2:B, 1:C)  e.g.(A+B= OneSeg + FullSeg  or  A= FullSeg)
-		if(( ret = writeReg(dev, 0x71, tsSel & 0x07, 0x07) ))  goto err1;
-	}
-
+		ts_id = tsSel ;
+ 	}
+	if(( ret = tc90522_setTSID(state, devnum, ts_id) )) goto err1;
 	return 0;
 err1:
 	warn_info(ret,"failed");
@@ -576,7 +614,7 @@
 
 int tc90522_readStatistic(void * const state, const unsigned devnum, unsigned* const data)
 {
-	int ret;
+	int ret=0;
 	struct state_st* const s = state;
 	struct i2c_device_st* const  dev = &(s->i2c_dev[devnum]);
 	unsigned uval;
@@ -586,6 +624,7 @@
 		warn_info(0,"invalid device %u", devnum);
 		return -2;
 	}
+
 	if(devnum & 1) {  //# sate
 		//# status
 		if(( ret = readReg(dev, 0xc3, &utmp ) ))  goto err1;
@@ -633,11 +672,11 @@
 		}
 	}
 
-	return 0;
 err1:
-	warn_info(ret,"failed");
+
+	if(ret) warn_info(ret,"failed");
 	return ret;
 }
 
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/tc90522.h BonD_FSHybrid-20201009_mod2/src/tc90522.h
--- BonD_FSHybrid-20201009_org/src/tc90522.h	2016-02-11 03:40:42.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/tc90522.h	2019-12-07 23:35:12.000000000 +0900
@@ -13,6 +13,7 @@
 int tc90522_selectDevice(void * const, const unsigned devnum);
 int tc90522_powerControl(void * const, const unsigned devnum, const int isWake);
 int tc90522_resetDemod(void * const, const unsigned devnum);
+int tc90522_setTSID(void * const, const unsigned devnum, const unsigned ts_id);
 int tc90522_selectStream(void * const, const unsigned devnum, const unsigned tsSel);
 int tc90522_readTMCC(void * const, const unsigned devnum, void* const pData);
 int tc90522_readStatistic(void * const, const unsigned devnum, unsigned* const data);
diff -uPr BonD_FSHybrid-20201009_org/src/tda20142.c BonD_FSHybrid-20201009_mod2/src/tda20142.c
--- BonD_FSHybrid-20201009_org/src/tda20142.c	2016-01-28 22:00:38.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/tda20142.c	2019-12-16 06:15:18.000000000 +0900
@@ -4,7 +4,16 @@
   2016-01-28
 */
 
+#ifdef LEGACY_STDINT
+
+#include "stdint_.h"
+
+#else
+
 #include <stdint.h>
+
+#endif
+
 #include <errno.h>
 #include <string.h>
 #include <malloc.h>
@@ -240,7 +249,7 @@
 	freq_val += uval * denomi;
 	denomi *= mval;
 	dmsgn("freqVal= %u +%u/%u, ", u2val, freq_val, denomi);
-	
+
 	//# remainder * 65536 / denominator
 	mval = (u3val >> 16) & 0xFF;
 	freq_val <<= 8;
@@ -408,4 +417,4 @@
 }
 
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/tsbuff.h BonD_FSHybrid-20201009_mod2/src/tsbuff.h
--- BonD_FSHybrid-20201009_org/src/tsbuff.h	2016-01-23 16:17:38.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/tsbuff.h	2020-10-09 08:55:58.000000000 +0900
@@ -1,16 +1,57 @@
-/* SunPTV-USB   (c) 2016 trinity19683
+/* fsusb2i   (c) 2015-2016 trinity19683
   TS buffer, transfer parameters (MS-Windows)
   tsbuff.h
-  2016-01-23
+  2016-01-22
 */
 #pragma once
 
-//# TS Buffer size = 3584 KiB
-#define TS_BufSize  3670016
+
+#ifdef INCLUDE_ISOCH_XFER // Isochronous & Bulk hybrid
+
+//# Isochronous Frames per a Packet
+#define ISOCH_PacketFrames 48
+
+//# Isochronous Frame size (real packet size)
+#define ISOCH_FrameSize   (5*188)
+
+//# TS Packet size (faked packet size)
+#define TS_PacketSize   (ISOCH_FrameSize*ISOCH_PacketFrames)
+
+#else // Bulk only
+
+//# TS Packet size (real packet size)
+#define TS_PacketSize   47752 // org : 46060
+
+#endif
+
+//# TS Delta size that is reserved bytes protected from device's messy overlapping
+#define TS_DeltaSize  	1024
+
+//# TS Buffer packets
+#define TS_BufPackets	64
+
+//# TS Buffer size
+#define TS_CalcBufSize(PacketSize)	(((PacketSize+0x1FF)&~0x1FF)*TS_BufPackets)
+#define TS_BufSize		TS_CalcBufSize(TS_PacketSize)
+
+//# number of compensated read only bytes before the buffer busy memory area
+#define TS_CalcDeadZone(BufSize)	(BufSize/4)
+#define TS_DeadZone  	TS_CalcDeadZone(TS_BufSize)
 
 //# max number of submitted IO requests
 #define TS_MaxNumIO  24
+
 //# IO polling timeout (msec)
 #define TS_PollTimeout  100
 
-/*EOF*/
\ ե˲Ԥޤ
+
+//# 2020-10-5
+//#   Added the definition "ISOCH_PacketFrames".
+//#   Added the definition "ISOCH_FrameSize" for the isochronous transfer.
+//# 2018-3-1
+//#   Added the definition "TS_DeadZone".
+//#   Moved the definition "TS_BulkSize" from the source file "it9175.c".
+//#   Rename the definition "TS_BulkSize" to "TS_PacketSize".
+//# Fixed by 2018-2020 LVhJPic0JSk5LiQ1ITskKVk9UGBg
+
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/tsthread.c BonD_FSHybrid-20201009_mod2/src/tsthread.c
--- BonD_FSHybrid-20201009_org/src/tsthread.c	2016-02-18 20:21:28.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/tsthread.c	2020-10-10 20:38:22.000000000 +0900
@@ -1,329 +1,893 @@
-/* fsusb2i   (c) 2015-2016 trinity19683
-  TS USB I/O thread (MS-Windows)
-  tsthread.c
-  2016-02-18
-*/
-#include "stdafx.h"
-#include <errno.h>
-#include <string.h>
-#include <process.h>
-#include <WinUSB.h>
-
-#include "usbops.h"
-#include "osdepend.h"
-#include "tsbuff.h"
-#include "tsthread.h"
-
-#define ROUNDUP(n,w) (((n) + (w)) & ~(unsigned)(w))
-
-struct TSIO_CONTEXT {
-	OVERLAPPED ol;
-	int index;
-
-};
-
-struct tsthread_param {
-	HANDLE hThread;    //# handle to thread data
-	unsigned char volatile  flags;
-	/* if 0x01 flagged, issue a new request.
-	   if 0x02 flagged, cancel requests and stop thread.
-	*/
-	const struct usb_endpoint_st*  pUSB;
-	char* buffer;    //# data buffer (in heap memory)
-	int*  actual_length;    //# actual length of each buffer block
-	unsigned buff_unitSize;
-	int buff_num;
-	int buff_push;
-	int buff_pop;
-	struct TSIO_CONTEXT ioContext[TS_MaxNumIO];
-	HANDLE hTsEvent;
-
-};
-
-
-static int submitURB(const tsthread_ptr tptr)
-{
-	//# isochronous URB request
-	struct tsthread_param* const ps = tptr;
-	DWORD i, dRet = 0;
-
-	for(i = 0; i < TS_MaxNumIO; i++) {
-		struct TSIO_CONTEXT* const pContext = &ps->ioContext[i];
-		BOOL bRet;
-		if(0 <= pContext->index) continue;
-
-		ZeroMemory( &pContext->ol, sizeof(OVERLAPPED));
-		pContext->ol.hEvent = ps->hTsEvent;
-		pContext->index = ps->buff_push;
-		if(ps->pUSB->endpoint & 0x100) { //# Isochronous
-
-			bRet = FALSE;
-			dRet = ERROR_INVALID_FUNCTION;
-			tsthread_stop(ps);
-
-		}
-		else {
-			ps->actual_length[ps->buff_push] = -2;
-			bRet = WinUsb_ReadPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF, ps->buffer + (ps->buff_push * ps->buff_unitSize), ps->buff_unitSize, NULL, &(pContext->ol));
-			dRet = GetLastError();
-		}
-		if (FALSE == bRet && ERROR_IO_PENDING != dRet) {
-			warn_info(dRet, "submitURB failed");
-			pContext->index = -1;
-		}
-		else {
-			int next_index = ps->buff_push;
-			next_index++;
-			ps->buff_push = (next_index < ps->buff_num) ? next_index : 0;
-			dRet = 0;
-		}
-
-		if (bRet) {
-			//# completed (nowait)
-			SetEvent(ps->hTsEvent);
-		}
-		if(dRet) break;
-	}
-
-	return dRet;
-}
-
-static int reapURB(const tsthread_ptr tptr)
-{
-	struct tsthread_param* const ps = tptr;
-	DWORD i, countURB = 0;
-
-	for(i = 0; i < TS_MaxNumIO; i++) {
-		struct TSIO_CONTEXT* const pContext = &ps->ioContext[i];
-		BOOL bRet;
-		DWORD dRet, bytesRead = 0;
-		if(0 > pContext->index) continue;
-
-		bRet = WinUsb_GetOverlappedResult( ps->pUSB->fd, &(pContext->ol), &bytesRead, FALSE );
-		dRet = GetLastError();
-		if(FALSE == bRet && ERROR_IO_INCOMPLETE == dRet) {
-			//# incomplete
-			countURB++;
-		}else{
-			int* const   pLen = &(ps->actual_length[pContext->index]);
-			if(ps->pUSB->endpoint & 0x100) { //# Isochronous
-
-			}
-			else {
-				if (bRet) {
-					//# success
-					if (ps->buff_unitSize < bytesRead) {
-						warn_info(bytesRead, "reapURB overflow");
-						bytesRead = ps->buff_unitSize;
-					}
-					pLen[0] = bytesRead;
-					//dmsgn("reapURB%u=%d, ",i,bytesRead);
-				}
-				else {
-					//# failed
-					pLen[0] = 0;
-					warn_msg(dRet, "reapURB%u", i);
-				}
-			}
-			pContext->index = -1;
-		}
-	}
-
-	return countURB;
-}
-
-/* TS thread function issues URB requests. */
-static unsigned int __stdcall tsthread(void* const param)
-{
-	struct tsthread_param* const ps = param;
-	ps->buff_push = 0;
-
-	for(;;) {
-		DWORD dRet;
-		if(ps->flags & 0x01) {
-			//# continue to issue a new URB request
-			submitURB(ps);
-		}
-		if(ps->flags & 0x02) {
-			//# canceled
-			reapURB(ps);
-			break; 
-		}
-
-		dRet = WaitForSingleObject( ps->hTsEvent , TS_PollTimeout );
-		if(WAIT_OBJECT_0 == dRet || WAIT_TIMEOUT == dRet) {
-			if(reapURB(ps) < 0) break;
-			//# timeout
-			if(WAIT_TIMEOUT == dRet && ps->flags & 0x01) {
-				dmsg("poll timeout");
-			}
-		}else{
-			dRet = GetLastError();
-			warn_info(dRet,"poll failed");
-			break;
-		}
-	}
-	_endthreadex( 0 );
-	return 0;
-}
-
-/* public function */
-
-int tsthread_create(tsthread_ptr* const tptr, const struct usb_endpoint_st* const pusbep)
-{
-	struct tsthread_param* ps;
-	DWORD dwRet, i;
-
-	{//#
-		const unsigned param_size  = ROUNDUP(sizeof(struct tsthread_param), 0xF);
-		const unsigned buffer_size = ROUNDUP(TS_BufSize ,0xF);
-		const unsigned unitSize = ROUNDUP(pusbep->xfer_size ,0x1FF);
-		const unsigned unitNum = TS_BufSize / unitSize;
-		const unsigned actlen_size = sizeof(int) * unitNum;
-		char *ptr, *buffer_ptr;
-		unsigned totalSize = param_size + actlen_size + buffer_size;
-		ptr = uHeapAlloc( totalSize );
-		if(NULL == ptr) {
-			dwRet = GetLastError();
-			warn_msg(dwRet,"failed to allocate TS buffer");
-			return -1;
-		}
-		buffer_ptr = ptr;
-		ptr += buffer_size;
-		ps = (struct tsthread_param*) ptr;
-		ps->buffer = buffer_ptr;
-		ptr += param_size;
-		ps->actual_length = (int*)ptr;
-		//ptr += actlen_size;
-		ps->buff_unitSize = unitSize;
-		ps->buff_num = unitNum;
-		ps->actual_length[0] = -1;   //# the first block is not-used
-
-	}
-	ps->pUSB = pusbep;
-	ps->flags = 0;
-	ps->buff_pop = 0;
-	
-	for(i = 0; i < TS_MaxNumIO; i++) {
-		ps->ioContext[i].index = -1;    //# mark it unused
-	}
-	ps->hTsEvent = CreateEvent ( NULL, FALSE, TRUE, NULL );
-	//# USB endpoint
-	WinUsb_ResetPipe(pusbep->fd, pusbep->endpoint & 0xFF);
-	i = 0x01;
-	WinUsb_SetPipePolicy(pusbep->fd, pusbep->endpoint & 0xFF, RAW_IO, sizeof(UCHAR), &i);
-	WinUsb_SetPipePolicy(pusbep->fd, pusbep->endpoint & 0xFF, AUTO_CLEAR_STALL, sizeof(UCHAR), &i);
-
-#ifdef _DEBUG
-	dwRet = sizeof(i);
-	WinUsb_GetPipePolicy(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF, MAXIMUM_TRANSFER_SIZE, &dwRet, &i);
-	dmsg("MAX_TRANSFER_SIZE=%u", i);
-#endif
-
-	ps->hThread = (HANDLE)_beginthreadex( NULL, 0, tsthread, ps, 0, NULL );
-	if(INVALID_HANDLE_VALUE == ps->hThread) {
-		warn_info(errno,"tsthread_create failed");
-		uHeapFree(ps->buffer);
-		return -1;
-	}else{
-		SetThreadPriority( ps->hThread, THREAD_PRIORITY_TIME_CRITICAL );
-	}
-	*tptr = ps;
-	return 0;
-}
-
-void tsthread_destroy(const tsthread_ptr ptr)
-{
-	struct tsthread_param* const p = ptr;
-
-	tsthread_stop(ptr);
-	p->flags |= 0x02;    //# canceled = T
-	SetEvent(p->hTsEvent);
-	if(WaitForSingleObject(p->hThread, 1000) != WAIT_OBJECT_0) {
-		warn_msg(GetLastError(),"tsthread_destroy timeout");
-		TerminateThread(p->hThread, 0);
-	}
-	CloseHandle(p->hTsEvent);
-	CloseHandle(p->hThread);
-
-	uHeapFree(p->buffer);
-}
-
-void tsthread_start(const tsthread_ptr ptr)
-{
-	struct tsthread_param* const p = ptr;
-	WinUsb_FlushPipe(p->pUSB->fd, p->pUSB->endpoint & 0xFF);
-	p->flags |= 0x01;    //# continue = T
-	if(p->pUSB->startstopFunc)
-		p->pUSB->startstopFunc(p->pUSB->dev, 1);
-
-	SetEvent(p->hTsEvent);
-}
-
-void tsthread_stop(const tsthread_ptr ptr)
-{
-	struct tsthread_param* const p = ptr;
-
-	p->flags &= ~0x01U;    //# continue = F
-	if(p->pUSB->startstopFunc)
-		p->pUSB->startstopFunc(p->pUSB->dev, 0);
-
-	if(!(p->pUSB->endpoint & 0x100) ) { //# Bulk
-		WinUsb_AbortPipe(p->pUSB->fd, p->pUSB->endpoint & 0xFF);
-	}
-}
-
-int tsthread_read(const tsthread_ptr tptr, void ** const ptr)
-{
-	struct tsthread_param* const ps = tptr;
-	int i, j;
-	i = tsthread_readable(tptr);
-	if(0 >= i) return 0;
-
-	j = ps->buff_pop;
-	ps->actual_length[ps->buff_pop] = -1;
-	if(ptr) {
-		*ptr = ps->buffer + (j * ps->buff_unitSize);
-		ps->buff_pop = (ps->buff_num - 1 > j) ? j + 1 : 0;
-	}else{
-		ps->actual_length[ps->buff_push] = -1;
-		ps->buff_pop = ps->buff_push;
-	}
-	return i;
-}
-
-int tsthread_readable(const tsthread_ptr tptr)
-{
-	struct tsthread_param* const ps = tptr;
-	int j = ps->buff_pop;
-
-	if(0 > j || ps->buff_num <= j) {  //# bug check
-		warn_info(j,"ts.buff_pop Out of range");
-		ps->buff_pop = 0;
-		return 0;
-	}
-	do {  //# skip empty blocks
-		if(0 != ps->actual_length[j] ) break;
-		if(ps->buff_num -1 > j) {
-			j++;
-		}else{
-			j = 0;
-		}
-	} while(j != ps->buff_pop);
-	ps->buff_pop = j;
-	return ps->actual_length[j];
-}
-
-int tsthread_wait(const tsthread_ptr tptr, const int timeout)
-{
-	struct tsthread_param* const ps = tptr;
-	DWORD dRet = WaitForSingleObject( ps->hTsEvent , timeout );
-	if(WAIT_OBJECT_0 == dRet)  return 1;
-	else if(WAIT_TIMEOUT == dRet)  return 0;
-
-	warn_info(dRet,"poll failed");
-	return -1;
-}
-
-
-/*EOF*/
\ ե˲Ԥޤ
+/* fsusb2i   (c) 2015-2016 trinity19683
+  TS USB I/O thread (MS-Windows)
+  tsthread.c
+  2016-02-18
+*/
+
+#include "stdafx.h"
+#include <errno.h>
+#include <string.h>
+#include <process.h>
+#include <WinUSB.h>
+#include <assert.h>
+
+#include "usbops.h"
+#include "osdepend.h"
+#include "tsbuff.h"
+#include "tsthread.h"
+
+#if defined(_WIN32) && !defined(_WIN64)
+//#define X86_ASM
+#endif
+
+#define HasSignal(e) (WaitForSingleObject(e,0)==WAIT_OBJECT_0)
+
+#define ROUNDUP(n,w) (((n) + (w)) & ~(unsigned)(w))
+
+//# pipe policy settings
+BOOL USBPIPEPOLICY_RAW_IO = TRUE ;
+BOOL USBPIPEPOLICY_AUTO_CLEAR_STALL = TRUE ;
+BOOL USBPIPEPOLICY_ALLOW_PARTIAL_READS = TRUE ;
+BOOL USBPIPEPOLICY_AUTO_FLUSH = FALSE ;
+BOOL USBPIPEPOLICY_IGNORE_SHORT_PACKETS = FALSE ;
+BOOL USBPIPEPOLICY_SHORT_PACKET_TERMINATE = FALSE ;
+DWORD USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT = 5000UL ;
+BOOL USBPIPEPOLICY_RESET_PIPE_ON_RESUME = FALSE ;
+
+
+struct TSIO_CONTEXT {
+#ifdef INCLUDE_ISOCH_XFER
+	USBD_ISO_PACKET_DESCRIPTOR isochFrameDesc[ISOCH_PacketFrames];
+#endif
+	OVERLAPPED ol;
+	int index;
+	DWORD bytesRead;
+};
+
+struct tsthread_param {
+	HANDLE hThread;    //# handle to thread data
+	unsigned char volatile  flags;
+	/* if 0x01 flagged, issue a new request.
+	   if 0x02 flagged, cancel requests and stop thread.
+	*/
+	const struct usb_endpoint_st*  pUSB;
+	char* buffer;    //# data buffer (in heap memory)
+	int*  actual_length;    //# actual length of each buffer block
+	unsigned xfer_size;
+	unsigned buff_size;
+	unsigned buff_unitSize;
+	int buff_num;
+	int buff_push;
+	int buff_pop;
+	int total_submit ;
+	struct TSIO_CONTEXT ioContext[TS_MaxNumIO];
+	HANDLE hTsEvents[TS_MaxNumIO*2-1] ;
+	HANDLE hTsAvailable,hTsRead,hTsRestart,hTsStopped ;
+
+	struct tsfifo_t* tsfifo ; //# ts fifo caching object
+
+	//# critical object
+	CRITICAL_SECTION csTsExclusive;
+
+#ifdef INCLUDE_ISOCH_XFER
+	WINUSB_ISOCH_BUFFER_HANDLE hIsochBuffer;
+#endif
+};
+
+  static int __inline isCritical(struct tsthread_param* const ps) {
+	return !(ps->flags & 0x01)||HasSignal(ps->hTsRestart) ;
+  }
+
+  static void __inline lockWinUsb(struct tsthread_param* const ps,int lock) {
+	if(ps->pUSB->lockunlockFunc)
+		 ps->pUSB->lockunlockFunc(ps->pUSB->dev,lock) ;
+  }
+
+
+static void tsthread_purgeURB(const tsthread_ptr ptr)
+{
+	struct tsthread_param* const ps = ptr;
+	int i;
+
+	EnterCriticalSection(&ps->csTsExclusive);
+	lockWinUsb(ps,1);
+
+	if(!(ps->pUSB->endpoint & 0x100) ) { //# Bulk
+
+		WinUsb_AbortPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF);
+
+		if(ps->total_submit>0) {
+
+			for (i = 0;i < TS_MaxNumIO;i++) {
+				struct TSIO_CONTEXT* pContext = &ps->ioContext[i];
+				if(pContext->index>=0) {
+					if(ps->tsfifo&&ps->tsfifo->writeBackFinish)
+						ps->tsfifo->writeBackFinish(pContext->index,0,ps->tsfifo->arg);
+					/*
+					else
+						ps->actual_length[pContext->index]=0;*/
+					ResetEvent(pContext->ol.hEvent);
+					pContext->index=-1 ;
+				}
+			}
+
+
+			ps->total_submit = 0;
+
+		}
+	}
+
+
+	#if 1
+	if(ps->tsfifo) {
+		if(ps->tsfifo->purge)
+			ps->tsfifo->purge(ps->tsfifo->arg);
+	}
+	if(ps->actual_length) {
+		if(!(ps->pUSB->endpoint & 0x100) ) { //# Bulk
+			for (i = 0;i < ps->buff_num;i++) {
+				ps->actual_length[i]=-1 ;
+			}
+			ps->buff_pop = ps->buff_push ;
+		}
+		else { //# Isochronous
+			void* ptr; while(tsthread_read( ps, &ptr )>0);
+		}
+	}
+	#endif
+
+	WinUsb_FlushPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF);
+	ps->flags &= ~0x10; //# reset isochronous continuous status
+
+	lockWinUsb(ps,0);
+	LeaveCriticalSection(&ps->csTsExclusive);
+}
+
+//# 2020-10-5
+//#   Added the URB feature for the isochronous transfer mode.
+//# 2018-3-1
+//#   Removed the tsthread_submitURB static function.
+//#   Removed the tsthread_reapURB static function.
+//#   Added the tsthread_bulkURB static function instead of submitURB/reapURB.
+//# Fixed by 2018-2020 LVhJPic0JSk5LiQ1ITskKVk9UGBg
+static unsigned int tsthread_bulkURB(struct tsthread_param* const ps)
+{
+
+	//# number of the prefetching buffer busy area that shouldn't be submitted
+	const int POPDELTA = (TS_CalcDeadZone(ps->buff_size)+ps->buff_unitSize-1)/ps->buff_unitSize;
+
+	int ri=0; //# the circular index based ioContext cursor for reaping
+	int si=0; //# the circular index based ioContext cursor for submitting
+	BOOL bRet ;
+	DWORD dRet=0 ;
+
+	//# the pointer of a ts fifo caching object
+	struct tsfifo_t *pTSFifo = ps->tsfifo ;
+
+	//# the write through ts fifo caching feature is existed or not
+	const BOOL hasWThrough = pTSFifo && pTSFifo->writeThrough ? TRUE : FALSE ;
+
+	//# the write back ts fifo caching feature is enabled or not
+	const BOOL isWBack =
+#ifdef INCLUDE_ISOCH_XFER
+			(ps->pUSB->endpoint & 0x100) ? FALSE:
+#endif
+			(pTSFifo && pTSFifo->writeBackBegin && pTSFifo->writeBackFinish ? TRUE: FALSE);
+
+	//# prefetching frames per a packet
+	const int frames =
+#ifdef INCLUDE_ISOCH_XFER
+		(ps->pUSB->endpoint & 0x100) ? ISOCH_PacketFrames :
+#endif
+		1 ;
+
+	//# check the contradiction of caching methods
+	assert( !isWBack != (ps->actual_length==NULL) ) ;
+	assert( !isWBack || (isWBack && !hasWThrough) ) ;
+
+	//# bulk loop
+	while(!(ps->flags&0x02)) {
+
+		if(HasSignal(ps->hTsRestart)) {
+			tsthread_purgeURB(ps) ;
+			ResetEvent(ps->hTsRestart) ;
+			continue;
+		}
+
+		if (!(ps->flags & 0x01)) {
+			SetEvent(ps->hTsStopped);
+			WaitForSingleObject(ps->hTsAvailable, TS_PollTimeout) ;
+			continue ;
+		}
+
+#ifndef INCLUDE_ISOCH_XFER
+		if (ps->pUSB->endpoint & 0x100) { //# Isochronous
+			if(ps->flags & 0x01) {
+				tsthread_stop(ps);
+				continue ;
+			}
+		}
+#endif
+
+		if(ps->total_submit>0) {
+
+			//# poll
+			int next_wait_index=-1 ;
+			int max_wait_count = ps->total_submit<MAXIMUM_WAIT_OBJECTS ? ps->total_submit : MAXIMUM_WAIT_OBJECTS ;
+			dRet = WaitForMultipleObjects(max_wait_count, &ps->hTsEvents[ri] , FALSE, TS_PollTimeout );
+			if (isCritical(ps)) continue;
+			if(WAIT_OBJECT_0 <= dRet&&dRet < WAIT_OBJECT_0+max_wait_count) {
+				int end_index=(ri+ps->total_submit)%TS_MaxNumIO ;
+				next_wait_index = ((dRet - WAIT_OBJECT_0)+1 + ri)%TS_MaxNumIO ;
+				while(next_wait_index!=end_index) {
+					if(!HasSignal(ps->hTsEvents[next_wait_index]))
+						break ;
+					if (++next_wait_index >= TS_MaxNumIO)
+						next_wait_index ^= next_wait_index ;
+				}
+			}else if(WAIT_TIMEOUT!=dRet) {
+				dRet = GetLastError();
+				warn_info(dRet,"poll failed");
+				break;
+			}
+
+			//# reap
+			if(next_wait_index>=0) do {
+
+				struct TSIO_CONTEXT* pContext = &ps->ioContext[ri];
+				if(pContext->index>=0) {
+
+					DWORD bytesRead=pContext->bytesRead ;
+
+					if (isCritical(ps)) break;
+					//if(!HasSignal(ps->hTsEvents[ri])) break ;
+					if(bytesRead>0) {
+						bRet = TRUE;
+						dRet = 0;
+					}else {
+						lockWinUsb(ps,1) ;
+						if (isCritical(ps)) {
+							bRet=FALSE ;
+							dRet=ERROR_OPERATION_ABORTED ;
+						}else {
+							bRet = WinUsb_GetOverlappedResult(
+								ps->pUSB->fd, &(pContext->ol), &bytesRead, FALSE);
+							dRet = GetLastError();
+						}
+						lockWinUsb(ps,0) ;
+					}
+					if (ps->buff_unitSize < bytesRead) {
+						DBGOUT("reap: size over (size=%d)\n",bytesRead) ;
+						warn_info(bytesRead, "reapURB overflow");
+						bytesRead = ps->buff_unitSize;
+					}
+					if(bRet) {
+#ifndef INCLUDE_ISOCH_XFER
+						if (ps->pUSB->endpoint & 0x100)
+							bytesRead = 0;
+#endif
+#ifdef TS_IgnoreShortPacket
+						if (ps->xfer_size>bytesRead) {
+							//if(bytesRead>0)
+								DBGOUT("reap: short packet (size=%d)\n",bytesRead) ;
+							bytesRead=0;
+						}
+#endif
+					}else {
+						DBGOUT("reap: error (code=%d, size=%d)\n",dRet,bytesRead) ;
+						if(ERROR_IO_INCOMPLETE == dRet) { //# incomplete
+							break;  //# looking forward to the next time...
+						}
+						#if 1
+						if(ERROR_SEM_TIMEOUT == dRet) { //# timeout
+							break;  //# looking forward to the next time...
+						}
+						#endif
+						//# failed
+						bytesRead = 0;
+						//ps->flags &= ~0x10;
+						warn_msg(dRet, "reapURB%u failed", ri);
+					}
+					EnterCriticalSection(&ps->csTsExclusive) ;
+					if(pContext->index>=0) {
+						if (ps->pUSB->endpoint & 0x100) {
+#ifdef INCLUDE_ISOCH_XFER
+#if defined(_WIN32) && !defined(_WIN64)
+
+							int stride = (char*) &pContext->isochFrameDesc[1]
+								- (char*) &pContext->isochFrameDesc[0] ;
+							void* sp_ = &pContext->isochFrameDesc[0].Length ;
+							void* dp_ = &ps->actual_length[pContext->index] ;
+							int dx_ = (char*) &pContext->isochFrameDesc[0].Status
+								- (char*) &pContext->isochFrameDesc[0].Length ;
+							int errors = 0 ;
+							_asm {
+								mov ecx, frames
+								mov edi, dp_
+								cld
+								cmp bRet, 0
+								je lb3
+								xor ebx, ebx
+								mov esi, sp_
+								mov eax, stride
+								mov edx, dx_
+							lb1:
+								cmp dword ptr [esi+edx], 0
+								jne lb2
+								movsd
+								lea esi, [esi+eax-4]
+								dec ecx
+								jnz lb1
+								jmp lb4
+							lb2:
+								mov dword ptr [edi], 0
+								lea edi, [edi+4]
+								lea esi, [esi+eax]
+								inc ebx
+								dec ecx
+								jnz lb1
+								jmp lb4
+							lb3:
+								mov ebx, ecx
+								xor eax, eax
+								rep stosd
+							lb4:
+								mov errors, ebx
+							}
+							if(errors>0)
+								warn_msg(dRet, "reapURB(%u)", errors);
+#else
+							register int n,*pLen = &ps->actual_length[pContext->index];
+							register const USBD_ISO_PACKET_DESCRIPTOR *pDesc=&pContext->isochFrameDesc[frames-1];
+							if(!bRet)
+								__stosd(pLen,0,frames);
+							else for (n = frames ; n ; n--, pDesc--) {
+								if (pDesc->Status) {
+									pLen[n-1] =  0;
+									warn_msg(dRet, "reapURB%u.%u", ri, n-1);
+								}
+								else
+									pLen[n-1] = pDesc->Length ;
+							}
+#endif
+#endif
+						}else {
+							if (isWBack)
+								pTSFifo->writeBackFinish(ri, bytesRead, pTSFifo->arg);
+							else
+								ps->actual_length[pContext->index] = bytesRead;
+							if(bytesRead) SetEvent(ps->hTsAvailable) ;
+						}
+						ResetEvent(ps->hTsEvents[ri]);
+						pContext->index=-1 ;
+						ps->total_submit-- ;
+					}
+					LeaveCriticalSection(&ps->csTsExclusive) ;
+				}
+				if(++ri>=TS_MaxNumIO) ri^=ri ;
+				if(ps->total_submit<=0) break ;
+
+			}while(ri!=next_wait_index);
+
+		}
+
+		if(!ps->total_submit) {
+
+			//# I/O stall
+			ri = si ;
+			DBGOUT("io stall\n");
+
+		}
+
+		if(hasWThrough) {
+
+			//# write through caching
+			BYTE *esi=NULL,*edi ;
+			int sz,amount=0;
+			do {
+				edi = NULL ;
+				sz  = tsthread_read( ps, (void**) &edi ) ;
+				if(edi) {
+					if(!esi)
+						esi=edi, amount=sz, sz=0 ;
+					else if(&esi[amount]==edi)
+						amount+=sz, sz=0 ;
+				}
+				if(!edi||sz>0) {
+					if(esi) pTSFifo->writeThrough(esi, amount, pTSFifo->arg) ;
+					esi=edi, amount=sz ;
+				}
+			}while(esi);
+
+		}
+
+		if (HasSignal(ps->hTsRestart)) continue;
+
+		if(ps->total_submit<TS_MaxNumIO) {
+
+			//# submit
+			if(ps->flags & 0x01) {
+				void *buffer;
+				DWORD lnTransfered;
+				int num_empties=0,max_empties=TS_MaxNumIO;
+				int last_state=0;
+				dRet = 0;bRet = FALSE;
+				//# calculate the real maximum number of submittable empties
+				if(!isWBack) {
+					EnterCriticalSection(&ps->csTsExclusive) ;
+					tsthread_readable(ps);
+					last_state = ps->actual_length[ps->buff_pop] ;
+					#if 1
+					if(ps->buff_push==ps->buff_pop)
+						max_empties =
+							last_state>0||last_state==-2 ? 0 : ps->buff_num ;
+					else
+					#endif
+						max_empties = ps->buff_push<ps->buff_pop ?
+							ps->buff_pop-ps->buff_push :
+							ps->buff_num-ps->buff_push + ps->buff_pop ;
+					ResetEvent(ps->hTsRead);
+					LeaveCriticalSection(&ps->csTsExclusive) ;
+					max_empties -= POPDELTA; //# subtract deadzone
+				}
+				//# summary amount of empties
+				num_empties=TS_MaxNumIO-ps->total_submit;
+				num_empties*=frames;
+				//start=si ;
+				if(num_empties>max_empties) {
+					num_empties = max_empties ;
+					#if 1
+					if(num_empties<=0&&ps->total_submit<=0) {
+						//# in the dead zone
+						if(!isWBack&&last_state>0) {
+							HANDLE events[2];
+							events[0]=ps->hTsRead;
+							events[1]=ps->hTsRestart ;
+							//# wait for reading buffer...
+							dRet=WaitForMultipleObjects(2, events , FALSE, TS_PollTimeout );
+							if(dRet==WAIT_TIMEOUT)
+							  DBGOUT("read: wait timeout\n") ;
+							else if(dRet==WAIT_OBJECT_0)
+							  DBGOUT("read: wait success\n") ;
+						}
+					}
+					#endif
+				}
+				//# submit to empties
+				while (num_empties-frames >= 0) {
+					struct TSIO_CONTEXT* pContext = &ps->ioContext[si];
+					if (isCritical(ps)) break;
+					if(ps->total_submit>=TS_MaxNumIO) break;
+					if (pContext->index>=0) break ;
+					//if (HasSignal(ps->hTsEvents[ri])) break;
+#ifndef INCLUDE_ISOCH_XFER
+					if (ps->pUSB->endpoint & 0x100) { //# Isochronous
+						//tsthread_stop(ps);
+						break;
+					}
+#endif
+					if(isWBack) {
+						buffer = pTSFifo->writeBackBegin(si, ps->buff_unitSize, pTSFifo->arg) ;
+						if(!buffer) break ; //# buffer overflow
+					}
+					else {
+						register int n,*p=&ps->actual_length[ps->buff_push] ;
+						for(n=frames;n;n--)
+							if(p[n-1]>0||p[n-1]==-2) break;
+						if(n) break ; //# buffer busy
+					}
+					EnterCriticalSection(&ps->csTsExclusive) ;
+					if(!isWBack) {
+						buffer = ps->buffer + (ps->buff_push * ps->buff_unitSize) ;
+						last_state =  ps->actual_length[ps->buff_push] ;
+						ps->actual_length[ps->buff_push] = -2;
+					}
+					pContext->index = isWBack ? si : ps->buff_push;
+					pContext->bytesRead = 0 ;
+					ZeroMemory(&pContext->ol,sizeof(OVERLAPPED));
+					pContext->ol.hEvent = ps->hTsEvents[si];
+					lnTransfered = 0;
+					ResetEvent(pContext->ol.hEvent);
+					lockWinUsb(ps,1) ;
+					if(isCritical(ps)) {
+						bRet=FALSE ;
+						dRet=ERROR_OPERATION_ABORTED ;
+					}else{
+						if (ps->pUSB->endpoint & 0x100) { //# Isochronous
+#ifdef INCLUDE_ISOCH_XFER
+							bRet = WinUsb_ReadIsochPipeAsap(
+								ps->hIsochBuffer,
+								ps->buff_push * ps->buff_unitSize, // offset
+								frames * ps->buff_unitSize,  // length
+								ps->flags & 0x10 ? TRUE: FALSE, // continuous
+								frames, pContext->isochFrameDesc,
+								&(pContext->ol));
+							dRet = GetLastError();
+							if (!bRet && ERROR_INVALID_PARAMETER == dRet)
+								ps->flags &= ~0x10;
+							else if(!(ps->flags & 0x10))
+								ps->flags |= 0x10;
+#endif
+						}else {
+							bRet = WinUsb_ReadPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF,
+								buffer, ps->buff_unitSize, &lnTransfered, &(pContext->ol));
+							dRet = GetLastError();
+						}
+					}
+					lockWinUsb(ps,0) ;
+					if (FALSE == bRet && ERROR_IO_PENDING != dRet) {
+						//# submitting failed
+						DBGOUT("submit: error (code=%d, size=%d)\n",dRet,lnTransfered) ;
+						warn_info(dRet, "submitURB failed");
+						if(isWBack)
+							pTSFifo->writeBackFinish(si,0,pTSFifo->arg);
+						else
+							ps->actual_length[ps->buff_push] = last_state;
+						ResetEvent(ps->hTsEvents[si]);
+						pContext->index = -1;
+					}else {
+						//# submitting succeeded
+						if(!isWBack) {
+#if defined(INCLUDE_ISOCH_XFER)
+							if(frames>1)
+								__stosd(&ps->actual_length[ps->buff_push+1],-2,frames-1);
+#elif defined(_DEBUG)
+							assert(frames==1);
+#endif
+							if(ps->buff_push+frames>=ps->buff_num)
+								ps->buff_push=0;
+							else
+								ps->buff_push+=frames;
+						}
+						if(bRet) {
+							DBGOUT("submit: success (size=%d)\n",lnTransfered) ;
+							pContext->bytesRead = lnTransfered ;
+							SetEvent(ps->hTsEvents[si]) ;
+						}else {
+							if(lnTransfered>0)
+								DBGOUT("submit: pending (size=%d)\n",lnTransfered) ;
+						}
+						dRet = 0;
+						if(++si >= TS_MaxNumIO) si^=si;
+						++ps->total_submit;
+					}
+					LeaveCriticalSection(&ps->csTsExclusive) ;
+					//# check submitting failed or not
+					if(/*dRet||*/pContext->index<0) break ;
+					num_empties-=frames;
+				}
+				//if(dRet) break ;
+			}
+
+		}
+
+	}
+
+	//# dispose
+	tsthread_purgeURB(ps);
+
+	return dRet ;
+}
+
+/* TS thread function issues URB requests. */
+static unsigned int __stdcall tsthread(void* const param)
+{
+	struct tsthread_param* const ps = param;
+	unsigned int result = 0;
+
+	ps->buff_push = 0;
+
+	result = tsthread_bulkURB(ps);
+
+	_endthreadex( 0 );
+	return result ;
+}
+
+/* public function */
+
+int tsthread_create( tsthread_ptr* const tptr,
+					 const struct usb_endpoint_st* const pusbep,
+					 const struct tsfifo_t * const ptsfifo
+				   )
+{
+
+	struct tsthread_param* ps;
+	DWORD dwRet, i;
+
+	{ //#
+		const BOOL tsfifo_exists = ptsfifo ? TRUE : FALSE ;
+		const BOOL wback_exists =
+#ifdef INCLUDE_ISOCH_XFER
+			(pusbep->endpoint & 0x100) ? FALSE:
+#endif
+			(tsfifo_exists && ptsfifo->writeBackBegin && ptsfifo->writeBackFinish? TRUE: FALSE);
+		const unsigned param_size = ROUNDUP( sizeof( struct tsthread_param ), 0xF );
+		const unsigned xferSize = pusbep->xfer_size ;
+		const unsigned unitSize = pusbep->endpoint & 0x100 ? xferSize : ROUNDUP( xferSize, 0x1FF ) ;
+		const unsigned unitNum =
+#ifdef INCLUDE_ISOCH_XFER
+			pusbep->endpoint & 0x100 ? ISOCH_PacketFrames*TS_BufPackets :
+#endif
+			TS_CalcBufSize(xferSize)/unitSize ;
+		const unsigned buffSize = wback_exists ? 0 : unitSize*unitNum ;
+		const unsigned buffer_size = wback_exists ? 0 : ROUNDUP( buffSize+TS_DeltaSize , 0xF );
+		const unsigned actlen_size = wback_exists ? 0 : sizeof( int ) * unitNum;
+		const unsigned tsfifo_size = tsfifo_exists ? ROUNDUP( sizeof( struct tsfifo_t ), 0xF) : 0;
+		char *ptr, *buffer_ptr;
+		struct tsfifo_t *tsfifo_ptr;
+		unsigned totalSize = param_size + actlen_size + buffer_size + tsfifo_size ;
+		ptr = uHeapAlloc( totalSize );
+		if ( NULL == ptr ) {
+			dwRet = GetLastError();
+			warn_msg( dwRet, "failed to allocate TS buffer" );
+			return -1;
+		}
+		buffer_ptr = ptr;
+		ptr += buffer_size;
+		ps = ( struct tsthread_param* ) ptr;
+		ps->buffer = buffer_ptr;
+		ptr += param_size;
+		ps->actual_length = ( int* ) ptr ;
+		ptr += actlen_size;
+		tsfifo_ptr = ( struct tsfifo_t * ) ptr;
+		ptr += tsfifo_size;
+		ps->xfer_size= xferSize;
+		ps->buff_unitSize = unitSize;
+		ps->buff_num = unitNum;
+		ps->buff_size = buffSize;
+		assert(ptr-buffer_ptr==totalSize) ;
+		if ( actlen_size ) {
+			for ( i = 0;i < unitNum;i++ )
+				ps->actual_length[ i ] = -1;   //# reset all values to empty
+		}else
+			ps->actual_length = NULL;
+		if ( tsfifo_exists ) {
+			CopyMemory( tsfifo_ptr, ptsfifo, sizeof( struct tsfifo_t ) );
+			ps->tsfifo = tsfifo_ptr;
+		}else
+			ps->tsfifo = NULL ;
+	}
+	ps->pUSB = pusbep;
+	ps->flags = 0;
+	ps->buff_pop = 0;
+	ps->total_submit = 0;
+#ifdef INCLUDE_ISOCH_XFER
+	ps->hIsochBuffer = NULL;
+	if (pusbep->endpoint & 0x100)
+		DBGOUT("-*- ISOCHRONOUS TRANSFER MODE -*-\n") ;
+#else
+	if (pusbep->endpoint & 0x100) { //# Isochronous
+		warn_msg(0, "Please change to BULK transfer mode :-P");
+	}
+#endif
+
+	for ( i = 0; i < TS_MaxNumIO; i++ ) {
+		ps->ioContext[ i ].index = -1;    //# mark it unused
+		ps->hTsEvents[ i ] = CreateEvent( NULL, TRUE, FALSE, NULL );
+		ZeroMemory( &ps->ioContext[ i ].ol, sizeof( OVERLAPPED ) );
+		ps->ioContext[ i ].ol.hEvent = ps->hTsEvents[ i ];
+	}
+
+	//# it arranges for event handles to look like circular buffer
+	for ( i = 0; i < TS_MaxNumIO - 1; i++ ) {
+		ps->hTsEvents[ i + TS_MaxNumIO ] = ps->hTsEvents[ i ];
+	}
+	ps->hTsAvailable = CreateEvent( NULL, FALSE, FALSE, NULL );
+	ps->hTsRead = CreateEvent( NULL, FALSE, FALSE, NULL );
+	ps->hTsRestart = CreateEvent( NULL, TRUE, FALSE, NULL );
+	ps->hTsStopped = CreateEvent( NULL, FALSE, FALSE, NULL );
+	InitializeCriticalSection(&ps->csTsExclusive) ;
+
+	//# USB endpoint
+	WinUsb_ResetPipe( pusbep->fd, pusbep->endpoint & 0xFF );
+	#define SETUSBPIPEPOLICY_BOOL(name) do { UCHAR v=(DWORD)USBPIPEPOLICY_##name?1:0; \
+		WinUsb_SetPipePolicy( pusbep->fd, \
+			pusbep->endpoint & 0xFF, name,  sizeof( UCHAR ), &v ); }while(0)
+	#define SETUSBPIPEPOLICY_DWORD(name) do { DWORD v=(DWORD)USBPIPEPOLICY_##name; \
+		WinUsb_SetPipePolicy( pusbep->fd, \
+			pusbep->endpoint & 0xFF, name,  sizeof( DWORD ), &v ); }while(0)
+	SETUSBPIPEPOLICY_BOOL(RAW_IO);
+	SETUSBPIPEPOLICY_BOOL(AUTO_CLEAR_STALL);
+	SETUSBPIPEPOLICY_BOOL(ALLOW_PARTIAL_READS);
+	SETUSBPIPEPOLICY_BOOL(AUTO_FLUSH);
+	SETUSBPIPEPOLICY_BOOL(IGNORE_SHORT_PACKETS);
+	SETUSBPIPEPOLICY_BOOL(SHORT_PACKET_TERMINATE);
+	SETUSBPIPEPOLICY_DWORD(PIPE_TRANSFER_TIMEOUT);
+	SETUSBPIPEPOLICY_BOOL(RESET_PIPE_ON_RESUME);
+	#undef SETUSBPIPEPOLICY_BOOL
+	#undef SETUSBPIPEPOLICY_DWORD
+
+	#ifdef _DEBUG
+
+	dwRet = sizeof( i );
+	WinUsb_GetPipePolicy( ps->pUSB->fd, ps->pUSB->endpoint & 0xFF, MAXIMUM_TRANSFER_SIZE, &dwRet, &i );
+	dmsg( "MAX_TRANSFER_SIZE=%u", i );
+	#endif
+
+	ps->hThread = ( HANDLE ) _beginthreadex( NULL, 0, tsthread, ps, 0, NULL );
+	if ( INVALID_HANDLE_VALUE == ps->hThread ) {
+		warn_info( errno, "tsthread_create failed" );
+		uHeapFree( ps->buffer );
+		return -1;
+	} else {
+		SetThreadPriority( ps->hThread, THREAD_PRIORITY_HIGHEST );
+	}
+	*tptr = ps;
+
+	return 0;
+}
+
+void tsthread_destroy(const tsthread_ptr ptr)
+{
+	int i;
+	struct tsthread_param* const p = ptr;
+
+	tsthread_stop(ptr);
+	p->flags |= 0x02;    //# canceled = T
+	SetEvent(p->hTsRead);
+	SetEvent(p->hTsAvailable);
+	if (WaitForSingleObject(p->hThread, 1000) != WAIT_OBJECT_0) {
+		warn_msg(GetLastError(), "tsthread_destroy timeout");
+		TerminateThread(p->hThread, 0);
+	}
+	for (i = 0; i < TS_MaxNumIO; i++)
+		CloseHandle(p->hTsEvents[i]);
+	CloseHandle(p->hTsAvailable);
+	CloseHandle(p->hTsRead);
+	CloseHandle(p->hTsRestart);
+	CloseHandle(p->hThread);
+	CloseHandle(p->hTsStopped);
+#ifdef INCLUDE_ISOCH_XFER
+	if(p->hIsochBuffer) {
+		WinUsb_UnregisterIsochBuffer( p->hIsochBuffer );
+		p->hIsochBuffer = NULL;
+	}
+#endif
+	DeleteCriticalSection(&p->csTsExclusive);
+
+	uHeapFree(p->buffer);
+}
+
+void tsthread_start(const tsthread_ptr ptr)
+{
+	struct tsthread_param* const ps = ptr;
+
+	EnterCriticalSection(&ps->csTsExclusive) ;
+	lockWinUsb(ps,1);
+
+	WinUsb_FlushPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF);
+	ps->flags &= ~0x10 ; //# reset isochronous continuous status
+
+#ifdef INCLUDE_ISOCH_XFER
+	if( (ps->pUSB->endpoint & 0x100) && !ps->hIsochBuffer) { //# Isochronous
+		if (!WinUsb_RegisterIsochBuffer(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF,
+			ps->buffer, ps->buff_size, &(ps->hIsochBuffer))) {
+			DWORD dwRet = GetLastError();
+			ps->hIsochBuffer = NULL;
+			warn_info(dwRet, "WinUsb_RegisterIsochBuffer failed");
+			DBGOUT("-*- Isoch Buffer Creation Failed -*-\n") ;
+		}else {
+			DBGOUT(
+				"Isoch buffer size = %d (unit size = %d, unit num = %d)\n",
+				ps->buff_size, ps->buff_unitSize, ps->buff_num);
+		}
+	}
+#endif
+
+	ps->flags |= 0x01;    //# continue = T
+	if (ps->pUSB->startstopFunc)
+		ps->pUSB->startstopFunc(ps->pUSB->dev, 1);
+
+	SetEvent(ps->hTsAvailable);
+
+	lockWinUsb(ps,0);
+	LeaveCriticalSection(&ps->csTsExclusive) ;
+}
+
+void tsthread_stop(const tsthread_ptr ptr)
+{
+	struct tsthread_param* const ps = ptr;
+
+	EnterCriticalSection(&ps->csTsExclusive) ;
+	lockWinUsb(ps,1);
+
+	ResetEvent(ps->hTsStopped);
+	ps->flags &= ~0x01U;    //# continue = F
+
+	if(ps->pUSB->startstopFunc)
+		ps->pUSB->startstopFunc(ps->pUSB->dev, 0);
+#ifdef INCLUDE_ISOCH_XFER
+	if(ps->hIsochBuffer) {
+		WinUsb_UnregisterIsochBuffer( ps->hIsochBuffer );
+		ps->hIsochBuffer = NULL;
+	}
+#endif
+
+	if(!(ps->pUSB->endpoint & 0x100) ) { //# Bulk
+		WinUsb_AbortPipe(ps->pUSB->fd, ps->pUSB->endpoint & 0xFF);
+	}
+
+	SetEvent(ps->hTsRestart) ;
+
+	lockWinUsb(ps,0);
+	LeaveCriticalSection(&ps->csTsExclusive) ;
+
+	if(!(ps->pUSB->endpoint & 0x100) ) { //# Bulk
+		WaitForSingleObject(ps->hTsStopped,USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT);
+	}
+}
+
+int tsthread_read(const tsthread_ptr tptr, void ** const ptr)
+{
+	struct tsthread_param* const ps = tptr;
+	int i, j;
+
+	if(!ptr) {
+		//# purge
+		SetEvent(ps->hTsRestart);
+		return 0 ;
+	}
+
+	if(!ps->actual_length)
+		return 0 ;
+
+	EnterCriticalSection(&ps->csTsExclusive) ;
+	i = tsthread_readable(tptr);
+	if(0 < i) {
+		j = ps->buff_pop;
+		ps->actual_length[ps->buff_pop] = -1;
+		*ptr = ps->buffer + (j * ps->buff_unitSize);
+		ps->buff_pop = (ps->buff_num - 1 > j) ? j + 1 : 0;
+		SetEvent(ps->hTsRead) ;
+	}
+	LeaveCriticalSection(&ps->csTsExclusive) ;
+
+	return i<0 ? 0:i ;
+}
+
+int tsthread_readable(const tsthread_ptr tptr)
+{
+	struct tsthread_param* const ps = tptr;
+	int j ;
+
+	if(!ps->actual_length) return 0 ;
+	if(!(ps->flags&0x01U)) return 0;
+	if(HasSignal(ps->hTsRestart))
+		return 0 ;
+
+	EnterCriticalSection(&ps->csTsExclusive) ;
+	j= ps->buff_pop;
+	if(0 > j || ps->buff_num <= j) {  //# bug check
+		warn_info(j,"ts.buff_pop Out of range");
+		j = -1;
+	}
+	else do {  //# skip empty blocks
+		if(!ps->actual_length[j]) {
+			ps->actual_length[j]=-1;
+		}else break;
+		if(ps->buff_num -1 > j) {
+			j++;
+		}else{
+			j = 0;
+		}
+	} while(j != ps->buff_pop);
+	ps->buff_pop = j<0 ? 0 : j ;
+	LeaveCriticalSection(&ps->csTsExclusive) ;
+	return j<0 ? 0 : ps->actual_length[j];
+}
+
+int tsthread_wait(const tsthread_ptr tptr, const int timeout)
+{
+	struct tsthread_param* const ps = tptr;
+	DWORD dRet ;
+	if(tsthread_readable(tptr)>0) return 1 ; //# already available
+	dRet = WaitForSingleObject( ps->hTsAvailable , timeout );
+	if(WAIT_OBJECT_0 == dRet)  return 1;
+	else if(WAIT_TIMEOUT == dRet)  return 0;
+
+	warn_info(dRet,"poll failed");
+	return -1;
+}
+
+
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/tsthread.h BonD_FSHybrid-20201009_mod2/src/tsthread.h
--- BonD_FSHybrid-20201009_org/src/tsthread.h	2016-01-04 16:39:06.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/tsthread.h	2020-10-03 07:43:48.000000000 +0900
@@ -6,9 +6,36 @@
 #pragma once
 #include "types_u.h"
 
+//# pipe policy settings
+extern BOOL USBPIPEPOLICY_RAW_IO;
+extern BOOL USBPIPEPOLICY_AUTO_CLEAR_STALL;
+extern BOOL USBPIPEPOLICY_ALLOW_PARTIAL_READS;
+extern BOOL USBPIPEPOLICY_AUTO_FLUSH;
+extern BOOL USBPIPEPOLICY_IGNORE_SHORT_PACKETS;
+extern BOOL USBPIPEPOLICY_SHORT_PACKET_TERMINATE;
+extern DWORD USBPIPEPOLICY_PIPE_TRANSFER_TIMEOUT;
+extern BOOL USBPIPEPOLICY_RESET_PIPE_ON_RESUME;
+
 typedef void* tsthread_ptr;
 
-int tsthread_create(tsthread_ptr* const, const struct usb_endpoint_st * const);
+typedef void *(*tsfifo_writeback_begin_t)(int id, size_t max_size, void *arg) ;
+typedef void (*tsfifo_writeback_finish_t)(int id, size_t wrote_size, void *arg) ;
+typedef void (*tsfifo_writethrough_t)(const void *buffer, size_t size, void *arg) ;
+typedef void (*tsfifo_purge_t)(void *arg) ;
+
+struct tsfifo_t {
+  //# For the write back caching  
+  tsfifo_writeback_begin_t      writeBackBegin;
+  tsfifo_writeback_finish_t     writeBackFinish;
+  //# For the write through caching  
+  tsfifo_writethrough_t         writeThrough;
+  //# For purging the fifo cache
+  tsfifo_purge_t                purge;
+  //# App's argument to be called back
+  void *                        arg;
+};
+
+int tsthread_create(tsthread_ptr* const, const struct usb_endpoint_st * const, const struct tsfifo_t *const);
 void tsthread_destroy(const tsthread_ptr);
 void tsthread_start(const tsthread_ptr);
 void tsthread_stop(const tsthread_ptr);
@@ -16,4 +43,4 @@
 int tsthread_readable(const tsthread_ptr);
 int tsthread_wait(const tsthread_ptr, const int);
 
-/*EOF*/
\ ե˲Ԥޤ
+/*EOF*/
diff -uPr BonD_FSHybrid-20201009_org/src/twindbg.h BonD_FSHybrid-20201009_mod2/src/twindbg.h
--- BonD_FSHybrid-20201009_org/src/twindbg.h	2010-09-22 03:19:32.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/twindbg.h	2019-12-06 00:36:44.000000000 +0900
@@ -1,10 +1,39 @@
 #pragma once
 
+#define DEBUG_TO_X_DRIVE
+
 #ifdef _DEBUG
 #include <stdio.h>
-#define DBG_INFO(...) { char d_buff[128]; \
+#include <stdarg.h>
+#define DBG_INFO(...) do{ char d_buff[128]; \
 	_snprintf_s(d_buff,128, __VA_ARGS__); \
-	::OutputDebugStringA(d_buff);}
+	::OutputDebugStringA(d_buff);}while(0)
+#define TRACE(...) do{ wchar_t d_buff[128]; \
+	_snwprintf_s(d_buff,128, __VA_ARGS__); \
+	::OutputDebugStringW(d_buff);}while(0)
+    void __inline DBGOUT( const char* format,... )
+    {
+        va_list marker ;
+        char edit_str[1024] ;
+        va_start( marker, format ) ;
+        vsprintf_s( edit_str, sizeof(edit_str), format, marker ) ;
+        va_end( marker ) ;
+        #ifndef DEBUG_TO_X_DRIVE
+        OutputDebugStringA(edit_str) ;
+        #else
+        {
+			FILE *fp = NULL ;
+            fopen_s(&fp,"X:\\Debug.txt","a+t") ;
+            if(fp) {
+              fputs(edit_str,fp) ;
+              fclose(fp) ;
+            }
+		}
+        #endif
+    }
 #else
-#define DBG_INFO(...) void()
+#define DBG_INFO(...) /*empty*/
+#define TRACE(...) /*empty*/
+#define DBGOUT(...) /*empty*/
 #endif
+
diff -uPr BonD_FSHybrid-20201009_org/src/types_u.h BonD_FSHybrid-20201009_mod2/src/types_u.h
--- BonD_FSHybrid-20201009_org/src/types_u.h	2016-01-22 09:39:12.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/types_u.h	2020-04-27 00:20:10.000000000 +0900
@@ -13,7 +13,8 @@
 	unsigned  endpoint;    //# USB endpoint
 	void* dev;
 	int (* startstopFunc)(void * const  dev, const int start);
-	unsigned  xfer_size;    //# transfer unit size
+	int (* lockunlockFunc)(void * const  dev, const int lock);
+    unsigned  xfer_size;    //# transfer unit size
 };
 
 struct i2c_device_st {
diff -uPr BonD_FSHybrid-20201009_org/src/uSUNpTV.sln BonD_FSHybrid-20201009_mod2/src/uSUNpTV.sln
--- BonD_FSHybrid-20201009_org/src/uSUNpTV.sln	2016-01-23 00:07:42.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/uSUNpTV.sln	2019-12-16 05:14:42.000000000 +0900
@@ -1,18 +1,26 @@
 ﻿
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual C++ Express 2010
-Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver", "BonDriver\BonDriver_uSUNpTV.vcxproj", "{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.24720.0
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_uSUNpTV", "BonDriver_uSUNpTV\BonDriver_uSUNpTV.vcxproj", "{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
-		Debug|Win32 = Debug|Win32
-		Release|Win32 = Release|Win32
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|Win32.ActiveCfg = Debug|Win32
-		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|Win32.Build.0 = Debug|Win32
-		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|Win32.ActiveCfg = Release|Win32
-		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|Win32.Build.0 = Release|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x64.ActiveCfg = Debug|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x64.Build.0 = Debug|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x86.ActiveCfg = Debug|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x86.Build.0 = Debug|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x64.ActiveCfg = Release|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x64.Build.0 = Release|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x86.ActiveCfg = Release|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x86.Build.0 = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
diff -uPr BonD_FSHybrid-20201009_org/src/uSUNpTV_VS2008.sln BonD_FSHybrid-20201009_mod2/src/uSUNpTV_VS2008.sln
--- BonD_FSHybrid-20201009_org/src/uSUNpTV_VS2008.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/uSUNpTV_VS2008.sln	2019-12-20 14:08:42.000000000 +0900
@@ -0,0 +1,26 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 10.00
+# Visual Studio 2008
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_uSUNpTV", "BonDriver_uSUNpTV\BonDriver_uSUNpTV.vcproj", "{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Debug|x64 = Debug|x64
+		Release|Win32 = Release|Win32
+		Release|x64 = Release|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|Win32.ActiveCfg = Debug|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|Win32.Build.0 = Debug|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x64.ActiveCfg = Debug|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Debug|x64.Build.0 = Debug|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|Win32.ActiveCfg = Release|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|Win32.Build.0 = Release|Win32
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x64.ActiveCfg = Release|x64
+		{A9765A26-A6C9-4135-ADFA-3DA4CF26EE67}.Release|x64.Build.0 = Release|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/uSUNpTV_isoch.sln BonD_FSHybrid-20201009_mod2/src/uSUNpTV_isoch.sln
--- BonD_FSHybrid-20201009_org/src/uSUNpTV_isoch.sln	1970-01-01 09:00:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/uSUNpTV_isoch.sln	2020-10-03 19:38:34.000000000 +0900
@@ -0,0 +1,28 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 14
+VisualStudioVersion = 14.0.25420.1
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BonDriver_uSUNpTV_isoch", "BonDriver_uSUNpTV\BonDriver_uSUNpTV_isoch.vcxproj", "{264FED43-93BD-4D55-B545-DD16668B7BB7}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Debug|x64.ActiveCfg = Debug|x64
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Debug|x64.Build.0 = Debug|x64
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Debug|x86.ActiveCfg = Debug|Win32
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Debug|x86.Build.0 = Debug|Win32
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Release|x64.ActiveCfg = Release|x64
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Release|x64.Build.0 = Release|x64
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Release|x86.ActiveCfg = Release|Win32
+		{264FED43-93BD-4D55-B545-DD16668B7BB7}.Release|x86.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -uPr BonD_FSHybrid-20201009_org/src/usbdevfile.cpp BonD_FSHybrid-20201009_mod2/src/usbdevfile.cpp
--- BonD_FSHybrid-20201009_org/src/usbdevfile.cpp	2016-01-23 00:02:00.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/usbdevfile.cpp	2019-12-16 07:27:20.000000000 +0900
@@ -11,15 +11,11 @@
 
 #include "usbdevfile.h"
 
-// Driver Instance GUID
-DEFINE_GUID( GUID_WINUSB_DRV,	0xa70cc802, 0x7309, 0x486d, 0xbe, 0xe8, 0x93, 0xa0, 0x48, 0xcf, 0x6c, 0x63);
-
-HANDLE usbdevfile_alloc(unsigned int * const idx)
+HANDLE usbdevfile_alloc(int * const idx, const GUID *pDrvID)
 {
 	DWORD dwRet;
 	ULONG length;
 	HANDLE hDev = INVALID_HANDLE_VALUE;
-	GUID * const pDrvID = (GUID *)&GUID_WINUSB_DRV;
 
 	// get handle to device info.
 	HDEVINFO deviceInfo = SetupDiGetClassDevs(pDrvID, NULL, NULL, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
@@ -28,7 +24,10 @@
 	SP_DEVICE_INTERFACE_DATA interfaceData;
 	interfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
 
-	for(; *idx < 40; (*idx)++ ) {
+    const int idmax = (*idx<0) ? 40 : *idx+1 ;
+    if(*idx<0) *idx=0 ;
+
+	for(; *idx < idmax; (*idx)++ ) {
 		//# enumerate device interfaces
 		if( FALSE == SetupDiEnumDeviceInterfaces(deviceInfo, NULL, pDrvID, *idx, &interfaceData) ) {
 			dwRet = GetLastError();
@@ -58,7 +57,7 @@
 		GlobalFree(detailData);
 	}
 	SetupDiDestroyDeviceInfoList(deviceInfo);
-	
+
 	if(INVALID_HANDLE_VALUE == hDev) return NULL;
 	return hDev;
 }
diff -uPr BonD_FSHybrid-20201009_org/src/usbdevfile.h BonD_FSHybrid-20201009_mod2/src/usbdevfile.h
--- BonD_FSHybrid-20201009_org/src/usbdevfile.h	2015-12-10 01:42:56.000000000 +0900
+++ BonD_FSHybrid-20201009_mod2/src/usbdevfile.h	2020-01-01 16:05:48.000000000 +0900
@@ -5,7 +5,12 @@
 */
 #pragma once
 
-HANDLE usbdevfile_alloc(unsigned int * const idx);
+// Driver Instance GUID
+DEFINE_GUID( GUID_WINUSB_FSUSB2N_DRV,	0xb35924d6, 0x3e09, 0x4a9e, 0x97, 0x82, 0x55, 0x24, 0xa4, 0xb7, 0x9b, 0xa4 );
+DEFINE_GUID( GUID_WINUSB_FSUSB2V3_DRV,	0x77ed26ec, 0x2783, 0x7bba, 0xa8, 0x24, 0x00, 0xbc, 0xad, 0x7a, 0xcd, 0xb9 );
+DEFINE_GUID( GUID_WINUSB_US3POUT_DRV,	0xa70cc802, 0x7309, 0x486d, 0xbe, 0xe8, 0x93, 0xa0, 0x48, 0xcf, 0x6c, 0x63 );
+
+HANDLE usbdevfile_alloc(int * const idx, const GUID *pDrvID);
 HANDLE usbdevfile_init(HANDLE hDev);
 void usbdevfile_free(HANDLE usbHandle);
 
